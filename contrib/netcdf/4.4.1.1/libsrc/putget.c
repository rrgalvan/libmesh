#line 9 "putget.m4"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 11
/*
 *	Copyright 1996, University Corporation for Atmospheric Research
 *      See netcdf/COPYRIGHT file for copying and redistribution conditions.
 */
/* $Id: putget.m4 2783 2014-10-26 05:19:35Z wkliao $ */

#include "config.h"
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "netcdf.h"
#include "nc3internal.h"
#include "ncx.h"
#include "fbits.h"
#include "onstack.h"
#ifdef LOCKNUMREC
#  include <mpp/shmem.h>	/* for SGI/Cray SHMEM routines */
#  ifdef LN_TEST
#    include <stdio.h>
#  endif
#endif
#include "nc3dispatch.h"


#undef MIN  /* system may define MIN somewhere and complain */
#define MIN(mm,nn) (((mm) < (nn)) ? (mm) : (nn))

static int
readNCv(const NC3_INFO* ncp, const NC_var* varp, const size_t* start,
        const size_t nelems, void* value, const nc_type memtype);
static int
writeNCv(NC3_INFO* ncp, const NC_var* varp, const size_t* start,
         const size_t nelems, const void* value, const nc_type memtype);


/* #define ODEBUG 1 */

#if ODEBUG
#include <stdio.h>
/*
 * Print the values of an array of size_t
 */
void
arrayp(const char *label, size_t count, const size_t *array)
{
	(void) fprintf(stderr, "%s", label);
	(void) fputc('\t',stderr);
	for(; count > 0; count--, array++)
		(void) fprintf(stderr," %lu", (unsigned long)*array);
	(void) fputc('\n',stderr);
}
#endif /* ODEBUG */


/* Begin fill */
/*
 * This is tunable parameter.
 * It essentially controls the tradeoff between the number of times
 * memcpy() gets called to copy the external data to fill
 * a large buffer vs the number of times its called to
 * prepare the external data.
 */
#if	_SX
/* NEC SX specific optimization */
#define	NFILL	2048
#else
#define	NFILL	16
#endif


#line 107

/*
 * Next 6 type specific functions
 * Fill a some memory with the default special value.
 * Formerly
NC_arrayfill()
 */
static int
#line 114
NC_fill_schar(
#line 114
	void **xpp,
#line 114
	size_t nelems)	/* how many */
#line 114
{
#line 114
	schar fillp[NFILL * sizeof(double)/X_SIZEOF_CHAR];
#line 114

#line 114
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 114

#line 114
	{
#line 114
		schar *vp = fillp;	/* lower bound of area to be filled */
#line 114
		const schar *const end = vp + nelems;
#line 114
		while(vp < end)
#line 114
		{
#line 114
			*vp++ = NC_FILL_BYTE;
#line 114
		}
#line 114
	}
#line 114
	return ncx_putn_schar_schar(xpp, nelems, fillp);
#line 114
}
#line 114

static int
#line 115
NC_fill_char(
#line 115
	void **xpp,
#line 115
	size_t nelems)	/* how many */
#line 115
{
#line 115
	char fillp[NFILL * sizeof(double)/X_SIZEOF_CHAR];
#line 115

#line 115
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 115

#line 115
	{
#line 115
		char *vp = fillp;	/* lower bound of area to be filled */
#line 115
		const char *const end = vp + nelems;
#line 115
		while(vp < end)
#line 115
		{
#line 115
			*vp++ = NC_FILL_CHAR;
#line 115
		}
#line 115
	}
#line 115
	return ncx_putn_char_char(xpp, nelems, fillp);
#line 115
}
#line 115

static int
#line 116
NC_fill_short(
#line 116
	void **xpp,
#line 116
	size_t nelems)	/* how many */
#line 116
{
#line 116
	short fillp[NFILL * sizeof(double)/X_SIZEOF_SHORT];
#line 116

#line 116
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 116

#line 116
	{
#line 116
		short *vp = fillp;	/* lower bound of area to be filled */
#line 116
		const short *const end = vp + nelems;
#line 116
		while(vp < end)
#line 116
		{
#line 116
			*vp++ = NC_FILL_SHORT;
#line 116
		}
#line 116
	}
#line 116
	return ncx_putn_short_short(xpp, nelems, fillp);
#line 116
}
#line 116


#if (SIZEOF_INT >= X_SIZEOF_INT)
static int
#line 119
NC_fill_int(
#line 119
	void **xpp,
#line 119
	size_t nelems)	/* how many */
#line 119
{
#line 119
	int fillp[NFILL * sizeof(double)/X_SIZEOF_INT];
#line 119

#line 119
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 119

#line 119
	{
#line 119
		int *vp = fillp;	/* lower bound of area to be filled */
#line 119
		const int *const end = vp + nelems;
#line 119
		while(vp < end)
#line 119
		{
#line 119
			*vp++ = NC_FILL_INT;
#line 119
		}
#line 119
	}
#line 119
	return ncx_putn_int_int(xpp, nelems, fillp);
#line 119
}
#line 119

#elif SIZEOF_LONG == X_SIZEOF_INT
static int
#line 121
NC_fill_int(
#line 121
	void **xpp,
#line 121
	size_t nelems)	/* how many */
#line 121
{
#line 121
	long fillp[NFILL * sizeof(double)/X_SIZEOF_INT];
#line 121

#line 121
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 121

#line 121
	{
#line 121
		long *vp = fillp;	/* lower bound of area to be filled */
#line 121
		const long *const end = vp + nelems;
#line 121
		while(vp < end)
#line 121
		{
#line 121
			*vp++ = NC_FILL_INT;
#line 121
		}
#line 121
	}
#line 121
	return ncx_putn_int_long(xpp, nelems, fillp);
#line 121
}
#line 121

#else
#error "NC_fill_int implementation"
#endif

static int
#line 126
NC_fill_float(
#line 126
	void **xpp,
#line 126
	size_t nelems)	/* how many */
#line 126
{
#line 126
	float fillp[NFILL * sizeof(double)/X_SIZEOF_FLOAT];
#line 126

#line 126
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 126

#line 126
	{
#line 126
		float *vp = fillp;	/* lower bound of area to be filled */
#line 126
		const float *const end = vp + nelems;
#line 126
		while(vp < end)
#line 126
		{
#line 126
			*vp++ = NC_FILL_FLOAT;
#line 126
		}
#line 126
	}
#line 126
	return ncx_putn_float_float(xpp, nelems, fillp);
#line 126
}
#line 126

static int
#line 127
NC_fill_double(
#line 127
	void **xpp,
#line 127
	size_t nelems)	/* how many */
#line 127
{
#line 127
	double fillp[NFILL * sizeof(double)/X_SIZEOF_DOUBLE];
#line 127

#line 127
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 127

#line 127
	{
#line 127
		double *vp = fillp;	/* lower bound of area to be filled */
#line 127
		const double *const end = vp + nelems;
#line 127
		while(vp < end)
#line 127
		{
#line 127
			*vp++ = NC_FILL_DOUBLE;
#line 127
		}
#line 127
	}
#line 127
	return ncx_putn_double_double(xpp, nelems, fillp);
#line 127
}
#line 127


static int
#line 129
NC_fill_uchar(
#line 129
	void **xpp,
#line 129
	size_t nelems)	/* how many */
#line 129
{
#line 129
	uchar fillp[NFILL * sizeof(double)/X_SIZEOF_UBYTE];
#line 129

#line 129
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 129

#line 129
	{
#line 129
		uchar *vp = fillp;	/* lower bound of area to be filled */
#line 129
		const uchar *const end = vp + nelems;
#line 129
		while(vp < end)
#line 129
		{
#line 129
			*vp++ = NC_FILL_UBYTE;
#line 129
		}
#line 129
	}
#line 129
	return ncx_putn_uchar_uchar(xpp, nelems, fillp);
#line 129
}
#line 129

static int
#line 130
NC_fill_ushort(
#line 130
	void **xpp,
#line 130
	size_t nelems)	/* how many */
#line 130
{
#line 130
	ushort fillp[NFILL * sizeof(double)/X_SIZEOF_USHORT];
#line 130

#line 130
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 130

#line 130
	{
#line 130
		ushort *vp = fillp;	/* lower bound of area to be filled */
#line 130
		const ushort *const end = vp + nelems;
#line 130
		while(vp < end)
#line 130
		{
#line 130
			*vp++ = NC_FILL_USHORT;
#line 130
		}
#line 130
	}
#line 130
	return ncx_putn_ushort_ushort(xpp, nelems, fillp);
#line 130
}
#line 130

static int
#line 131
NC_fill_uint(
#line 131
	void **xpp,
#line 131
	size_t nelems)	/* how many */
#line 131
{
#line 131
	uint fillp[NFILL * sizeof(double)/X_SIZEOF_UINT];
#line 131

#line 131
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 131

#line 131
	{
#line 131
		uint *vp = fillp;	/* lower bound of area to be filled */
#line 131
		const uint *const end = vp + nelems;
#line 131
		while(vp < end)
#line 131
		{
#line 131
			*vp++ = NC_FILL_UINT;
#line 131
		}
#line 131
	}
#line 131
	return ncx_putn_uint_uint(xpp, nelems, fillp);
#line 131
}
#line 131

static int
#line 132
NC_fill_longlong(
#line 132
	void **xpp,
#line 132
	size_t nelems)	/* how many */
#line 132
{
#line 132
	longlong fillp[NFILL * sizeof(double)/X_SIZEOF_LONGLONG];
#line 132

#line 132
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 132

#line 132
	{
#line 132
		longlong *vp = fillp;	/* lower bound of area to be filled */
#line 132
		const longlong *const end = vp + nelems;
#line 132
		while(vp < end)
#line 132
		{
#line 132
			*vp++ = NC_FILL_INT64;
#line 132
		}
#line 132
	}
#line 132
	return ncx_putn_longlong_longlong(xpp, nelems, fillp);
#line 132
}
#line 132

static int
#line 133
NC_fill_ulonglong(
#line 133
	void **xpp,
#line 133
	size_t nelems)	/* how many */
#line 133
{
#line 133
	ulonglong fillp[NFILL * sizeof(double)/X_SIZEOF_ULONGLONG];
#line 133

#line 133
	assert(nelems <= sizeof(fillp)/sizeof(fillp[0]));
#line 133

#line 133
	{
#line 133
		ulonglong *vp = fillp;	/* lower bound of area to be filled */
#line 133
		const ulonglong *const end = vp + nelems;
#line 133
		while(vp < end)
#line 133
		{
#line 133
			*vp++ = NC_FILL_UINT64;
#line 133
		}
#line 133
	}
#line 133
	return ncx_putn_ulonglong_ulonglong(xpp, nelems, fillp);
#line 133
}
#line 133




/*
 * Fill the external space for variable 'varp' values at 'recno' with
 * the appropriate value. If 'varp' is not a record variable, fill the
 * whole thing.  For the special case when 'varp' is the only record
 * variable and it is of type byte, char, or short, varsize should be
 * ncp->recsize, otherwise it should be varp->len.
 * Formerly
xdr_NC_fill()
 */
int
fill_NC_var(NC3_INFO* ncp, const NC_var *varp, size_t varsize, size_t recno)
{
	char xfillp[NFILL * X_SIZEOF_DOUBLE];
	const size_t step = varp->xsz;
	const size_t nelems = sizeof(xfillp)/step;
	const size_t xsz = varp->xsz * nelems;
	NC_attr **attrpp = NULL;
	off_t offset;
	size_t remaining = varsize;

	void *xp;
	int status = NC_NOERR;

	/*
	 * Set up fill value
	 */
	attrpp = NC_findattr(&varp->attrs, _FillValue);
	if( attrpp != NULL )
	{
		/* User defined fill value */
		if( (*attrpp)->type != varp->type || (*attrpp)->nelems != 1 )
		{
			return NC_EBADTYPE;
		}
		else
		{
			/* Use the user defined value */
			char *cp = xfillp;
			const char *const end = &xfillp[sizeof(xfillp)];

			assert(step <= (*attrpp)->xsz);

			for( /*NADA*/; cp < end; cp += step)
			{
				(void) memcpy(cp, (*attrpp)->xvalue, step);
			}
		}
	}
	else
	{
		/* use the default */

		assert(xsz % X_ALIGN == 0);
		assert(xsz <= sizeof(xfillp));

		xp = xfillp;

		switch(varp->type){
		case NC_BYTE :
			status = NC_fill_schar(&xp, nelems);
			break;
		case NC_CHAR :
			status = NC_fill_char(&xp, nelems);
			break;
		case NC_SHORT :
			status = NC_fill_short(&xp, nelems);
			break;
		case NC_INT :
			status = NC_fill_int(&xp, nelems);
			break;
		case NC_FLOAT :
			status = NC_fill_float(&xp, nelems);
			break;
		case NC_DOUBLE :
			status = NC_fill_double(&xp, nelems);
			break;
                case NC_UBYTE :
                        status = NC_fill_uchar(&xp, nelems);
                        break;
                case NC_USHORT :
                        status = NC_fill_ushort(&xp, nelems);
                        break;
                case NC_UINT :
                        status = NC_fill_uint(&xp, nelems);
                        break;
                case NC_INT64 :
                        status = NC_fill_longlong(&xp, nelems);
                        break;
                case NC_UINT64 :
                        status = NC_fill_ulonglong(&xp, nelems);
                        break;
		default :
			assert("fill_NC_var invalid type" == 0);
			status = NC_EBADTYPE;
			break;
		}
		if(status != NC_NOERR)
			return status;

		assert(xp == xfillp + xsz);
	}

	/*
	 * copyout:
	 * xfillp now contains 'nelems' elements of the fill value
	 * in external representation.
	 */

	/*
	 * Copy it out.
	 */

	offset = varp->begin;
	if(IS_RECVAR(varp))
	{
		offset += (off_t)ncp->recsize * recno;
	}

	assert(remaining > 0);
	for(;;)
	{
		const size_t chunksz = MIN(remaining, ncp->chunk);
		size_t ii;

		status = ncio_get(ncp->nciop, offset, chunksz,
				 RGN_WRITE, &xp);
		if(status != NC_NOERR)
		{
			return status;
		}

		/*
		 * fill the chunksz buffer in units  of xsz
		 */
		for(ii = 0; ii < chunksz/xsz; ii++)
		{
			(void) memcpy(xp, xfillp, xsz);
			xp = (char *)xp + xsz;
		}
		/*
		 * Deal with any remainder
		 */
		{
			const size_t rem = chunksz % xsz;
			if(rem != 0)
			{
				(void) memcpy(xp, xfillp, rem);
				/* xp = (char *)xp + xsz; */
			}

		}

		status = ncio_rel(ncp->nciop, offset, RGN_MODIFIED);

		if(status != NC_NOERR)
		{
			break;
		}

		remaining -= chunksz;
		if(remaining == 0)
			break;	/* normal loop exit */
		offset += chunksz;

	}

	return status;
}
/* End fill */


/*
 * Add a record containing the fill values.
 */
static int
NCfillrecord(NC3_INFO* ncp, const NC_var *const *varpp, size_t recno)
{
	size_t ii = 0;
	for(; ii < ncp->vars.nelems; ii++, varpp++)
	{
		if( !IS_RECVAR(*varpp) )
		{
			continue;	/* skip non-record variables */
		}
		{
		const int status = fill_NC_var(ncp, *varpp, (*varpp)->len, recno);
		if(status != NC_NOERR)
			return status;
		}
	}
	return NC_NOERR;
}


/*
 * Add a record containing the fill values in the special case when
 * there is exactly one record variable, where we don't require each
 * record to be four-byte aligned (no record padding).
 */
static int
NCfillspecialrecord(NC3_INFO* ncp, const NC_var *varp, size_t recno)
{
    int status;
    assert(IS_RECVAR(varp));
    status = fill_NC_var(ncp, varp, ncp->recsize, recno);
    if(status != NC_NOERR)
	return status;
    return NC_NOERR;
}


/*
 * It is advantageous to
 * #define TOUCH_LAST
 * when using memory mapped io.
 */
#if TOUCH_LAST
/*
 * Grow the file to a size which can contain recno
 */
static int
NCtouchlast(NC3_INFO* ncp, const NC_var *const *varpp, size_t recno)
{
	int status = NC_NOERR;
	const NC_var *varp = NULL;

	{
	size_t ii = 0;
	for(; ii < ncp->vars.nelems; ii++, varpp++)
	{
		if( !IS_RECVAR(*varpp) )
		{
			continue;	/* skip non-record variables */
		}
		varp = *varpp;
	}
	}
	assert(varp != NULL);
	assert( IS_RECVAR(varp) );
	{
		const off_t offset = varp->begin
				+ (off_t)(recno-1) * (off_t)ncp->recsize
				+ (off_t)(varp->len - varp->xsz);
		void *xp;


		status = ncio_get(ncp->nciop, offset, varp->xsz,
				 RGN_WRITE, &xp);
		if(status != NC_NOERR)
			return status;
		(void)memset(xp, 0, varp->xsz);
		status = ncio_rel(ncp->nciop, offset, RGN_MODIFIED);
	}
	return status;
}
#endif /* TOUCH_LAST */


/*
 * Ensure that the netcdf file has 'numrecs' records,
 * add records and fill as necessary.
 */
static int
NCvnrecs(NC3_INFO* ncp, size_t numrecs)
{
	int status = NC_NOERR;
#ifdef LOCKNUMREC
	ushmem_t myticket = 0, nowserving = 0;
	ushmem_t numpe = (ushmem_t) _num_pes();

	/* get ticket and wait */
	myticket = shmem_short_finc((shmem_t *) ncp->lock + LOCKNUMREC_LOCK,
		ncp->lock[LOCKNUMREC_BASEPE]);
#ifdef LN_TEST
		fprintf(stderr,"%d of %d : ticket = %hu\n",
			_my_pe(), _num_pes(), myticket);
#endif
	do {
		shmem_short_get((shmem_t *) &nowserving,
			(shmem_t *) ncp->lock + LOCKNUMREC_SERVING, 1,
			ncp->lock[LOCKNUMREC_BASEPE]);
#ifdef LN_TEST
		fprintf(stderr,"%d of %d : serving = %hu\n",
			_my_pe(), _num_pes(), nowserving);
#endif
		/* work-around for non-unique tickets */
		if (nowserving > myticket && nowserving < myticket + numpe ) {
			/* get a new ticket ... you've been bypassed */
			/* and handle the unlikely wrap-around effect */
			myticket = shmem_short_finc(
				(shmem_t *) ncp->lock + LOCKNUMREC_LOCK,
				ncp->lock[LOCKNUMREC_BASEPE]);
#ifdef LN_TEST
				fprintf(stderr,"%d of %d : new ticket = %hu\n",
					_my_pe(), _num_pes(), myticket);
#endif
		}
	} while(nowserving != myticket);
	/* now our turn to check & update value */
#endif

	if(numrecs > NC_get_numrecs(ncp))
	{


#if TOUCH_LAST
		status = NCtouchlast(ncp,
			(const NC_var *const*)ncp->vars.value,
			numrecs);
		if(status != NC_NOERR)
			goto common_return;
#endif /* TOUCH_LAST */

		set_NC_ndirty(ncp);

		if(!NC_dofill(ncp))
		{
			/* Simply set the new numrecs value */
			NC_set_numrecs(ncp, numrecs);
		}
		else
		{
		    /* Treat two cases differently:
		        - exactly one record variable (no padding)
                        - multiple record variables (each record padded
                          to 4-byte alignment)
		    */
		    NC_var **vpp = (NC_var **)ncp->vars.value;
		    NC_var *const *const end = &vpp[ncp->vars.nelems];
		    NC_var *recvarp = NULL;	/* last record var */
		    int numrecvars = 0;
		    size_t cur_nrecs;

		    /* determine how many record variables */
		    for( /*NADA*/; vpp < end; vpp++) {
			if(IS_RECVAR(*vpp)) {
			    recvarp = *vpp;
			    numrecvars++;
			}
		    }

		    if (numrecvars != 1) { /* usual case */
			/* Fill each record out to numrecs */
			while((cur_nrecs = NC_get_numrecs(ncp)) < numrecs)
			    {
				status = NCfillrecord(ncp,
					(const NC_var *const*)ncp->vars.value,
					cur_nrecs);
				if(status != NC_NOERR)
				{
					break;
				}
				NC_increase_numrecs(ncp, cur_nrecs +1);
			}
			if(status != NC_NOERR)
				goto common_return;
		    } else {	/* special case */
			/* Fill each record out to numrecs */
			while((cur_nrecs = NC_get_numrecs(ncp)) < numrecs)
			    {
				status = NCfillspecialrecord(ncp,
					recvarp,
					cur_nrecs);
				if(status != NC_NOERR)
				{
					break;
				}
				NC_increase_numrecs(ncp, cur_nrecs +1);
			}
			if(status != NC_NOERR)
				goto common_return;

		    }
		}

		if(NC_doNsync(ncp))
		{
			status = write_numrecs(ncp);
		}

	}
common_return:
#ifdef LOCKNUMREC
	/* finished with our lock - increment serving number */
	(void) shmem_short_finc((shmem_t *) ncp->lock + LOCKNUMREC_SERVING,
		ncp->lock[LOCKNUMREC_BASEPE]);
#endif
	return status;
}


/*
 * Check whether 'coord' values are valid for the variable.
 */
static int
NCcoordck(NC3_INFO* ncp, const NC_var *varp, const size_t *coord)
{
	const size_t *ip;
	size_t *up;

	if(varp->ndims == 0)
		return NC_NOERR;	/* 'scalar' variable */

	if(IS_RECVAR(varp))
	{
		if(*coord > X_UINT_MAX) /* rkr: bug fix from previous X_INT_MAX */
			return NC_EINVALCOORDS; /* sanity check */
		if(NC_readonly(ncp) && *coord >= NC_get_numrecs(ncp))
		{
			if(!NC_doNsync(ncp))
				return NC_EINVALCOORDS;
			/* else */
			{
				/* Update from disk and check again */
				const int status = read_numrecs(ncp);
				if(status != NC_NOERR)
					return status;
				if(*coord >= NC_get_numrecs(ncp))
					return NC_EINVALCOORDS;
			}
		}
		ip = coord + 1;
		up = varp->shape + 1;
	}
	else
	{
		ip = coord;
		up = varp->shape;
	}

#ifdef CDEBUG
fprintf(stderr,"	NCcoordck: coord %ld, count %d, ip %ld\n",
		coord, varp->ndims, ip );
#endif /* CDEBUG */

	for(; ip < coord + varp->ndims; ip++, up++)
	{

#ifdef CDEBUG
fprintf(stderr,"	NCcoordck: ip %p, *ip %ld, up %p, *up %lu\n",
			ip, *ip, up, *up );
#endif /* CDEBUG */

		/* cast needed for braindead systems with signed size_t */
		if((unsigned long) *ip >= (unsigned long) *up )
			return NC_EINVALCOORDS;
	}

	return NC_NOERR;
}


/*
 * Check whether 'edges' are valid for the variable and 'start'
 */
/*ARGSUSED*/
static int
NCedgeck(const NC3_INFO* ncp, const NC_var *varp,
	 const size_t *start, const size_t *edges)
{
	const size_t *const end = start + varp->ndims;
	const size_t *shp = varp->shape;

	if(varp->ndims == 0)
		return NC_NOERR;	/* 'scalar' variable */

	if(IS_RECVAR(varp))
	{
		start++;
		edges++;
		shp++;
	}

	for(; start < end; start++, edges++, shp++)
	{
		/* cast needed for braindead systems with signed size_t */
		if((unsigned long) *edges > *shp ||
			(unsigned long) *start + (unsigned long) *edges > *shp)
		{
			return(NC_EEDGE);
		}
	}
	return NC_NOERR;
}


/*
 * Translate the (variable, coord) pair into a seek index
 */
static off_t
NC_varoffset(const NC3_INFO* ncp, const NC_var *varp, const size_t *coord)
{
	if(varp->ndims == 0) /* 'scalar' variable */
		return varp->begin;

	if(varp->ndims == 1)
	{
		if(IS_RECVAR(varp))
			return varp->begin +
				 (off_t)(*coord) * (off_t)ncp->recsize;
		/* else */
		return varp->begin + (off_t)(*coord) * (off_t)varp->xsz;
	}
	/* else */
	{
		off_t lcoord = (off_t)coord[varp->ndims -1];

		off_t *up = varp->dsizes +1;
		const size_t *ip = coord;
		const off_t *const end = varp->dsizes + varp->ndims;

		if(IS_RECVAR(varp))
			up++, ip++;

		for(; up < end; up++, ip++)
			lcoord += (off_t)(*up) * (off_t)(*ip);

		lcoord *= varp->xsz;

		if(IS_RECVAR(varp))
			lcoord += (off_t)(*coord) * ncp->recsize;

		lcoord += varp->begin;
		return lcoord;
	}
}


#line 720

static int
#line 721
putNCvx_char_char(NC3_INFO* ncp, const NC_var *varp,
#line 721
		 const size_t *start, size_t nelems, const char *value)
#line 721
{
#line 721
	off_t offset = NC_varoffset(ncp, varp, start);
#line 721
	size_t remaining = varp->xsz * nelems;
#line 721
	int status = NC_NOERR;
#line 721
	void *xp;
#line 721

#line 721
	if(nelems == 0)
#line 721
		return NC_NOERR;
#line 721

#line 721
	assert(value != NULL);
#line 721

#line 721
	for(;;)
#line 721
	{
#line 721
		size_t extent = MIN(remaining, ncp->chunk);
#line 721
		size_t nput = ncx_howmany(varp->type, extent);
#line 721

#line 721
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 721
				 RGN_WRITE, &xp);
#line 721
		if(lstatus != NC_NOERR)
#line 721
			return lstatus;
#line 721

#line 721
		lstatus = ncx_putn_char_char(&xp, nput, value);
#line 721
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 721
		{
#line 721
			/* not fatal to the loop */
#line 721
			status = lstatus;
#line 721
		}
#line 721

#line 721
		(void) ncio_rel(ncp->nciop, offset,
#line 721
				 RGN_MODIFIED);
#line 721

#line 721
		remaining -= extent;
#line 721
		if(remaining == 0)
#line 721
			break; /* normal loop exit */
#line 721
		offset += extent;
#line 721
		value += nput;
#line 721

#line 721
	}
#line 721

#line 721
	return status;
#line 721
}
#line 721


static int
#line 723
putNCvx_schar_schar(NC3_INFO* ncp, const NC_var *varp,
#line 723
		 const size_t *start, size_t nelems, const schar *value)
#line 723
{
#line 723
	off_t offset = NC_varoffset(ncp, varp, start);
#line 723
	size_t remaining = varp->xsz * nelems;
#line 723
	int status = NC_NOERR;
#line 723
	void *xp;
#line 723

#line 723
	if(nelems == 0)
#line 723
		return NC_NOERR;
#line 723

#line 723
	assert(value != NULL);
#line 723

#line 723
	for(;;)
#line 723
	{
#line 723
		size_t extent = MIN(remaining, ncp->chunk);
#line 723
		size_t nput = ncx_howmany(varp->type, extent);
#line 723

#line 723
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 723
				 RGN_WRITE, &xp);
#line 723
		if(lstatus != NC_NOERR)
#line 723
			return lstatus;
#line 723

#line 723
		lstatus = ncx_putn_schar_schar(&xp, nput, value);
#line 723
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 723
		{
#line 723
			/* not fatal to the loop */
#line 723
			status = lstatus;
#line 723
		}
#line 723

#line 723
		(void) ncio_rel(ncp->nciop, offset,
#line 723
				 RGN_MODIFIED);
#line 723

#line 723
		remaining -= extent;
#line 723
		if(remaining == 0)
#line 723
			break; /* normal loop exit */
#line 723
		offset += extent;
#line 723
		value += nput;
#line 723

#line 723
	}
#line 723

#line 723
	return status;
#line 723
}
#line 723

static int
#line 724
putNCvx_schar_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 724
		 const size_t *start, size_t nelems, const uchar *value)
#line 724
{
#line 724
	off_t offset = NC_varoffset(ncp, varp, start);
#line 724
	size_t remaining = varp->xsz * nelems;
#line 724
	int status = NC_NOERR;
#line 724
	void *xp;
#line 724

#line 724
	if(nelems == 0)
#line 724
		return NC_NOERR;
#line 724

#line 724
	assert(value != NULL);
#line 724

#line 724
	for(;;)
#line 724
	{
#line 724
		size_t extent = MIN(remaining, ncp->chunk);
#line 724
		size_t nput = ncx_howmany(varp->type, extent);
#line 724

#line 724
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 724
				 RGN_WRITE, &xp);
#line 724
		if(lstatus != NC_NOERR)
#line 724
			return lstatus;
#line 724

#line 724
		lstatus = ncx_putn_schar_uchar(&xp, nput, value);
#line 724
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 724
		{
#line 724
			/* not fatal to the loop */
#line 724
			status = lstatus;
#line 724
		}
#line 724

#line 724
		(void) ncio_rel(ncp->nciop, offset,
#line 724
				 RGN_MODIFIED);
#line 724

#line 724
		remaining -= extent;
#line 724
		if(remaining == 0)
#line 724
			break; /* normal loop exit */
#line 724
		offset += extent;
#line 724
		value += nput;
#line 724

#line 724
	}
#line 724

#line 724
	return status;
#line 724
}
#line 724

static int
#line 725
putNCvx_schar_short(NC3_INFO* ncp, const NC_var *varp,
#line 725
		 const size_t *start, size_t nelems, const short *value)
#line 725
{
#line 725
	off_t offset = NC_varoffset(ncp, varp, start);
#line 725
	size_t remaining = varp->xsz * nelems;
#line 725
	int status = NC_NOERR;
#line 725
	void *xp;
#line 725

#line 725
	if(nelems == 0)
#line 725
		return NC_NOERR;
#line 725

#line 725
	assert(value != NULL);
#line 725

#line 725
	for(;;)
#line 725
	{
#line 725
		size_t extent = MIN(remaining, ncp->chunk);
#line 725
		size_t nput = ncx_howmany(varp->type, extent);
#line 725

#line 725
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 725
				 RGN_WRITE, &xp);
#line 725
		if(lstatus != NC_NOERR)
#line 725
			return lstatus;
#line 725

#line 725
		lstatus = ncx_putn_schar_short(&xp, nput, value);
#line 725
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 725
		{
#line 725
			/* not fatal to the loop */
#line 725
			status = lstatus;
#line 725
		}
#line 725

#line 725
		(void) ncio_rel(ncp->nciop, offset,
#line 725
				 RGN_MODIFIED);
#line 725

#line 725
		remaining -= extent;
#line 725
		if(remaining == 0)
#line 725
			break; /* normal loop exit */
#line 725
		offset += extent;
#line 725
		value += nput;
#line 725

#line 725
	}
#line 725

#line 725
	return status;
#line 725
}
#line 725

static int
#line 726
putNCvx_schar_int(NC3_INFO* ncp, const NC_var *varp,
#line 726
		 const size_t *start, size_t nelems, const int *value)
#line 726
{
#line 726
	off_t offset = NC_varoffset(ncp, varp, start);
#line 726
	size_t remaining = varp->xsz * nelems;
#line 726
	int status = NC_NOERR;
#line 726
	void *xp;
#line 726

#line 726
	if(nelems == 0)
#line 726
		return NC_NOERR;
#line 726

#line 726
	assert(value != NULL);
#line 726

#line 726
	for(;;)
#line 726
	{
#line 726
		size_t extent = MIN(remaining, ncp->chunk);
#line 726
		size_t nput = ncx_howmany(varp->type, extent);
#line 726

#line 726
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 726
				 RGN_WRITE, &xp);
#line 726
		if(lstatus != NC_NOERR)
#line 726
			return lstatus;
#line 726

#line 726
		lstatus = ncx_putn_schar_int(&xp, nput, value);
#line 726
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 726
		{
#line 726
			/* not fatal to the loop */
#line 726
			status = lstatus;
#line 726
		}
#line 726

#line 726
		(void) ncio_rel(ncp->nciop, offset,
#line 726
				 RGN_MODIFIED);
#line 726

#line 726
		remaining -= extent;
#line 726
		if(remaining == 0)
#line 726
			break; /* normal loop exit */
#line 726
		offset += extent;
#line 726
		value += nput;
#line 726

#line 726
	}
#line 726

#line 726
	return status;
#line 726
}
#line 726

static int
#line 727
putNCvx_schar_float(NC3_INFO* ncp, const NC_var *varp,
#line 727
		 const size_t *start, size_t nelems, const float *value)
#line 727
{
#line 727
	off_t offset = NC_varoffset(ncp, varp, start);
#line 727
	size_t remaining = varp->xsz * nelems;
#line 727
	int status = NC_NOERR;
#line 727
	void *xp;
#line 727

#line 727
	if(nelems == 0)
#line 727
		return NC_NOERR;
#line 727

#line 727
	assert(value != NULL);
#line 727

#line 727
	for(;;)
#line 727
	{
#line 727
		size_t extent = MIN(remaining, ncp->chunk);
#line 727
		size_t nput = ncx_howmany(varp->type, extent);
#line 727

#line 727
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 727
				 RGN_WRITE, &xp);
#line 727
		if(lstatus != NC_NOERR)
#line 727
			return lstatus;
#line 727

#line 727
		lstatus = ncx_putn_schar_float(&xp, nput, value);
#line 727
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 727
		{
#line 727
			/* not fatal to the loop */
#line 727
			status = lstatus;
#line 727
		}
#line 727

#line 727
		(void) ncio_rel(ncp->nciop, offset,
#line 727
				 RGN_MODIFIED);
#line 727

#line 727
		remaining -= extent;
#line 727
		if(remaining == 0)
#line 727
			break; /* normal loop exit */
#line 727
		offset += extent;
#line 727
		value += nput;
#line 727

#line 727
	}
#line 727

#line 727
	return status;
#line 727
}
#line 727

static int
#line 728
putNCvx_schar_double(NC3_INFO* ncp, const NC_var *varp,
#line 728
		 const size_t *start, size_t nelems, const double *value)
#line 728
{
#line 728
	off_t offset = NC_varoffset(ncp, varp, start);
#line 728
	size_t remaining = varp->xsz * nelems;
#line 728
	int status = NC_NOERR;
#line 728
	void *xp;
#line 728

#line 728
	if(nelems == 0)
#line 728
		return NC_NOERR;
#line 728

#line 728
	assert(value != NULL);
#line 728

#line 728
	for(;;)
#line 728
	{
#line 728
		size_t extent = MIN(remaining, ncp->chunk);
#line 728
		size_t nput = ncx_howmany(varp->type, extent);
#line 728

#line 728
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 728
				 RGN_WRITE, &xp);
#line 728
		if(lstatus != NC_NOERR)
#line 728
			return lstatus;
#line 728

#line 728
		lstatus = ncx_putn_schar_double(&xp, nput, value);
#line 728
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 728
		{
#line 728
			/* not fatal to the loop */
#line 728
			status = lstatus;
#line 728
		}
#line 728

#line 728
		(void) ncio_rel(ncp->nciop, offset,
#line 728
				 RGN_MODIFIED);
#line 728

#line 728
		remaining -= extent;
#line 728
		if(remaining == 0)
#line 728
			break; /* normal loop exit */
#line 728
		offset += extent;
#line 728
		value += nput;
#line 728

#line 728
	}
#line 728

#line 728
	return status;
#line 728
}
#line 728

static int
#line 729
putNCvx_schar_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 729
		 const size_t *start, size_t nelems, const longlong *value)
#line 729
{
#line 729
	off_t offset = NC_varoffset(ncp, varp, start);
#line 729
	size_t remaining = varp->xsz * nelems;
#line 729
	int status = NC_NOERR;
#line 729
	void *xp;
#line 729

#line 729
	if(nelems == 0)
#line 729
		return NC_NOERR;
#line 729

#line 729
	assert(value != NULL);
#line 729

#line 729
	for(;;)
#line 729
	{
#line 729
		size_t extent = MIN(remaining, ncp->chunk);
#line 729
		size_t nput = ncx_howmany(varp->type, extent);
#line 729

#line 729
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 729
				 RGN_WRITE, &xp);
#line 729
		if(lstatus != NC_NOERR)
#line 729
			return lstatus;
#line 729

#line 729
		lstatus = ncx_putn_schar_longlong(&xp, nput, value);
#line 729
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 729
		{
#line 729
			/* not fatal to the loop */
#line 729
			status = lstatus;
#line 729
		}
#line 729

#line 729
		(void) ncio_rel(ncp->nciop, offset,
#line 729
				 RGN_MODIFIED);
#line 729

#line 729
		remaining -= extent;
#line 729
		if(remaining == 0)
#line 729
			break; /* normal loop exit */
#line 729
		offset += extent;
#line 729
		value += nput;
#line 729

#line 729
	}
#line 729

#line 729
	return status;
#line 729
}
#line 729

static int
#line 730
putNCvx_schar_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 730
		 const size_t *start, size_t nelems, const ushort *value)
#line 730
{
#line 730
	off_t offset = NC_varoffset(ncp, varp, start);
#line 730
	size_t remaining = varp->xsz * nelems;
#line 730
	int status = NC_NOERR;
#line 730
	void *xp;
#line 730

#line 730
	if(nelems == 0)
#line 730
		return NC_NOERR;
#line 730

#line 730
	assert(value != NULL);
#line 730

#line 730
	for(;;)
#line 730
	{
#line 730
		size_t extent = MIN(remaining, ncp->chunk);
#line 730
		size_t nput = ncx_howmany(varp->type, extent);
#line 730

#line 730
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 730
				 RGN_WRITE, &xp);
#line 730
		if(lstatus != NC_NOERR)
#line 730
			return lstatus;
#line 730

#line 730
		lstatus = ncx_putn_schar_ushort(&xp, nput, value);
#line 730
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 730
		{
#line 730
			/* not fatal to the loop */
#line 730
			status = lstatus;
#line 730
		}
#line 730

#line 730
		(void) ncio_rel(ncp->nciop, offset,
#line 730
				 RGN_MODIFIED);
#line 730

#line 730
		remaining -= extent;
#line 730
		if(remaining == 0)
#line 730
			break; /* normal loop exit */
#line 730
		offset += extent;
#line 730
		value += nput;
#line 730

#line 730
	}
#line 730

#line 730
	return status;
#line 730
}
#line 730

static int
#line 731
putNCvx_schar_uint(NC3_INFO* ncp, const NC_var *varp,
#line 731
		 const size_t *start, size_t nelems, const uint *value)
#line 731
{
#line 731
	off_t offset = NC_varoffset(ncp, varp, start);
#line 731
	size_t remaining = varp->xsz * nelems;
#line 731
	int status = NC_NOERR;
#line 731
	void *xp;
#line 731

#line 731
	if(nelems == 0)
#line 731
		return NC_NOERR;
#line 731

#line 731
	assert(value != NULL);
#line 731

#line 731
	for(;;)
#line 731
	{
#line 731
		size_t extent = MIN(remaining, ncp->chunk);
#line 731
		size_t nput = ncx_howmany(varp->type, extent);
#line 731

#line 731
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 731
				 RGN_WRITE, &xp);
#line 731
		if(lstatus != NC_NOERR)
#line 731
			return lstatus;
#line 731

#line 731
		lstatus = ncx_putn_schar_uint(&xp, nput, value);
#line 731
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 731
		{
#line 731
			/* not fatal to the loop */
#line 731
			status = lstatus;
#line 731
		}
#line 731

#line 731
		(void) ncio_rel(ncp->nciop, offset,
#line 731
				 RGN_MODIFIED);
#line 731

#line 731
		remaining -= extent;
#line 731
		if(remaining == 0)
#line 731
			break; /* normal loop exit */
#line 731
		offset += extent;
#line 731
		value += nput;
#line 731

#line 731
	}
#line 731

#line 731
	return status;
#line 731
}
#line 731

static int
#line 732
putNCvx_schar_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 732
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 732
{
#line 732
	off_t offset = NC_varoffset(ncp, varp, start);
#line 732
	size_t remaining = varp->xsz * nelems;
#line 732
	int status = NC_NOERR;
#line 732
	void *xp;
#line 732

#line 732
	if(nelems == 0)
#line 732
		return NC_NOERR;
#line 732

#line 732
	assert(value != NULL);
#line 732

#line 732
	for(;;)
#line 732
	{
#line 732
		size_t extent = MIN(remaining, ncp->chunk);
#line 732
		size_t nput = ncx_howmany(varp->type, extent);
#line 732

#line 732
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 732
				 RGN_WRITE, &xp);
#line 732
		if(lstatus != NC_NOERR)
#line 732
			return lstatus;
#line 732

#line 732
		lstatus = ncx_putn_schar_ulonglong(&xp, nput, value);
#line 732
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 732
		{
#line 732
			/* not fatal to the loop */
#line 732
			status = lstatus;
#line 732
		}
#line 732

#line 732
		(void) ncio_rel(ncp->nciop, offset,
#line 732
				 RGN_MODIFIED);
#line 732

#line 732
		remaining -= extent;
#line 732
		if(remaining == 0)
#line 732
			break; /* normal loop exit */
#line 732
		offset += extent;
#line 732
		value += nput;
#line 732

#line 732
	}
#line 732

#line 732
	return status;
#line 732
}
#line 732


static int
#line 734
putNCvx_short_schar(NC3_INFO* ncp, const NC_var *varp,
#line 734
		 const size_t *start, size_t nelems, const schar *value)
#line 734
{
#line 734
	off_t offset = NC_varoffset(ncp, varp, start);
#line 734
	size_t remaining = varp->xsz * nelems;
#line 734
	int status = NC_NOERR;
#line 734
	void *xp;
#line 734

#line 734
	if(nelems == 0)
#line 734
		return NC_NOERR;
#line 734

#line 734
	assert(value != NULL);
#line 734

#line 734
	for(;;)
#line 734
	{
#line 734
		size_t extent = MIN(remaining, ncp->chunk);
#line 734
		size_t nput = ncx_howmany(varp->type, extent);
#line 734

#line 734
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 734
				 RGN_WRITE, &xp);
#line 734
		if(lstatus != NC_NOERR)
#line 734
			return lstatus;
#line 734

#line 734
		lstatus = ncx_putn_short_schar(&xp, nput, value);
#line 734
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 734
		{
#line 734
			/* not fatal to the loop */
#line 734
			status = lstatus;
#line 734
		}
#line 734

#line 734
		(void) ncio_rel(ncp->nciop, offset,
#line 734
				 RGN_MODIFIED);
#line 734

#line 734
		remaining -= extent;
#line 734
		if(remaining == 0)
#line 734
			break; /* normal loop exit */
#line 734
		offset += extent;
#line 734
		value += nput;
#line 734

#line 734
	}
#line 734

#line 734
	return status;
#line 734
}
#line 734

static int
#line 735
putNCvx_short_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 735
		 const size_t *start, size_t nelems, const uchar *value)
#line 735
{
#line 735
	off_t offset = NC_varoffset(ncp, varp, start);
#line 735
	size_t remaining = varp->xsz * nelems;
#line 735
	int status = NC_NOERR;
#line 735
	void *xp;
#line 735

#line 735
	if(nelems == 0)
#line 735
		return NC_NOERR;
#line 735

#line 735
	assert(value != NULL);
#line 735

#line 735
	for(;;)
#line 735
	{
#line 735
		size_t extent = MIN(remaining, ncp->chunk);
#line 735
		size_t nput = ncx_howmany(varp->type, extent);
#line 735

#line 735
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 735
				 RGN_WRITE, &xp);
#line 735
		if(lstatus != NC_NOERR)
#line 735
			return lstatus;
#line 735

#line 735
		lstatus = ncx_putn_short_uchar(&xp, nput, value);
#line 735
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 735
		{
#line 735
			/* not fatal to the loop */
#line 735
			status = lstatus;
#line 735
		}
#line 735

#line 735
		(void) ncio_rel(ncp->nciop, offset,
#line 735
				 RGN_MODIFIED);
#line 735

#line 735
		remaining -= extent;
#line 735
		if(remaining == 0)
#line 735
			break; /* normal loop exit */
#line 735
		offset += extent;
#line 735
		value += nput;
#line 735

#line 735
	}
#line 735

#line 735
	return status;
#line 735
}
#line 735

static int
#line 736
putNCvx_short_short(NC3_INFO* ncp, const NC_var *varp,
#line 736
		 const size_t *start, size_t nelems, const short *value)
#line 736
{
#line 736
	off_t offset = NC_varoffset(ncp, varp, start);
#line 736
	size_t remaining = varp->xsz * nelems;
#line 736
	int status = NC_NOERR;
#line 736
	void *xp;
#line 736

#line 736
	if(nelems == 0)
#line 736
		return NC_NOERR;
#line 736

#line 736
	assert(value != NULL);
#line 736

#line 736
	for(;;)
#line 736
	{
#line 736
		size_t extent = MIN(remaining, ncp->chunk);
#line 736
		size_t nput = ncx_howmany(varp->type, extent);
#line 736

#line 736
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 736
				 RGN_WRITE, &xp);
#line 736
		if(lstatus != NC_NOERR)
#line 736
			return lstatus;
#line 736

#line 736
		lstatus = ncx_putn_short_short(&xp, nput, value);
#line 736
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 736
		{
#line 736
			/* not fatal to the loop */
#line 736
			status = lstatus;
#line 736
		}
#line 736

#line 736
		(void) ncio_rel(ncp->nciop, offset,
#line 736
				 RGN_MODIFIED);
#line 736

#line 736
		remaining -= extent;
#line 736
		if(remaining == 0)
#line 736
			break; /* normal loop exit */
#line 736
		offset += extent;
#line 736
		value += nput;
#line 736

#line 736
	}
#line 736

#line 736
	return status;
#line 736
}
#line 736

static int
#line 737
putNCvx_short_int(NC3_INFO* ncp, const NC_var *varp,
#line 737
		 const size_t *start, size_t nelems, const int *value)
#line 737
{
#line 737
	off_t offset = NC_varoffset(ncp, varp, start);
#line 737
	size_t remaining = varp->xsz * nelems;
#line 737
	int status = NC_NOERR;
#line 737
	void *xp;
#line 737

#line 737
	if(nelems == 0)
#line 737
		return NC_NOERR;
#line 737

#line 737
	assert(value != NULL);
#line 737

#line 737
	for(;;)
#line 737
	{
#line 737
		size_t extent = MIN(remaining, ncp->chunk);
#line 737
		size_t nput = ncx_howmany(varp->type, extent);
#line 737

#line 737
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 737
				 RGN_WRITE, &xp);
#line 737
		if(lstatus != NC_NOERR)
#line 737
			return lstatus;
#line 737

#line 737
		lstatus = ncx_putn_short_int(&xp, nput, value);
#line 737
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 737
		{
#line 737
			/* not fatal to the loop */
#line 737
			status = lstatus;
#line 737
		}
#line 737

#line 737
		(void) ncio_rel(ncp->nciop, offset,
#line 737
				 RGN_MODIFIED);
#line 737

#line 737
		remaining -= extent;
#line 737
		if(remaining == 0)
#line 737
			break; /* normal loop exit */
#line 737
		offset += extent;
#line 737
		value += nput;
#line 737

#line 737
	}
#line 737

#line 737
	return status;
#line 737
}
#line 737

static int
#line 738
putNCvx_short_float(NC3_INFO* ncp, const NC_var *varp,
#line 738
		 const size_t *start, size_t nelems, const float *value)
#line 738
{
#line 738
	off_t offset = NC_varoffset(ncp, varp, start);
#line 738
	size_t remaining = varp->xsz * nelems;
#line 738
	int status = NC_NOERR;
#line 738
	void *xp;
#line 738

#line 738
	if(nelems == 0)
#line 738
		return NC_NOERR;
#line 738

#line 738
	assert(value != NULL);
#line 738

#line 738
	for(;;)
#line 738
	{
#line 738
		size_t extent = MIN(remaining, ncp->chunk);
#line 738
		size_t nput = ncx_howmany(varp->type, extent);
#line 738

#line 738
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 738
				 RGN_WRITE, &xp);
#line 738
		if(lstatus != NC_NOERR)
#line 738
			return lstatus;
#line 738

#line 738
		lstatus = ncx_putn_short_float(&xp, nput, value);
#line 738
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 738
		{
#line 738
			/* not fatal to the loop */
#line 738
			status = lstatus;
#line 738
		}
#line 738

#line 738
		(void) ncio_rel(ncp->nciop, offset,
#line 738
				 RGN_MODIFIED);
#line 738

#line 738
		remaining -= extent;
#line 738
		if(remaining == 0)
#line 738
			break; /* normal loop exit */
#line 738
		offset += extent;
#line 738
		value += nput;
#line 738

#line 738
	}
#line 738

#line 738
	return status;
#line 738
}
#line 738

static int
#line 739
putNCvx_short_double(NC3_INFO* ncp, const NC_var *varp,
#line 739
		 const size_t *start, size_t nelems, const double *value)
#line 739
{
#line 739
	off_t offset = NC_varoffset(ncp, varp, start);
#line 739
	size_t remaining = varp->xsz * nelems;
#line 739
	int status = NC_NOERR;
#line 739
	void *xp;
#line 739

#line 739
	if(nelems == 0)
#line 739
		return NC_NOERR;
#line 739

#line 739
	assert(value != NULL);
#line 739

#line 739
	for(;;)
#line 739
	{
#line 739
		size_t extent = MIN(remaining, ncp->chunk);
#line 739
		size_t nput = ncx_howmany(varp->type, extent);
#line 739

#line 739
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 739
				 RGN_WRITE, &xp);
#line 739
		if(lstatus != NC_NOERR)
#line 739
			return lstatus;
#line 739

#line 739
		lstatus = ncx_putn_short_double(&xp, nput, value);
#line 739
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 739
		{
#line 739
			/* not fatal to the loop */
#line 739
			status = lstatus;
#line 739
		}
#line 739

#line 739
		(void) ncio_rel(ncp->nciop, offset,
#line 739
				 RGN_MODIFIED);
#line 739

#line 739
		remaining -= extent;
#line 739
		if(remaining == 0)
#line 739
			break; /* normal loop exit */
#line 739
		offset += extent;
#line 739
		value += nput;
#line 739

#line 739
	}
#line 739

#line 739
	return status;
#line 739
}
#line 739

static int
#line 740
putNCvx_short_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 740
		 const size_t *start, size_t nelems, const longlong *value)
#line 740
{
#line 740
	off_t offset = NC_varoffset(ncp, varp, start);
#line 740
	size_t remaining = varp->xsz * nelems;
#line 740
	int status = NC_NOERR;
#line 740
	void *xp;
#line 740

#line 740
	if(nelems == 0)
#line 740
		return NC_NOERR;
#line 740

#line 740
	assert(value != NULL);
#line 740

#line 740
	for(;;)
#line 740
	{
#line 740
		size_t extent = MIN(remaining, ncp->chunk);
#line 740
		size_t nput = ncx_howmany(varp->type, extent);
#line 740

#line 740
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 740
				 RGN_WRITE, &xp);
#line 740
		if(lstatus != NC_NOERR)
#line 740
			return lstatus;
#line 740

#line 740
		lstatus = ncx_putn_short_longlong(&xp, nput, value);
#line 740
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 740
		{
#line 740
			/* not fatal to the loop */
#line 740
			status = lstatus;
#line 740
		}
#line 740

#line 740
		(void) ncio_rel(ncp->nciop, offset,
#line 740
				 RGN_MODIFIED);
#line 740

#line 740
		remaining -= extent;
#line 740
		if(remaining == 0)
#line 740
			break; /* normal loop exit */
#line 740
		offset += extent;
#line 740
		value += nput;
#line 740

#line 740
	}
#line 740

#line 740
	return status;
#line 740
}
#line 740

static int
#line 741
putNCvx_short_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 741
		 const size_t *start, size_t nelems, const ushort *value)
#line 741
{
#line 741
	off_t offset = NC_varoffset(ncp, varp, start);
#line 741
	size_t remaining = varp->xsz * nelems;
#line 741
	int status = NC_NOERR;
#line 741
	void *xp;
#line 741

#line 741
	if(nelems == 0)
#line 741
		return NC_NOERR;
#line 741

#line 741
	assert(value != NULL);
#line 741

#line 741
	for(;;)
#line 741
	{
#line 741
		size_t extent = MIN(remaining, ncp->chunk);
#line 741
		size_t nput = ncx_howmany(varp->type, extent);
#line 741

#line 741
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 741
				 RGN_WRITE, &xp);
#line 741
		if(lstatus != NC_NOERR)
#line 741
			return lstatus;
#line 741

#line 741
		lstatus = ncx_putn_short_ushort(&xp, nput, value);
#line 741
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 741
		{
#line 741
			/* not fatal to the loop */
#line 741
			status = lstatus;
#line 741
		}
#line 741

#line 741
		(void) ncio_rel(ncp->nciop, offset,
#line 741
				 RGN_MODIFIED);
#line 741

#line 741
		remaining -= extent;
#line 741
		if(remaining == 0)
#line 741
			break; /* normal loop exit */
#line 741
		offset += extent;
#line 741
		value += nput;
#line 741

#line 741
	}
#line 741

#line 741
	return status;
#line 741
}
#line 741

static int
#line 742
putNCvx_short_uint(NC3_INFO* ncp, const NC_var *varp,
#line 742
		 const size_t *start, size_t nelems, const uint *value)
#line 742
{
#line 742
	off_t offset = NC_varoffset(ncp, varp, start);
#line 742
	size_t remaining = varp->xsz * nelems;
#line 742
	int status = NC_NOERR;
#line 742
	void *xp;
#line 742

#line 742
	if(nelems == 0)
#line 742
		return NC_NOERR;
#line 742

#line 742
	assert(value != NULL);
#line 742

#line 742
	for(;;)
#line 742
	{
#line 742
		size_t extent = MIN(remaining, ncp->chunk);
#line 742
		size_t nput = ncx_howmany(varp->type, extent);
#line 742

#line 742
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 742
				 RGN_WRITE, &xp);
#line 742
		if(lstatus != NC_NOERR)
#line 742
			return lstatus;
#line 742

#line 742
		lstatus = ncx_putn_short_uint(&xp, nput, value);
#line 742
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 742
		{
#line 742
			/* not fatal to the loop */
#line 742
			status = lstatus;
#line 742
		}
#line 742

#line 742
		(void) ncio_rel(ncp->nciop, offset,
#line 742
				 RGN_MODIFIED);
#line 742

#line 742
		remaining -= extent;
#line 742
		if(remaining == 0)
#line 742
			break; /* normal loop exit */
#line 742
		offset += extent;
#line 742
		value += nput;
#line 742

#line 742
	}
#line 742

#line 742
	return status;
#line 742
}
#line 742

static int
#line 743
putNCvx_short_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 743
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 743
{
#line 743
	off_t offset = NC_varoffset(ncp, varp, start);
#line 743
	size_t remaining = varp->xsz * nelems;
#line 743
	int status = NC_NOERR;
#line 743
	void *xp;
#line 743

#line 743
	if(nelems == 0)
#line 743
		return NC_NOERR;
#line 743

#line 743
	assert(value != NULL);
#line 743

#line 743
	for(;;)
#line 743
	{
#line 743
		size_t extent = MIN(remaining, ncp->chunk);
#line 743
		size_t nput = ncx_howmany(varp->type, extent);
#line 743

#line 743
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 743
				 RGN_WRITE, &xp);
#line 743
		if(lstatus != NC_NOERR)
#line 743
			return lstatus;
#line 743

#line 743
		lstatus = ncx_putn_short_ulonglong(&xp, nput, value);
#line 743
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 743
		{
#line 743
			/* not fatal to the loop */
#line 743
			status = lstatus;
#line 743
		}
#line 743

#line 743
		(void) ncio_rel(ncp->nciop, offset,
#line 743
				 RGN_MODIFIED);
#line 743

#line 743
		remaining -= extent;
#line 743
		if(remaining == 0)
#line 743
			break; /* normal loop exit */
#line 743
		offset += extent;
#line 743
		value += nput;
#line 743

#line 743
	}
#line 743

#line 743
	return status;
#line 743
}
#line 743


static int
#line 745
putNCvx_int_schar(NC3_INFO* ncp, const NC_var *varp,
#line 745
		 const size_t *start, size_t nelems, const schar *value)
#line 745
{
#line 745
	off_t offset = NC_varoffset(ncp, varp, start);
#line 745
	size_t remaining = varp->xsz * nelems;
#line 745
	int status = NC_NOERR;
#line 745
	void *xp;
#line 745

#line 745
	if(nelems == 0)
#line 745
		return NC_NOERR;
#line 745

#line 745
	assert(value != NULL);
#line 745

#line 745
	for(;;)
#line 745
	{
#line 745
		size_t extent = MIN(remaining, ncp->chunk);
#line 745
		size_t nput = ncx_howmany(varp->type, extent);
#line 745

#line 745
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 745
				 RGN_WRITE, &xp);
#line 745
		if(lstatus != NC_NOERR)
#line 745
			return lstatus;
#line 745

#line 745
		lstatus = ncx_putn_int_schar(&xp, nput, value);
#line 745
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 745
		{
#line 745
			/* not fatal to the loop */
#line 745
			status = lstatus;
#line 745
		}
#line 745

#line 745
		(void) ncio_rel(ncp->nciop, offset,
#line 745
				 RGN_MODIFIED);
#line 745

#line 745
		remaining -= extent;
#line 745
		if(remaining == 0)
#line 745
			break; /* normal loop exit */
#line 745
		offset += extent;
#line 745
		value += nput;
#line 745

#line 745
	}
#line 745

#line 745
	return status;
#line 745
}
#line 745

static int
#line 746
putNCvx_int_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 746
		 const size_t *start, size_t nelems, const uchar *value)
#line 746
{
#line 746
	off_t offset = NC_varoffset(ncp, varp, start);
#line 746
	size_t remaining = varp->xsz * nelems;
#line 746
	int status = NC_NOERR;
#line 746
	void *xp;
#line 746

#line 746
	if(nelems == 0)
#line 746
		return NC_NOERR;
#line 746

#line 746
	assert(value != NULL);
#line 746

#line 746
	for(;;)
#line 746
	{
#line 746
		size_t extent = MIN(remaining, ncp->chunk);
#line 746
		size_t nput = ncx_howmany(varp->type, extent);
#line 746

#line 746
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 746
				 RGN_WRITE, &xp);
#line 746
		if(lstatus != NC_NOERR)
#line 746
			return lstatus;
#line 746

#line 746
		lstatus = ncx_putn_int_uchar(&xp, nput, value);
#line 746
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 746
		{
#line 746
			/* not fatal to the loop */
#line 746
			status = lstatus;
#line 746
		}
#line 746

#line 746
		(void) ncio_rel(ncp->nciop, offset,
#line 746
				 RGN_MODIFIED);
#line 746

#line 746
		remaining -= extent;
#line 746
		if(remaining == 0)
#line 746
			break; /* normal loop exit */
#line 746
		offset += extent;
#line 746
		value += nput;
#line 746

#line 746
	}
#line 746

#line 746
	return status;
#line 746
}
#line 746

static int
#line 747
putNCvx_int_short(NC3_INFO* ncp, const NC_var *varp,
#line 747
		 const size_t *start, size_t nelems, const short *value)
#line 747
{
#line 747
	off_t offset = NC_varoffset(ncp, varp, start);
#line 747
	size_t remaining = varp->xsz * nelems;
#line 747
	int status = NC_NOERR;
#line 747
	void *xp;
#line 747

#line 747
	if(nelems == 0)
#line 747
		return NC_NOERR;
#line 747

#line 747
	assert(value != NULL);
#line 747

#line 747
	for(;;)
#line 747
	{
#line 747
		size_t extent = MIN(remaining, ncp->chunk);
#line 747
		size_t nput = ncx_howmany(varp->type, extent);
#line 747

#line 747
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 747
				 RGN_WRITE, &xp);
#line 747
		if(lstatus != NC_NOERR)
#line 747
			return lstatus;
#line 747

#line 747
		lstatus = ncx_putn_int_short(&xp, nput, value);
#line 747
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 747
		{
#line 747
			/* not fatal to the loop */
#line 747
			status = lstatus;
#line 747
		}
#line 747

#line 747
		(void) ncio_rel(ncp->nciop, offset,
#line 747
				 RGN_MODIFIED);
#line 747

#line 747
		remaining -= extent;
#line 747
		if(remaining == 0)
#line 747
			break; /* normal loop exit */
#line 747
		offset += extent;
#line 747
		value += nput;
#line 747

#line 747
	}
#line 747

#line 747
	return status;
#line 747
}
#line 747

static int
#line 748
putNCvx_int_int(NC3_INFO* ncp, const NC_var *varp,
#line 748
		 const size_t *start, size_t nelems, const int *value)
#line 748
{
#line 748
	off_t offset = NC_varoffset(ncp, varp, start);
#line 748
	size_t remaining = varp->xsz * nelems;
#line 748
	int status = NC_NOERR;
#line 748
	void *xp;
#line 748

#line 748
	if(nelems == 0)
#line 748
		return NC_NOERR;
#line 748

#line 748
	assert(value != NULL);
#line 748

#line 748
	for(;;)
#line 748
	{
#line 748
		size_t extent = MIN(remaining, ncp->chunk);
#line 748
		size_t nput = ncx_howmany(varp->type, extent);
#line 748

#line 748
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 748
				 RGN_WRITE, &xp);
#line 748
		if(lstatus != NC_NOERR)
#line 748
			return lstatus;
#line 748

#line 748
		lstatus = ncx_putn_int_int(&xp, nput, value);
#line 748
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 748
		{
#line 748
			/* not fatal to the loop */
#line 748
			status = lstatus;
#line 748
		}
#line 748

#line 748
		(void) ncio_rel(ncp->nciop, offset,
#line 748
				 RGN_MODIFIED);
#line 748

#line 748
		remaining -= extent;
#line 748
		if(remaining == 0)
#line 748
			break; /* normal loop exit */
#line 748
		offset += extent;
#line 748
		value += nput;
#line 748

#line 748
	}
#line 748

#line 748
	return status;
#line 748
}
#line 748

static int
#line 749
putNCvx_int_float(NC3_INFO* ncp, const NC_var *varp,
#line 749
		 const size_t *start, size_t nelems, const float *value)
#line 749
{
#line 749
	off_t offset = NC_varoffset(ncp, varp, start);
#line 749
	size_t remaining = varp->xsz * nelems;
#line 749
	int status = NC_NOERR;
#line 749
	void *xp;
#line 749

#line 749
	if(nelems == 0)
#line 749
		return NC_NOERR;
#line 749

#line 749
	assert(value != NULL);
#line 749

#line 749
	for(;;)
#line 749
	{
#line 749
		size_t extent = MIN(remaining, ncp->chunk);
#line 749
		size_t nput = ncx_howmany(varp->type, extent);
#line 749

#line 749
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 749
				 RGN_WRITE, &xp);
#line 749
		if(lstatus != NC_NOERR)
#line 749
			return lstatus;
#line 749

#line 749
		lstatus = ncx_putn_int_float(&xp, nput, value);
#line 749
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 749
		{
#line 749
			/* not fatal to the loop */
#line 749
			status = lstatus;
#line 749
		}
#line 749

#line 749
		(void) ncio_rel(ncp->nciop, offset,
#line 749
				 RGN_MODIFIED);
#line 749

#line 749
		remaining -= extent;
#line 749
		if(remaining == 0)
#line 749
			break; /* normal loop exit */
#line 749
		offset += extent;
#line 749
		value += nput;
#line 749

#line 749
	}
#line 749

#line 749
	return status;
#line 749
}
#line 749

static int
#line 750
putNCvx_int_double(NC3_INFO* ncp, const NC_var *varp,
#line 750
		 const size_t *start, size_t nelems, const double *value)
#line 750
{
#line 750
	off_t offset = NC_varoffset(ncp, varp, start);
#line 750
	size_t remaining = varp->xsz * nelems;
#line 750
	int status = NC_NOERR;
#line 750
	void *xp;
#line 750

#line 750
	if(nelems == 0)
#line 750
		return NC_NOERR;
#line 750

#line 750
	assert(value != NULL);
#line 750

#line 750
	for(;;)
#line 750
	{
#line 750
		size_t extent = MIN(remaining, ncp->chunk);
#line 750
		size_t nput = ncx_howmany(varp->type, extent);
#line 750

#line 750
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 750
				 RGN_WRITE, &xp);
#line 750
		if(lstatus != NC_NOERR)
#line 750
			return lstatus;
#line 750

#line 750
		lstatus = ncx_putn_int_double(&xp, nput, value);
#line 750
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 750
		{
#line 750
			/* not fatal to the loop */
#line 750
			status = lstatus;
#line 750
		}
#line 750

#line 750
		(void) ncio_rel(ncp->nciop, offset,
#line 750
				 RGN_MODIFIED);
#line 750

#line 750
		remaining -= extent;
#line 750
		if(remaining == 0)
#line 750
			break; /* normal loop exit */
#line 750
		offset += extent;
#line 750
		value += nput;
#line 750

#line 750
	}
#line 750

#line 750
	return status;
#line 750
}
#line 750

static int
#line 751
putNCvx_int_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 751
		 const size_t *start, size_t nelems, const longlong *value)
#line 751
{
#line 751
	off_t offset = NC_varoffset(ncp, varp, start);
#line 751
	size_t remaining = varp->xsz * nelems;
#line 751
	int status = NC_NOERR;
#line 751
	void *xp;
#line 751

#line 751
	if(nelems == 0)
#line 751
		return NC_NOERR;
#line 751

#line 751
	assert(value != NULL);
#line 751

#line 751
	for(;;)
#line 751
	{
#line 751
		size_t extent = MIN(remaining, ncp->chunk);
#line 751
		size_t nput = ncx_howmany(varp->type, extent);
#line 751

#line 751
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 751
				 RGN_WRITE, &xp);
#line 751
		if(lstatus != NC_NOERR)
#line 751
			return lstatus;
#line 751

#line 751
		lstatus = ncx_putn_int_longlong(&xp, nput, value);
#line 751
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 751
		{
#line 751
			/* not fatal to the loop */
#line 751
			status = lstatus;
#line 751
		}
#line 751

#line 751
		(void) ncio_rel(ncp->nciop, offset,
#line 751
				 RGN_MODIFIED);
#line 751

#line 751
		remaining -= extent;
#line 751
		if(remaining == 0)
#line 751
			break; /* normal loop exit */
#line 751
		offset += extent;
#line 751
		value += nput;
#line 751

#line 751
	}
#line 751

#line 751
	return status;
#line 751
}
#line 751

static int
#line 752
putNCvx_int_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 752
		 const size_t *start, size_t nelems, const ushort *value)
#line 752
{
#line 752
	off_t offset = NC_varoffset(ncp, varp, start);
#line 752
	size_t remaining = varp->xsz * nelems;
#line 752
	int status = NC_NOERR;
#line 752
	void *xp;
#line 752

#line 752
	if(nelems == 0)
#line 752
		return NC_NOERR;
#line 752

#line 752
	assert(value != NULL);
#line 752

#line 752
	for(;;)
#line 752
	{
#line 752
		size_t extent = MIN(remaining, ncp->chunk);
#line 752
		size_t nput = ncx_howmany(varp->type, extent);
#line 752

#line 752
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 752
				 RGN_WRITE, &xp);
#line 752
		if(lstatus != NC_NOERR)
#line 752
			return lstatus;
#line 752

#line 752
		lstatus = ncx_putn_int_ushort(&xp, nput, value);
#line 752
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 752
		{
#line 752
			/* not fatal to the loop */
#line 752
			status = lstatus;
#line 752
		}
#line 752

#line 752
		(void) ncio_rel(ncp->nciop, offset,
#line 752
				 RGN_MODIFIED);
#line 752

#line 752
		remaining -= extent;
#line 752
		if(remaining == 0)
#line 752
			break; /* normal loop exit */
#line 752
		offset += extent;
#line 752
		value += nput;
#line 752

#line 752
	}
#line 752

#line 752
	return status;
#line 752
}
#line 752

static int
#line 753
putNCvx_int_uint(NC3_INFO* ncp, const NC_var *varp,
#line 753
		 const size_t *start, size_t nelems, const uint *value)
#line 753
{
#line 753
	off_t offset = NC_varoffset(ncp, varp, start);
#line 753
	size_t remaining = varp->xsz * nelems;
#line 753
	int status = NC_NOERR;
#line 753
	void *xp;
#line 753

#line 753
	if(nelems == 0)
#line 753
		return NC_NOERR;
#line 753

#line 753
	assert(value != NULL);
#line 753

#line 753
	for(;;)
#line 753
	{
#line 753
		size_t extent = MIN(remaining, ncp->chunk);
#line 753
		size_t nput = ncx_howmany(varp->type, extent);
#line 753

#line 753
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 753
				 RGN_WRITE, &xp);
#line 753
		if(lstatus != NC_NOERR)
#line 753
			return lstatus;
#line 753

#line 753
		lstatus = ncx_putn_int_uint(&xp, nput, value);
#line 753
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 753
		{
#line 753
			/* not fatal to the loop */
#line 753
			status = lstatus;
#line 753
		}
#line 753

#line 753
		(void) ncio_rel(ncp->nciop, offset,
#line 753
				 RGN_MODIFIED);
#line 753

#line 753
		remaining -= extent;
#line 753
		if(remaining == 0)
#line 753
			break; /* normal loop exit */
#line 753
		offset += extent;
#line 753
		value += nput;
#line 753

#line 753
	}
#line 753

#line 753
	return status;
#line 753
}
#line 753

static int
#line 754
putNCvx_int_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 754
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 754
{
#line 754
	off_t offset = NC_varoffset(ncp, varp, start);
#line 754
	size_t remaining = varp->xsz * nelems;
#line 754
	int status = NC_NOERR;
#line 754
	void *xp;
#line 754

#line 754
	if(nelems == 0)
#line 754
		return NC_NOERR;
#line 754

#line 754
	assert(value != NULL);
#line 754

#line 754
	for(;;)
#line 754
	{
#line 754
		size_t extent = MIN(remaining, ncp->chunk);
#line 754
		size_t nput = ncx_howmany(varp->type, extent);
#line 754

#line 754
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 754
				 RGN_WRITE, &xp);
#line 754
		if(lstatus != NC_NOERR)
#line 754
			return lstatus;
#line 754

#line 754
		lstatus = ncx_putn_int_ulonglong(&xp, nput, value);
#line 754
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 754
		{
#line 754
			/* not fatal to the loop */
#line 754
			status = lstatus;
#line 754
		}
#line 754

#line 754
		(void) ncio_rel(ncp->nciop, offset,
#line 754
				 RGN_MODIFIED);
#line 754

#line 754
		remaining -= extent;
#line 754
		if(remaining == 0)
#line 754
			break; /* normal loop exit */
#line 754
		offset += extent;
#line 754
		value += nput;
#line 754

#line 754
	}
#line 754

#line 754
	return status;
#line 754
}
#line 754


static int
#line 756
putNCvx_float_schar(NC3_INFO* ncp, const NC_var *varp,
#line 756
		 const size_t *start, size_t nelems, const schar *value)
#line 756
{
#line 756
	off_t offset = NC_varoffset(ncp, varp, start);
#line 756
	size_t remaining = varp->xsz * nelems;
#line 756
	int status = NC_NOERR;
#line 756
	void *xp;
#line 756

#line 756
	if(nelems == 0)
#line 756
		return NC_NOERR;
#line 756

#line 756
	assert(value != NULL);
#line 756

#line 756
	for(;;)
#line 756
	{
#line 756
		size_t extent = MIN(remaining, ncp->chunk);
#line 756
		size_t nput = ncx_howmany(varp->type, extent);
#line 756

#line 756
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 756
				 RGN_WRITE, &xp);
#line 756
		if(lstatus != NC_NOERR)
#line 756
			return lstatus;
#line 756

#line 756
		lstatus = ncx_putn_float_schar(&xp, nput, value);
#line 756
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 756
		{
#line 756
			/* not fatal to the loop */
#line 756
			status = lstatus;
#line 756
		}
#line 756

#line 756
		(void) ncio_rel(ncp->nciop, offset,
#line 756
				 RGN_MODIFIED);
#line 756

#line 756
		remaining -= extent;
#line 756
		if(remaining == 0)
#line 756
			break; /* normal loop exit */
#line 756
		offset += extent;
#line 756
		value += nput;
#line 756

#line 756
	}
#line 756

#line 756
	return status;
#line 756
}
#line 756

static int
#line 757
putNCvx_float_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 757
		 const size_t *start, size_t nelems, const uchar *value)
#line 757
{
#line 757
	off_t offset = NC_varoffset(ncp, varp, start);
#line 757
	size_t remaining = varp->xsz * nelems;
#line 757
	int status = NC_NOERR;
#line 757
	void *xp;
#line 757

#line 757
	if(nelems == 0)
#line 757
		return NC_NOERR;
#line 757

#line 757
	assert(value != NULL);
#line 757

#line 757
	for(;;)
#line 757
	{
#line 757
		size_t extent = MIN(remaining, ncp->chunk);
#line 757
		size_t nput = ncx_howmany(varp->type, extent);
#line 757

#line 757
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 757
				 RGN_WRITE, &xp);
#line 757
		if(lstatus != NC_NOERR)
#line 757
			return lstatus;
#line 757

#line 757
		lstatus = ncx_putn_float_uchar(&xp, nput, value);
#line 757
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 757
		{
#line 757
			/* not fatal to the loop */
#line 757
			status = lstatus;
#line 757
		}
#line 757

#line 757
		(void) ncio_rel(ncp->nciop, offset,
#line 757
				 RGN_MODIFIED);
#line 757

#line 757
		remaining -= extent;
#line 757
		if(remaining == 0)
#line 757
			break; /* normal loop exit */
#line 757
		offset += extent;
#line 757
		value += nput;
#line 757

#line 757
	}
#line 757

#line 757
	return status;
#line 757
}
#line 757

static int
#line 758
putNCvx_float_short(NC3_INFO* ncp, const NC_var *varp,
#line 758
		 const size_t *start, size_t nelems, const short *value)
#line 758
{
#line 758
	off_t offset = NC_varoffset(ncp, varp, start);
#line 758
	size_t remaining = varp->xsz * nelems;
#line 758
	int status = NC_NOERR;
#line 758
	void *xp;
#line 758

#line 758
	if(nelems == 0)
#line 758
		return NC_NOERR;
#line 758

#line 758
	assert(value != NULL);
#line 758

#line 758
	for(;;)
#line 758
	{
#line 758
		size_t extent = MIN(remaining, ncp->chunk);
#line 758
		size_t nput = ncx_howmany(varp->type, extent);
#line 758

#line 758
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 758
				 RGN_WRITE, &xp);
#line 758
		if(lstatus != NC_NOERR)
#line 758
			return lstatus;
#line 758

#line 758
		lstatus = ncx_putn_float_short(&xp, nput, value);
#line 758
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 758
		{
#line 758
			/* not fatal to the loop */
#line 758
			status = lstatus;
#line 758
		}
#line 758

#line 758
		(void) ncio_rel(ncp->nciop, offset,
#line 758
				 RGN_MODIFIED);
#line 758

#line 758
		remaining -= extent;
#line 758
		if(remaining == 0)
#line 758
			break; /* normal loop exit */
#line 758
		offset += extent;
#line 758
		value += nput;
#line 758

#line 758
	}
#line 758

#line 758
	return status;
#line 758
}
#line 758

static int
#line 759
putNCvx_float_int(NC3_INFO* ncp, const NC_var *varp,
#line 759
		 const size_t *start, size_t nelems, const int *value)
#line 759
{
#line 759
	off_t offset = NC_varoffset(ncp, varp, start);
#line 759
	size_t remaining = varp->xsz * nelems;
#line 759
	int status = NC_NOERR;
#line 759
	void *xp;
#line 759

#line 759
	if(nelems == 0)
#line 759
		return NC_NOERR;
#line 759

#line 759
	assert(value != NULL);
#line 759

#line 759
	for(;;)
#line 759
	{
#line 759
		size_t extent = MIN(remaining, ncp->chunk);
#line 759
		size_t nput = ncx_howmany(varp->type, extent);
#line 759

#line 759
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 759
				 RGN_WRITE, &xp);
#line 759
		if(lstatus != NC_NOERR)
#line 759
			return lstatus;
#line 759

#line 759
		lstatus = ncx_putn_float_int(&xp, nput, value);
#line 759
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 759
		{
#line 759
			/* not fatal to the loop */
#line 759
			status = lstatus;
#line 759
		}
#line 759

#line 759
		(void) ncio_rel(ncp->nciop, offset,
#line 759
				 RGN_MODIFIED);
#line 759

#line 759
		remaining -= extent;
#line 759
		if(remaining == 0)
#line 759
			break; /* normal loop exit */
#line 759
		offset += extent;
#line 759
		value += nput;
#line 759

#line 759
	}
#line 759

#line 759
	return status;
#line 759
}
#line 759

static int
#line 760
putNCvx_float_float(NC3_INFO* ncp, const NC_var *varp,
#line 760
		 const size_t *start, size_t nelems, const float *value)
#line 760
{
#line 760
	off_t offset = NC_varoffset(ncp, varp, start);
#line 760
	size_t remaining = varp->xsz * nelems;
#line 760
	int status = NC_NOERR;
#line 760
	void *xp;
#line 760

#line 760
	if(nelems == 0)
#line 760
		return NC_NOERR;
#line 760

#line 760
	assert(value != NULL);
#line 760

#line 760
	for(;;)
#line 760
	{
#line 760
		size_t extent = MIN(remaining, ncp->chunk);
#line 760
		size_t nput = ncx_howmany(varp->type, extent);
#line 760

#line 760
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 760
				 RGN_WRITE, &xp);
#line 760
		if(lstatus != NC_NOERR)
#line 760
			return lstatus;
#line 760

#line 760
		lstatus = ncx_putn_float_float(&xp, nput, value);
#line 760
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 760
		{
#line 760
			/* not fatal to the loop */
#line 760
			status = lstatus;
#line 760
		}
#line 760

#line 760
		(void) ncio_rel(ncp->nciop, offset,
#line 760
				 RGN_MODIFIED);
#line 760

#line 760
		remaining -= extent;
#line 760
		if(remaining == 0)
#line 760
			break; /* normal loop exit */
#line 760
		offset += extent;
#line 760
		value += nput;
#line 760

#line 760
	}
#line 760

#line 760
	return status;
#line 760
}
#line 760

static int
#line 761
putNCvx_float_double(NC3_INFO* ncp, const NC_var *varp,
#line 761
		 const size_t *start, size_t nelems, const double *value)
#line 761
{
#line 761
	off_t offset = NC_varoffset(ncp, varp, start);
#line 761
	size_t remaining = varp->xsz * nelems;
#line 761
	int status = NC_NOERR;
#line 761
	void *xp;
#line 761

#line 761
	if(nelems == 0)
#line 761
		return NC_NOERR;
#line 761

#line 761
	assert(value != NULL);
#line 761

#line 761
	for(;;)
#line 761
	{
#line 761
		size_t extent = MIN(remaining, ncp->chunk);
#line 761
		size_t nput = ncx_howmany(varp->type, extent);
#line 761

#line 761
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 761
				 RGN_WRITE, &xp);
#line 761
		if(lstatus != NC_NOERR)
#line 761
			return lstatus;
#line 761

#line 761
		lstatus = ncx_putn_float_double(&xp, nput, value);
#line 761
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 761
		{
#line 761
			/* not fatal to the loop */
#line 761
			status = lstatus;
#line 761
		}
#line 761

#line 761
		(void) ncio_rel(ncp->nciop, offset,
#line 761
				 RGN_MODIFIED);
#line 761

#line 761
		remaining -= extent;
#line 761
		if(remaining == 0)
#line 761
			break; /* normal loop exit */
#line 761
		offset += extent;
#line 761
		value += nput;
#line 761

#line 761
	}
#line 761

#line 761
	return status;
#line 761
}
#line 761

static int
#line 762
putNCvx_float_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 762
		 const size_t *start, size_t nelems, const longlong *value)
#line 762
{
#line 762
	off_t offset = NC_varoffset(ncp, varp, start);
#line 762
	size_t remaining = varp->xsz * nelems;
#line 762
	int status = NC_NOERR;
#line 762
	void *xp;
#line 762

#line 762
	if(nelems == 0)
#line 762
		return NC_NOERR;
#line 762

#line 762
	assert(value != NULL);
#line 762

#line 762
	for(;;)
#line 762
	{
#line 762
		size_t extent = MIN(remaining, ncp->chunk);
#line 762
		size_t nput = ncx_howmany(varp->type, extent);
#line 762

#line 762
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 762
				 RGN_WRITE, &xp);
#line 762
		if(lstatus != NC_NOERR)
#line 762
			return lstatus;
#line 762

#line 762
		lstatus = ncx_putn_float_longlong(&xp, nput, value);
#line 762
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 762
		{
#line 762
			/* not fatal to the loop */
#line 762
			status = lstatus;
#line 762
		}
#line 762

#line 762
		(void) ncio_rel(ncp->nciop, offset,
#line 762
				 RGN_MODIFIED);
#line 762

#line 762
		remaining -= extent;
#line 762
		if(remaining == 0)
#line 762
			break; /* normal loop exit */
#line 762
		offset += extent;
#line 762
		value += nput;
#line 762

#line 762
	}
#line 762

#line 762
	return status;
#line 762
}
#line 762

static int
#line 763
putNCvx_float_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 763
		 const size_t *start, size_t nelems, const ushort *value)
#line 763
{
#line 763
	off_t offset = NC_varoffset(ncp, varp, start);
#line 763
	size_t remaining = varp->xsz * nelems;
#line 763
	int status = NC_NOERR;
#line 763
	void *xp;
#line 763

#line 763
	if(nelems == 0)
#line 763
		return NC_NOERR;
#line 763

#line 763
	assert(value != NULL);
#line 763

#line 763
	for(;;)
#line 763
	{
#line 763
		size_t extent = MIN(remaining, ncp->chunk);
#line 763
		size_t nput = ncx_howmany(varp->type, extent);
#line 763

#line 763
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 763
				 RGN_WRITE, &xp);
#line 763
		if(lstatus != NC_NOERR)
#line 763
			return lstatus;
#line 763

#line 763
		lstatus = ncx_putn_float_ushort(&xp, nput, value);
#line 763
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 763
		{
#line 763
			/* not fatal to the loop */
#line 763
			status = lstatus;
#line 763
		}
#line 763

#line 763
		(void) ncio_rel(ncp->nciop, offset,
#line 763
				 RGN_MODIFIED);
#line 763

#line 763
		remaining -= extent;
#line 763
		if(remaining == 0)
#line 763
			break; /* normal loop exit */
#line 763
		offset += extent;
#line 763
		value += nput;
#line 763

#line 763
	}
#line 763

#line 763
	return status;
#line 763
}
#line 763

static int
#line 764
putNCvx_float_uint(NC3_INFO* ncp, const NC_var *varp,
#line 764
		 const size_t *start, size_t nelems, const uint *value)
#line 764
{
#line 764
	off_t offset = NC_varoffset(ncp, varp, start);
#line 764
	size_t remaining = varp->xsz * nelems;
#line 764
	int status = NC_NOERR;
#line 764
	void *xp;
#line 764

#line 764
	if(nelems == 0)
#line 764
		return NC_NOERR;
#line 764

#line 764
	assert(value != NULL);
#line 764

#line 764
	for(;;)
#line 764
	{
#line 764
		size_t extent = MIN(remaining, ncp->chunk);
#line 764
		size_t nput = ncx_howmany(varp->type, extent);
#line 764

#line 764
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 764
				 RGN_WRITE, &xp);
#line 764
		if(lstatus != NC_NOERR)
#line 764
			return lstatus;
#line 764

#line 764
		lstatus = ncx_putn_float_uint(&xp, nput, value);
#line 764
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 764
		{
#line 764
			/* not fatal to the loop */
#line 764
			status = lstatus;
#line 764
		}
#line 764

#line 764
		(void) ncio_rel(ncp->nciop, offset,
#line 764
				 RGN_MODIFIED);
#line 764

#line 764
		remaining -= extent;
#line 764
		if(remaining == 0)
#line 764
			break; /* normal loop exit */
#line 764
		offset += extent;
#line 764
		value += nput;
#line 764

#line 764
	}
#line 764

#line 764
	return status;
#line 764
}
#line 764

static int
#line 765
putNCvx_float_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 765
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 765
{
#line 765
	off_t offset = NC_varoffset(ncp, varp, start);
#line 765
	size_t remaining = varp->xsz * nelems;
#line 765
	int status = NC_NOERR;
#line 765
	void *xp;
#line 765

#line 765
	if(nelems == 0)
#line 765
		return NC_NOERR;
#line 765

#line 765
	assert(value != NULL);
#line 765

#line 765
	for(;;)
#line 765
	{
#line 765
		size_t extent = MIN(remaining, ncp->chunk);
#line 765
		size_t nput = ncx_howmany(varp->type, extent);
#line 765

#line 765
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 765
				 RGN_WRITE, &xp);
#line 765
		if(lstatus != NC_NOERR)
#line 765
			return lstatus;
#line 765

#line 765
		lstatus = ncx_putn_float_ulonglong(&xp, nput, value);
#line 765
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 765
		{
#line 765
			/* not fatal to the loop */
#line 765
			status = lstatus;
#line 765
		}
#line 765

#line 765
		(void) ncio_rel(ncp->nciop, offset,
#line 765
				 RGN_MODIFIED);
#line 765

#line 765
		remaining -= extent;
#line 765
		if(remaining == 0)
#line 765
			break; /* normal loop exit */
#line 765
		offset += extent;
#line 765
		value += nput;
#line 765

#line 765
	}
#line 765

#line 765
	return status;
#line 765
}
#line 765


static int
#line 767
putNCvx_double_schar(NC3_INFO* ncp, const NC_var *varp,
#line 767
		 const size_t *start, size_t nelems, const schar *value)
#line 767
{
#line 767
	off_t offset = NC_varoffset(ncp, varp, start);
#line 767
	size_t remaining = varp->xsz * nelems;
#line 767
	int status = NC_NOERR;
#line 767
	void *xp;
#line 767

#line 767
	if(nelems == 0)
#line 767
		return NC_NOERR;
#line 767

#line 767
	assert(value != NULL);
#line 767

#line 767
	for(;;)
#line 767
	{
#line 767
		size_t extent = MIN(remaining, ncp->chunk);
#line 767
		size_t nput = ncx_howmany(varp->type, extent);
#line 767

#line 767
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 767
				 RGN_WRITE, &xp);
#line 767
		if(lstatus != NC_NOERR)
#line 767
			return lstatus;
#line 767

#line 767
		lstatus = ncx_putn_double_schar(&xp, nput, value);
#line 767
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 767
		{
#line 767
			/* not fatal to the loop */
#line 767
			status = lstatus;
#line 767
		}
#line 767

#line 767
		(void) ncio_rel(ncp->nciop, offset,
#line 767
				 RGN_MODIFIED);
#line 767

#line 767
		remaining -= extent;
#line 767
		if(remaining == 0)
#line 767
			break; /* normal loop exit */
#line 767
		offset += extent;
#line 767
		value += nput;
#line 767

#line 767
	}
#line 767

#line 767
	return status;
#line 767
}
#line 767

static int
#line 768
putNCvx_double_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 768
		 const size_t *start, size_t nelems, const uchar *value)
#line 768
{
#line 768
	off_t offset = NC_varoffset(ncp, varp, start);
#line 768
	size_t remaining = varp->xsz * nelems;
#line 768
	int status = NC_NOERR;
#line 768
	void *xp;
#line 768

#line 768
	if(nelems == 0)
#line 768
		return NC_NOERR;
#line 768

#line 768
	assert(value != NULL);
#line 768

#line 768
	for(;;)
#line 768
	{
#line 768
		size_t extent = MIN(remaining, ncp->chunk);
#line 768
		size_t nput = ncx_howmany(varp->type, extent);
#line 768

#line 768
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 768
				 RGN_WRITE, &xp);
#line 768
		if(lstatus != NC_NOERR)
#line 768
			return lstatus;
#line 768

#line 768
		lstatus = ncx_putn_double_uchar(&xp, nput, value);
#line 768
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 768
		{
#line 768
			/* not fatal to the loop */
#line 768
			status = lstatus;
#line 768
		}
#line 768

#line 768
		(void) ncio_rel(ncp->nciop, offset,
#line 768
				 RGN_MODIFIED);
#line 768

#line 768
		remaining -= extent;
#line 768
		if(remaining == 0)
#line 768
			break; /* normal loop exit */
#line 768
		offset += extent;
#line 768
		value += nput;
#line 768

#line 768
	}
#line 768

#line 768
	return status;
#line 768
}
#line 768

static int
#line 769
putNCvx_double_short(NC3_INFO* ncp, const NC_var *varp,
#line 769
		 const size_t *start, size_t nelems, const short *value)
#line 769
{
#line 769
	off_t offset = NC_varoffset(ncp, varp, start);
#line 769
	size_t remaining = varp->xsz * nelems;
#line 769
	int status = NC_NOERR;
#line 769
	void *xp;
#line 769

#line 769
	if(nelems == 0)
#line 769
		return NC_NOERR;
#line 769

#line 769
	assert(value != NULL);
#line 769

#line 769
	for(;;)
#line 769
	{
#line 769
		size_t extent = MIN(remaining, ncp->chunk);
#line 769
		size_t nput = ncx_howmany(varp->type, extent);
#line 769

#line 769
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 769
				 RGN_WRITE, &xp);
#line 769
		if(lstatus != NC_NOERR)
#line 769
			return lstatus;
#line 769

#line 769
		lstatus = ncx_putn_double_short(&xp, nput, value);
#line 769
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 769
		{
#line 769
			/* not fatal to the loop */
#line 769
			status = lstatus;
#line 769
		}
#line 769

#line 769
		(void) ncio_rel(ncp->nciop, offset,
#line 769
				 RGN_MODIFIED);
#line 769

#line 769
		remaining -= extent;
#line 769
		if(remaining == 0)
#line 769
			break; /* normal loop exit */
#line 769
		offset += extent;
#line 769
		value += nput;
#line 769

#line 769
	}
#line 769

#line 769
	return status;
#line 769
}
#line 769

static int
#line 770
putNCvx_double_int(NC3_INFO* ncp, const NC_var *varp,
#line 770
		 const size_t *start, size_t nelems, const int *value)
#line 770
{
#line 770
	off_t offset = NC_varoffset(ncp, varp, start);
#line 770
	size_t remaining = varp->xsz * nelems;
#line 770
	int status = NC_NOERR;
#line 770
	void *xp;
#line 770

#line 770
	if(nelems == 0)
#line 770
		return NC_NOERR;
#line 770

#line 770
	assert(value != NULL);
#line 770

#line 770
	for(;;)
#line 770
	{
#line 770
		size_t extent = MIN(remaining, ncp->chunk);
#line 770
		size_t nput = ncx_howmany(varp->type, extent);
#line 770

#line 770
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 770
				 RGN_WRITE, &xp);
#line 770
		if(lstatus != NC_NOERR)
#line 770
			return lstatus;
#line 770

#line 770
		lstatus = ncx_putn_double_int(&xp, nput, value);
#line 770
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 770
		{
#line 770
			/* not fatal to the loop */
#line 770
			status = lstatus;
#line 770
		}
#line 770

#line 770
		(void) ncio_rel(ncp->nciop, offset,
#line 770
				 RGN_MODIFIED);
#line 770

#line 770
		remaining -= extent;
#line 770
		if(remaining == 0)
#line 770
			break; /* normal loop exit */
#line 770
		offset += extent;
#line 770
		value += nput;
#line 770

#line 770
	}
#line 770

#line 770
	return status;
#line 770
}
#line 770

static int
#line 771
putNCvx_double_float(NC3_INFO* ncp, const NC_var *varp,
#line 771
		 const size_t *start, size_t nelems, const float *value)
#line 771
{
#line 771
	off_t offset = NC_varoffset(ncp, varp, start);
#line 771
	size_t remaining = varp->xsz * nelems;
#line 771
	int status = NC_NOERR;
#line 771
	void *xp;
#line 771

#line 771
	if(nelems == 0)
#line 771
		return NC_NOERR;
#line 771

#line 771
	assert(value != NULL);
#line 771

#line 771
	for(;;)
#line 771
	{
#line 771
		size_t extent = MIN(remaining, ncp->chunk);
#line 771
		size_t nput = ncx_howmany(varp->type, extent);
#line 771

#line 771
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 771
				 RGN_WRITE, &xp);
#line 771
		if(lstatus != NC_NOERR)
#line 771
			return lstatus;
#line 771

#line 771
		lstatus = ncx_putn_double_float(&xp, nput, value);
#line 771
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 771
		{
#line 771
			/* not fatal to the loop */
#line 771
			status = lstatus;
#line 771
		}
#line 771

#line 771
		(void) ncio_rel(ncp->nciop, offset,
#line 771
				 RGN_MODIFIED);
#line 771

#line 771
		remaining -= extent;
#line 771
		if(remaining == 0)
#line 771
			break; /* normal loop exit */
#line 771
		offset += extent;
#line 771
		value += nput;
#line 771

#line 771
	}
#line 771

#line 771
	return status;
#line 771
}
#line 771

static int
#line 772
putNCvx_double_double(NC3_INFO* ncp, const NC_var *varp,
#line 772
		 const size_t *start, size_t nelems, const double *value)
#line 772
{
#line 772
	off_t offset = NC_varoffset(ncp, varp, start);
#line 772
	size_t remaining = varp->xsz * nelems;
#line 772
	int status = NC_NOERR;
#line 772
	void *xp;
#line 772

#line 772
	if(nelems == 0)
#line 772
		return NC_NOERR;
#line 772

#line 772
	assert(value != NULL);
#line 772

#line 772
	for(;;)
#line 772
	{
#line 772
		size_t extent = MIN(remaining, ncp->chunk);
#line 772
		size_t nput = ncx_howmany(varp->type, extent);
#line 772

#line 772
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 772
				 RGN_WRITE, &xp);
#line 772
		if(lstatus != NC_NOERR)
#line 772
			return lstatus;
#line 772

#line 772
		lstatus = ncx_putn_double_double(&xp, nput, value);
#line 772
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 772
		{
#line 772
			/* not fatal to the loop */
#line 772
			status = lstatus;
#line 772
		}
#line 772

#line 772
		(void) ncio_rel(ncp->nciop, offset,
#line 772
				 RGN_MODIFIED);
#line 772

#line 772
		remaining -= extent;
#line 772
		if(remaining == 0)
#line 772
			break; /* normal loop exit */
#line 772
		offset += extent;
#line 772
		value += nput;
#line 772

#line 772
	}
#line 772

#line 772
	return status;
#line 772
}
#line 772

static int
#line 773
putNCvx_double_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 773
		 const size_t *start, size_t nelems, const longlong *value)
#line 773
{
#line 773
	off_t offset = NC_varoffset(ncp, varp, start);
#line 773
	size_t remaining = varp->xsz * nelems;
#line 773
	int status = NC_NOERR;
#line 773
	void *xp;
#line 773

#line 773
	if(nelems == 0)
#line 773
		return NC_NOERR;
#line 773

#line 773
	assert(value != NULL);
#line 773

#line 773
	for(;;)
#line 773
	{
#line 773
		size_t extent = MIN(remaining, ncp->chunk);
#line 773
		size_t nput = ncx_howmany(varp->type, extent);
#line 773

#line 773
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 773
				 RGN_WRITE, &xp);
#line 773
		if(lstatus != NC_NOERR)
#line 773
			return lstatus;
#line 773

#line 773
		lstatus = ncx_putn_double_longlong(&xp, nput, value);
#line 773
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 773
		{
#line 773
			/* not fatal to the loop */
#line 773
			status = lstatus;
#line 773
		}
#line 773

#line 773
		(void) ncio_rel(ncp->nciop, offset,
#line 773
				 RGN_MODIFIED);
#line 773

#line 773
		remaining -= extent;
#line 773
		if(remaining == 0)
#line 773
			break; /* normal loop exit */
#line 773
		offset += extent;
#line 773
		value += nput;
#line 773

#line 773
	}
#line 773

#line 773
	return status;
#line 773
}
#line 773

static int
#line 774
putNCvx_double_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 774
		 const size_t *start, size_t nelems, const ushort *value)
#line 774
{
#line 774
	off_t offset = NC_varoffset(ncp, varp, start);
#line 774
	size_t remaining = varp->xsz * nelems;
#line 774
	int status = NC_NOERR;
#line 774
	void *xp;
#line 774

#line 774
	if(nelems == 0)
#line 774
		return NC_NOERR;
#line 774

#line 774
	assert(value != NULL);
#line 774

#line 774
	for(;;)
#line 774
	{
#line 774
		size_t extent = MIN(remaining, ncp->chunk);
#line 774
		size_t nput = ncx_howmany(varp->type, extent);
#line 774

#line 774
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 774
				 RGN_WRITE, &xp);
#line 774
		if(lstatus != NC_NOERR)
#line 774
			return lstatus;
#line 774

#line 774
		lstatus = ncx_putn_double_ushort(&xp, nput, value);
#line 774
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 774
		{
#line 774
			/* not fatal to the loop */
#line 774
			status = lstatus;
#line 774
		}
#line 774

#line 774
		(void) ncio_rel(ncp->nciop, offset,
#line 774
				 RGN_MODIFIED);
#line 774

#line 774
		remaining -= extent;
#line 774
		if(remaining == 0)
#line 774
			break; /* normal loop exit */
#line 774
		offset += extent;
#line 774
		value += nput;
#line 774

#line 774
	}
#line 774

#line 774
	return status;
#line 774
}
#line 774

static int
#line 775
putNCvx_double_uint(NC3_INFO* ncp, const NC_var *varp,
#line 775
		 const size_t *start, size_t nelems, const uint *value)
#line 775
{
#line 775
	off_t offset = NC_varoffset(ncp, varp, start);
#line 775
	size_t remaining = varp->xsz * nelems;
#line 775
	int status = NC_NOERR;
#line 775
	void *xp;
#line 775

#line 775
	if(nelems == 0)
#line 775
		return NC_NOERR;
#line 775

#line 775
	assert(value != NULL);
#line 775

#line 775
	for(;;)
#line 775
	{
#line 775
		size_t extent = MIN(remaining, ncp->chunk);
#line 775
		size_t nput = ncx_howmany(varp->type, extent);
#line 775

#line 775
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 775
				 RGN_WRITE, &xp);
#line 775
		if(lstatus != NC_NOERR)
#line 775
			return lstatus;
#line 775

#line 775
		lstatus = ncx_putn_double_uint(&xp, nput, value);
#line 775
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 775
		{
#line 775
			/* not fatal to the loop */
#line 775
			status = lstatus;
#line 775
		}
#line 775

#line 775
		(void) ncio_rel(ncp->nciop, offset,
#line 775
				 RGN_MODIFIED);
#line 775

#line 775
		remaining -= extent;
#line 775
		if(remaining == 0)
#line 775
			break; /* normal loop exit */
#line 775
		offset += extent;
#line 775
		value += nput;
#line 775

#line 775
	}
#line 775

#line 775
	return status;
#line 775
}
#line 775

static int
#line 776
putNCvx_double_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 776
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 776
{
#line 776
	off_t offset = NC_varoffset(ncp, varp, start);
#line 776
	size_t remaining = varp->xsz * nelems;
#line 776
	int status = NC_NOERR;
#line 776
	void *xp;
#line 776

#line 776
	if(nelems == 0)
#line 776
		return NC_NOERR;
#line 776

#line 776
	assert(value != NULL);
#line 776

#line 776
	for(;;)
#line 776
	{
#line 776
		size_t extent = MIN(remaining, ncp->chunk);
#line 776
		size_t nput = ncx_howmany(varp->type, extent);
#line 776

#line 776
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 776
				 RGN_WRITE, &xp);
#line 776
		if(lstatus != NC_NOERR)
#line 776
			return lstatus;
#line 776

#line 776
		lstatus = ncx_putn_double_ulonglong(&xp, nput, value);
#line 776
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 776
		{
#line 776
			/* not fatal to the loop */
#line 776
			status = lstatus;
#line 776
		}
#line 776

#line 776
		(void) ncio_rel(ncp->nciop, offset,
#line 776
				 RGN_MODIFIED);
#line 776

#line 776
		remaining -= extent;
#line 776
		if(remaining == 0)
#line 776
			break; /* normal loop exit */
#line 776
		offset += extent;
#line 776
		value += nput;
#line 776

#line 776
	}
#line 776

#line 776
	return status;
#line 776
}
#line 776


static int
#line 778
putNCvx_uchar_schar(NC3_INFO* ncp, const NC_var *varp,
#line 778
		 const size_t *start, size_t nelems, const schar *value)
#line 778
{
#line 778
	off_t offset = NC_varoffset(ncp, varp, start);
#line 778
	size_t remaining = varp->xsz * nelems;
#line 778
	int status = NC_NOERR;
#line 778
	void *xp;
#line 778

#line 778
	if(nelems == 0)
#line 778
		return NC_NOERR;
#line 778

#line 778
	assert(value != NULL);
#line 778

#line 778
	for(;;)
#line 778
	{
#line 778
		size_t extent = MIN(remaining, ncp->chunk);
#line 778
		size_t nput = ncx_howmany(varp->type, extent);
#line 778

#line 778
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 778
				 RGN_WRITE, &xp);
#line 778
		if(lstatus != NC_NOERR)
#line 778
			return lstatus;
#line 778

#line 778
		lstatus = ncx_putn_uchar_schar(&xp, nput, value);
#line 778
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 778
		{
#line 778
			/* not fatal to the loop */
#line 778
			status = lstatus;
#line 778
		}
#line 778

#line 778
		(void) ncio_rel(ncp->nciop, offset,
#line 778
				 RGN_MODIFIED);
#line 778

#line 778
		remaining -= extent;
#line 778
		if(remaining == 0)
#line 778
			break; /* normal loop exit */
#line 778
		offset += extent;
#line 778
		value += nput;
#line 778

#line 778
	}
#line 778

#line 778
	return status;
#line 778
}
#line 778

static int
#line 779
putNCvx_uchar_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 779
		 const size_t *start, size_t nelems, const uchar *value)
#line 779
{
#line 779
	off_t offset = NC_varoffset(ncp, varp, start);
#line 779
	size_t remaining = varp->xsz * nelems;
#line 779
	int status = NC_NOERR;
#line 779
	void *xp;
#line 779

#line 779
	if(nelems == 0)
#line 779
		return NC_NOERR;
#line 779

#line 779
	assert(value != NULL);
#line 779

#line 779
	for(;;)
#line 779
	{
#line 779
		size_t extent = MIN(remaining, ncp->chunk);
#line 779
		size_t nput = ncx_howmany(varp->type, extent);
#line 779

#line 779
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 779
				 RGN_WRITE, &xp);
#line 779
		if(lstatus != NC_NOERR)
#line 779
			return lstatus;
#line 779

#line 779
		lstatus = ncx_putn_uchar_uchar(&xp, nput, value);
#line 779
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 779
		{
#line 779
			/* not fatal to the loop */
#line 779
			status = lstatus;
#line 779
		}
#line 779

#line 779
		(void) ncio_rel(ncp->nciop, offset,
#line 779
				 RGN_MODIFIED);
#line 779

#line 779
		remaining -= extent;
#line 779
		if(remaining == 0)
#line 779
			break; /* normal loop exit */
#line 779
		offset += extent;
#line 779
		value += nput;
#line 779

#line 779
	}
#line 779

#line 779
	return status;
#line 779
}
#line 779

static int
#line 780
putNCvx_uchar_short(NC3_INFO* ncp, const NC_var *varp,
#line 780
		 const size_t *start, size_t nelems, const short *value)
#line 780
{
#line 780
	off_t offset = NC_varoffset(ncp, varp, start);
#line 780
	size_t remaining = varp->xsz * nelems;
#line 780
	int status = NC_NOERR;
#line 780
	void *xp;
#line 780

#line 780
	if(nelems == 0)
#line 780
		return NC_NOERR;
#line 780

#line 780
	assert(value != NULL);
#line 780

#line 780
	for(;;)
#line 780
	{
#line 780
		size_t extent = MIN(remaining, ncp->chunk);
#line 780
		size_t nput = ncx_howmany(varp->type, extent);
#line 780

#line 780
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 780
				 RGN_WRITE, &xp);
#line 780
		if(lstatus != NC_NOERR)
#line 780
			return lstatus;
#line 780

#line 780
		lstatus = ncx_putn_uchar_short(&xp, nput, value);
#line 780
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 780
		{
#line 780
			/* not fatal to the loop */
#line 780
			status = lstatus;
#line 780
		}
#line 780

#line 780
		(void) ncio_rel(ncp->nciop, offset,
#line 780
				 RGN_MODIFIED);
#line 780

#line 780
		remaining -= extent;
#line 780
		if(remaining == 0)
#line 780
			break; /* normal loop exit */
#line 780
		offset += extent;
#line 780
		value += nput;
#line 780

#line 780
	}
#line 780

#line 780
	return status;
#line 780
}
#line 780

static int
#line 781
putNCvx_uchar_int(NC3_INFO* ncp, const NC_var *varp,
#line 781
		 const size_t *start, size_t nelems, const int *value)
#line 781
{
#line 781
	off_t offset = NC_varoffset(ncp, varp, start);
#line 781
	size_t remaining = varp->xsz * nelems;
#line 781
	int status = NC_NOERR;
#line 781
	void *xp;
#line 781

#line 781
	if(nelems == 0)
#line 781
		return NC_NOERR;
#line 781

#line 781
	assert(value != NULL);
#line 781

#line 781
	for(;;)
#line 781
	{
#line 781
		size_t extent = MIN(remaining, ncp->chunk);
#line 781
		size_t nput = ncx_howmany(varp->type, extent);
#line 781

#line 781
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 781
				 RGN_WRITE, &xp);
#line 781
		if(lstatus != NC_NOERR)
#line 781
			return lstatus;
#line 781

#line 781
		lstatus = ncx_putn_uchar_int(&xp, nput, value);
#line 781
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 781
		{
#line 781
			/* not fatal to the loop */
#line 781
			status = lstatus;
#line 781
		}
#line 781

#line 781
		(void) ncio_rel(ncp->nciop, offset,
#line 781
				 RGN_MODIFIED);
#line 781

#line 781
		remaining -= extent;
#line 781
		if(remaining == 0)
#line 781
			break; /* normal loop exit */
#line 781
		offset += extent;
#line 781
		value += nput;
#line 781

#line 781
	}
#line 781

#line 781
	return status;
#line 781
}
#line 781

static int
#line 782
putNCvx_uchar_float(NC3_INFO* ncp, const NC_var *varp,
#line 782
		 const size_t *start, size_t nelems, const float *value)
#line 782
{
#line 782
	off_t offset = NC_varoffset(ncp, varp, start);
#line 782
	size_t remaining = varp->xsz * nelems;
#line 782
	int status = NC_NOERR;
#line 782
	void *xp;
#line 782

#line 782
	if(nelems == 0)
#line 782
		return NC_NOERR;
#line 782

#line 782
	assert(value != NULL);
#line 782

#line 782
	for(;;)
#line 782
	{
#line 782
		size_t extent = MIN(remaining, ncp->chunk);
#line 782
		size_t nput = ncx_howmany(varp->type, extent);
#line 782

#line 782
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 782
				 RGN_WRITE, &xp);
#line 782
		if(lstatus != NC_NOERR)
#line 782
			return lstatus;
#line 782

#line 782
		lstatus = ncx_putn_uchar_float(&xp, nput, value);
#line 782
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 782
		{
#line 782
			/* not fatal to the loop */
#line 782
			status = lstatus;
#line 782
		}
#line 782

#line 782
		(void) ncio_rel(ncp->nciop, offset,
#line 782
				 RGN_MODIFIED);
#line 782

#line 782
		remaining -= extent;
#line 782
		if(remaining == 0)
#line 782
			break; /* normal loop exit */
#line 782
		offset += extent;
#line 782
		value += nput;
#line 782

#line 782
	}
#line 782

#line 782
	return status;
#line 782
}
#line 782

static int
#line 783
putNCvx_uchar_double(NC3_INFO* ncp, const NC_var *varp,
#line 783
		 const size_t *start, size_t nelems, const double *value)
#line 783
{
#line 783
	off_t offset = NC_varoffset(ncp, varp, start);
#line 783
	size_t remaining = varp->xsz * nelems;
#line 783
	int status = NC_NOERR;
#line 783
	void *xp;
#line 783

#line 783
	if(nelems == 0)
#line 783
		return NC_NOERR;
#line 783

#line 783
	assert(value != NULL);
#line 783

#line 783
	for(;;)
#line 783
	{
#line 783
		size_t extent = MIN(remaining, ncp->chunk);
#line 783
		size_t nput = ncx_howmany(varp->type, extent);
#line 783

#line 783
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 783
				 RGN_WRITE, &xp);
#line 783
		if(lstatus != NC_NOERR)
#line 783
			return lstatus;
#line 783

#line 783
		lstatus = ncx_putn_uchar_double(&xp, nput, value);
#line 783
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 783
		{
#line 783
			/* not fatal to the loop */
#line 783
			status = lstatus;
#line 783
		}
#line 783

#line 783
		(void) ncio_rel(ncp->nciop, offset,
#line 783
				 RGN_MODIFIED);
#line 783

#line 783
		remaining -= extent;
#line 783
		if(remaining == 0)
#line 783
			break; /* normal loop exit */
#line 783
		offset += extent;
#line 783
		value += nput;
#line 783

#line 783
	}
#line 783

#line 783
	return status;
#line 783
}
#line 783

static int
#line 784
putNCvx_uchar_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 784
		 const size_t *start, size_t nelems, const longlong *value)
#line 784
{
#line 784
	off_t offset = NC_varoffset(ncp, varp, start);
#line 784
	size_t remaining = varp->xsz * nelems;
#line 784
	int status = NC_NOERR;
#line 784
	void *xp;
#line 784

#line 784
	if(nelems == 0)
#line 784
		return NC_NOERR;
#line 784

#line 784
	assert(value != NULL);
#line 784

#line 784
	for(;;)
#line 784
	{
#line 784
		size_t extent = MIN(remaining, ncp->chunk);
#line 784
		size_t nput = ncx_howmany(varp->type, extent);
#line 784

#line 784
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 784
				 RGN_WRITE, &xp);
#line 784
		if(lstatus != NC_NOERR)
#line 784
			return lstatus;
#line 784

#line 784
		lstatus = ncx_putn_uchar_longlong(&xp, nput, value);
#line 784
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 784
		{
#line 784
			/* not fatal to the loop */
#line 784
			status = lstatus;
#line 784
		}
#line 784

#line 784
		(void) ncio_rel(ncp->nciop, offset,
#line 784
				 RGN_MODIFIED);
#line 784

#line 784
		remaining -= extent;
#line 784
		if(remaining == 0)
#line 784
			break; /* normal loop exit */
#line 784
		offset += extent;
#line 784
		value += nput;
#line 784

#line 784
	}
#line 784

#line 784
	return status;
#line 784
}
#line 784

static int
#line 785
putNCvx_uchar_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 785
		 const size_t *start, size_t nelems, const ushort *value)
#line 785
{
#line 785
	off_t offset = NC_varoffset(ncp, varp, start);
#line 785
	size_t remaining = varp->xsz * nelems;
#line 785
	int status = NC_NOERR;
#line 785
	void *xp;
#line 785

#line 785
	if(nelems == 0)
#line 785
		return NC_NOERR;
#line 785

#line 785
	assert(value != NULL);
#line 785

#line 785
	for(;;)
#line 785
	{
#line 785
		size_t extent = MIN(remaining, ncp->chunk);
#line 785
		size_t nput = ncx_howmany(varp->type, extent);
#line 785

#line 785
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 785
				 RGN_WRITE, &xp);
#line 785
		if(lstatus != NC_NOERR)
#line 785
			return lstatus;
#line 785

#line 785
		lstatus = ncx_putn_uchar_ushort(&xp, nput, value);
#line 785
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 785
		{
#line 785
			/* not fatal to the loop */
#line 785
			status = lstatus;
#line 785
		}
#line 785

#line 785
		(void) ncio_rel(ncp->nciop, offset,
#line 785
				 RGN_MODIFIED);
#line 785

#line 785
		remaining -= extent;
#line 785
		if(remaining == 0)
#line 785
			break; /* normal loop exit */
#line 785
		offset += extent;
#line 785
		value += nput;
#line 785

#line 785
	}
#line 785

#line 785
	return status;
#line 785
}
#line 785

static int
#line 786
putNCvx_uchar_uint(NC3_INFO* ncp, const NC_var *varp,
#line 786
		 const size_t *start, size_t nelems, const uint *value)
#line 786
{
#line 786
	off_t offset = NC_varoffset(ncp, varp, start);
#line 786
	size_t remaining = varp->xsz * nelems;
#line 786
	int status = NC_NOERR;
#line 786
	void *xp;
#line 786

#line 786
	if(nelems == 0)
#line 786
		return NC_NOERR;
#line 786

#line 786
	assert(value != NULL);
#line 786

#line 786
	for(;;)
#line 786
	{
#line 786
		size_t extent = MIN(remaining, ncp->chunk);
#line 786
		size_t nput = ncx_howmany(varp->type, extent);
#line 786

#line 786
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 786
				 RGN_WRITE, &xp);
#line 786
		if(lstatus != NC_NOERR)
#line 786
			return lstatus;
#line 786

#line 786
		lstatus = ncx_putn_uchar_uint(&xp, nput, value);
#line 786
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 786
		{
#line 786
			/* not fatal to the loop */
#line 786
			status = lstatus;
#line 786
		}
#line 786

#line 786
		(void) ncio_rel(ncp->nciop, offset,
#line 786
				 RGN_MODIFIED);
#line 786

#line 786
		remaining -= extent;
#line 786
		if(remaining == 0)
#line 786
			break; /* normal loop exit */
#line 786
		offset += extent;
#line 786
		value += nput;
#line 786

#line 786
	}
#line 786

#line 786
	return status;
#line 786
}
#line 786

static int
#line 787
putNCvx_uchar_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 787
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 787
{
#line 787
	off_t offset = NC_varoffset(ncp, varp, start);
#line 787
	size_t remaining = varp->xsz * nelems;
#line 787
	int status = NC_NOERR;
#line 787
	void *xp;
#line 787

#line 787
	if(nelems == 0)
#line 787
		return NC_NOERR;
#line 787

#line 787
	assert(value != NULL);
#line 787

#line 787
	for(;;)
#line 787
	{
#line 787
		size_t extent = MIN(remaining, ncp->chunk);
#line 787
		size_t nput = ncx_howmany(varp->type, extent);
#line 787

#line 787
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 787
				 RGN_WRITE, &xp);
#line 787
		if(lstatus != NC_NOERR)
#line 787
			return lstatus;
#line 787

#line 787
		lstatus = ncx_putn_uchar_ulonglong(&xp, nput, value);
#line 787
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 787
		{
#line 787
			/* not fatal to the loop */
#line 787
			status = lstatus;
#line 787
		}
#line 787

#line 787
		(void) ncio_rel(ncp->nciop, offset,
#line 787
				 RGN_MODIFIED);
#line 787

#line 787
		remaining -= extent;
#line 787
		if(remaining == 0)
#line 787
			break; /* normal loop exit */
#line 787
		offset += extent;
#line 787
		value += nput;
#line 787

#line 787
	}
#line 787

#line 787
	return status;
#line 787
}
#line 787


static int
#line 789
putNCvx_ushort_schar(NC3_INFO* ncp, const NC_var *varp,
#line 789
		 const size_t *start, size_t nelems, const schar *value)
#line 789
{
#line 789
	off_t offset = NC_varoffset(ncp, varp, start);
#line 789
	size_t remaining = varp->xsz * nelems;
#line 789
	int status = NC_NOERR;
#line 789
	void *xp;
#line 789

#line 789
	if(nelems == 0)
#line 789
		return NC_NOERR;
#line 789

#line 789
	assert(value != NULL);
#line 789

#line 789
	for(;;)
#line 789
	{
#line 789
		size_t extent = MIN(remaining, ncp->chunk);
#line 789
		size_t nput = ncx_howmany(varp->type, extent);
#line 789

#line 789
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 789
				 RGN_WRITE, &xp);
#line 789
		if(lstatus != NC_NOERR)
#line 789
			return lstatus;
#line 789

#line 789
		lstatus = ncx_putn_ushort_schar(&xp, nput, value);
#line 789
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 789
		{
#line 789
			/* not fatal to the loop */
#line 789
			status = lstatus;
#line 789
		}
#line 789

#line 789
		(void) ncio_rel(ncp->nciop, offset,
#line 789
				 RGN_MODIFIED);
#line 789

#line 789
		remaining -= extent;
#line 789
		if(remaining == 0)
#line 789
			break; /* normal loop exit */
#line 789
		offset += extent;
#line 789
		value += nput;
#line 789

#line 789
	}
#line 789

#line 789
	return status;
#line 789
}
#line 789

static int
#line 790
putNCvx_ushort_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 790
		 const size_t *start, size_t nelems, const uchar *value)
#line 790
{
#line 790
	off_t offset = NC_varoffset(ncp, varp, start);
#line 790
	size_t remaining = varp->xsz * nelems;
#line 790
	int status = NC_NOERR;
#line 790
	void *xp;
#line 790

#line 790
	if(nelems == 0)
#line 790
		return NC_NOERR;
#line 790

#line 790
	assert(value != NULL);
#line 790

#line 790
	for(;;)
#line 790
	{
#line 790
		size_t extent = MIN(remaining, ncp->chunk);
#line 790
		size_t nput = ncx_howmany(varp->type, extent);
#line 790

#line 790
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 790
				 RGN_WRITE, &xp);
#line 790
		if(lstatus != NC_NOERR)
#line 790
			return lstatus;
#line 790

#line 790
		lstatus = ncx_putn_ushort_uchar(&xp, nput, value);
#line 790
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 790
		{
#line 790
			/* not fatal to the loop */
#line 790
			status = lstatus;
#line 790
		}
#line 790

#line 790
		(void) ncio_rel(ncp->nciop, offset,
#line 790
				 RGN_MODIFIED);
#line 790

#line 790
		remaining -= extent;
#line 790
		if(remaining == 0)
#line 790
			break; /* normal loop exit */
#line 790
		offset += extent;
#line 790
		value += nput;
#line 790

#line 790
	}
#line 790

#line 790
	return status;
#line 790
}
#line 790

static int
#line 791
putNCvx_ushort_short(NC3_INFO* ncp, const NC_var *varp,
#line 791
		 const size_t *start, size_t nelems, const short *value)
#line 791
{
#line 791
	off_t offset = NC_varoffset(ncp, varp, start);
#line 791
	size_t remaining = varp->xsz * nelems;
#line 791
	int status = NC_NOERR;
#line 791
	void *xp;
#line 791

#line 791
	if(nelems == 0)
#line 791
		return NC_NOERR;
#line 791

#line 791
	assert(value != NULL);
#line 791

#line 791
	for(;;)
#line 791
	{
#line 791
		size_t extent = MIN(remaining, ncp->chunk);
#line 791
		size_t nput = ncx_howmany(varp->type, extent);
#line 791

#line 791
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 791
				 RGN_WRITE, &xp);
#line 791
		if(lstatus != NC_NOERR)
#line 791
			return lstatus;
#line 791

#line 791
		lstatus = ncx_putn_ushort_short(&xp, nput, value);
#line 791
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 791
		{
#line 791
			/* not fatal to the loop */
#line 791
			status = lstatus;
#line 791
		}
#line 791

#line 791
		(void) ncio_rel(ncp->nciop, offset,
#line 791
				 RGN_MODIFIED);
#line 791

#line 791
		remaining -= extent;
#line 791
		if(remaining == 0)
#line 791
			break; /* normal loop exit */
#line 791
		offset += extent;
#line 791
		value += nput;
#line 791

#line 791
	}
#line 791

#line 791
	return status;
#line 791
}
#line 791

static int
#line 792
putNCvx_ushort_int(NC3_INFO* ncp, const NC_var *varp,
#line 792
		 const size_t *start, size_t nelems, const int *value)
#line 792
{
#line 792
	off_t offset = NC_varoffset(ncp, varp, start);
#line 792
	size_t remaining = varp->xsz * nelems;
#line 792
	int status = NC_NOERR;
#line 792
	void *xp;
#line 792

#line 792
	if(nelems == 0)
#line 792
		return NC_NOERR;
#line 792

#line 792
	assert(value != NULL);
#line 792

#line 792
	for(;;)
#line 792
	{
#line 792
		size_t extent = MIN(remaining, ncp->chunk);
#line 792
		size_t nput = ncx_howmany(varp->type, extent);
#line 792

#line 792
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 792
				 RGN_WRITE, &xp);
#line 792
		if(lstatus != NC_NOERR)
#line 792
			return lstatus;
#line 792

#line 792
		lstatus = ncx_putn_ushort_int(&xp, nput, value);
#line 792
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 792
		{
#line 792
			/* not fatal to the loop */
#line 792
			status = lstatus;
#line 792
		}
#line 792

#line 792
		(void) ncio_rel(ncp->nciop, offset,
#line 792
				 RGN_MODIFIED);
#line 792

#line 792
		remaining -= extent;
#line 792
		if(remaining == 0)
#line 792
			break; /* normal loop exit */
#line 792
		offset += extent;
#line 792
		value += nput;
#line 792

#line 792
	}
#line 792

#line 792
	return status;
#line 792
}
#line 792

static int
#line 793
putNCvx_ushort_float(NC3_INFO* ncp, const NC_var *varp,
#line 793
		 const size_t *start, size_t nelems, const float *value)
#line 793
{
#line 793
	off_t offset = NC_varoffset(ncp, varp, start);
#line 793
	size_t remaining = varp->xsz * nelems;
#line 793
	int status = NC_NOERR;
#line 793
	void *xp;
#line 793

#line 793
	if(nelems == 0)
#line 793
		return NC_NOERR;
#line 793

#line 793
	assert(value != NULL);
#line 793

#line 793
	for(;;)
#line 793
	{
#line 793
		size_t extent = MIN(remaining, ncp->chunk);
#line 793
		size_t nput = ncx_howmany(varp->type, extent);
#line 793

#line 793
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 793
				 RGN_WRITE, &xp);
#line 793
		if(lstatus != NC_NOERR)
#line 793
			return lstatus;
#line 793

#line 793
		lstatus = ncx_putn_ushort_float(&xp, nput, value);
#line 793
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 793
		{
#line 793
			/* not fatal to the loop */
#line 793
			status = lstatus;
#line 793
		}
#line 793

#line 793
		(void) ncio_rel(ncp->nciop, offset,
#line 793
				 RGN_MODIFIED);
#line 793

#line 793
		remaining -= extent;
#line 793
		if(remaining == 0)
#line 793
			break; /* normal loop exit */
#line 793
		offset += extent;
#line 793
		value += nput;
#line 793

#line 793
	}
#line 793

#line 793
	return status;
#line 793
}
#line 793

static int
#line 794
putNCvx_ushort_double(NC3_INFO* ncp, const NC_var *varp,
#line 794
		 const size_t *start, size_t nelems, const double *value)
#line 794
{
#line 794
	off_t offset = NC_varoffset(ncp, varp, start);
#line 794
	size_t remaining = varp->xsz * nelems;
#line 794
	int status = NC_NOERR;
#line 794
	void *xp;
#line 794

#line 794
	if(nelems == 0)
#line 794
		return NC_NOERR;
#line 794

#line 794
	assert(value != NULL);
#line 794

#line 794
	for(;;)
#line 794
	{
#line 794
		size_t extent = MIN(remaining, ncp->chunk);
#line 794
		size_t nput = ncx_howmany(varp->type, extent);
#line 794

#line 794
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 794
				 RGN_WRITE, &xp);
#line 794
		if(lstatus != NC_NOERR)
#line 794
			return lstatus;
#line 794

#line 794
		lstatus = ncx_putn_ushort_double(&xp, nput, value);
#line 794
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 794
		{
#line 794
			/* not fatal to the loop */
#line 794
			status = lstatus;
#line 794
		}
#line 794

#line 794
		(void) ncio_rel(ncp->nciop, offset,
#line 794
				 RGN_MODIFIED);
#line 794

#line 794
		remaining -= extent;
#line 794
		if(remaining == 0)
#line 794
			break; /* normal loop exit */
#line 794
		offset += extent;
#line 794
		value += nput;
#line 794

#line 794
	}
#line 794

#line 794
	return status;
#line 794
}
#line 794

static int
#line 795
putNCvx_ushort_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 795
		 const size_t *start, size_t nelems, const longlong *value)
#line 795
{
#line 795
	off_t offset = NC_varoffset(ncp, varp, start);
#line 795
	size_t remaining = varp->xsz * nelems;
#line 795
	int status = NC_NOERR;
#line 795
	void *xp;
#line 795

#line 795
	if(nelems == 0)
#line 795
		return NC_NOERR;
#line 795

#line 795
	assert(value != NULL);
#line 795

#line 795
	for(;;)
#line 795
	{
#line 795
		size_t extent = MIN(remaining, ncp->chunk);
#line 795
		size_t nput = ncx_howmany(varp->type, extent);
#line 795

#line 795
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 795
				 RGN_WRITE, &xp);
#line 795
		if(lstatus != NC_NOERR)
#line 795
			return lstatus;
#line 795

#line 795
		lstatus = ncx_putn_ushort_longlong(&xp, nput, value);
#line 795
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 795
		{
#line 795
			/* not fatal to the loop */
#line 795
			status = lstatus;
#line 795
		}
#line 795

#line 795
		(void) ncio_rel(ncp->nciop, offset,
#line 795
				 RGN_MODIFIED);
#line 795

#line 795
		remaining -= extent;
#line 795
		if(remaining == 0)
#line 795
			break; /* normal loop exit */
#line 795
		offset += extent;
#line 795
		value += nput;
#line 795

#line 795
	}
#line 795

#line 795
	return status;
#line 795
}
#line 795

static int
#line 796
putNCvx_ushort_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 796
		 const size_t *start, size_t nelems, const ushort *value)
#line 796
{
#line 796
	off_t offset = NC_varoffset(ncp, varp, start);
#line 796
	size_t remaining = varp->xsz * nelems;
#line 796
	int status = NC_NOERR;
#line 796
	void *xp;
#line 796

#line 796
	if(nelems == 0)
#line 796
		return NC_NOERR;
#line 796

#line 796
	assert(value != NULL);
#line 796

#line 796
	for(;;)
#line 796
	{
#line 796
		size_t extent = MIN(remaining, ncp->chunk);
#line 796
		size_t nput = ncx_howmany(varp->type, extent);
#line 796

#line 796
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 796
				 RGN_WRITE, &xp);
#line 796
		if(lstatus != NC_NOERR)
#line 796
			return lstatus;
#line 796

#line 796
		lstatus = ncx_putn_ushort_ushort(&xp, nput, value);
#line 796
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 796
		{
#line 796
			/* not fatal to the loop */
#line 796
			status = lstatus;
#line 796
		}
#line 796

#line 796
		(void) ncio_rel(ncp->nciop, offset,
#line 796
				 RGN_MODIFIED);
#line 796

#line 796
		remaining -= extent;
#line 796
		if(remaining == 0)
#line 796
			break; /* normal loop exit */
#line 796
		offset += extent;
#line 796
		value += nput;
#line 796

#line 796
	}
#line 796

#line 796
	return status;
#line 796
}
#line 796

static int
#line 797
putNCvx_ushort_uint(NC3_INFO* ncp, const NC_var *varp,
#line 797
		 const size_t *start, size_t nelems, const uint *value)
#line 797
{
#line 797
	off_t offset = NC_varoffset(ncp, varp, start);
#line 797
	size_t remaining = varp->xsz * nelems;
#line 797
	int status = NC_NOERR;
#line 797
	void *xp;
#line 797

#line 797
	if(nelems == 0)
#line 797
		return NC_NOERR;
#line 797

#line 797
	assert(value != NULL);
#line 797

#line 797
	for(;;)
#line 797
	{
#line 797
		size_t extent = MIN(remaining, ncp->chunk);
#line 797
		size_t nput = ncx_howmany(varp->type, extent);
#line 797

#line 797
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 797
				 RGN_WRITE, &xp);
#line 797
		if(lstatus != NC_NOERR)
#line 797
			return lstatus;
#line 797

#line 797
		lstatus = ncx_putn_ushort_uint(&xp, nput, value);
#line 797
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 797
		{
#line 797
			/* not fatal to the loop */
#line 797
			status = lstatus;
#line 797
		}
#line 797

#line 797
		(void) ncio_rel(ncp->nciop, offset,
#line 797
				 RGN_MODIFIED);
#line 797

#line 797
		remaining -= extent;
#line 797
		if(remaining == 0)
#line 797
			break; /* normal loop exit */
#line 797
		offset += extent;
#line 797
		value += nput;
#line 797

#line 797
	}
#line 797

#line 797
	return status;
#line 797
}
#line 797

static int
#line 798
putNCvx_ushort_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 798
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 798
{
#line 798
	off_t offset = NC_varoffset(ncp, varp, start);
#line 798
	size_t remaining = varp->xsz * nelems;
#line 798
	int status = NC_NOERR;
#line 798
	void *xp;
#line 798

#line 798
	if(nelems == 0)
#line 798
		return NC_NOERR;
#line 798

#line 798
	assert(value != NULL);
#line 798

#line 798
	for(;;)
#line 798
	{
#line 798
		size_t extent = MIN(remaining, ncp->chunk);
#line 798
		size_t nput = ncx_howmany(varp->type, extent);
#line 798

#line 798
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 798
				 RGN_WRITE, &xp);
#line 798
		if(lstatus != NC_NOERR)
#line 798
			return lstatus;
#line 798

#line 798
		lstatus = ncx_putn_ushort_ulonglong(&xp, nput, value);
#line 798
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 798
		{
#line 798
			/* not fatal to the loop */
#line 798
			status = lstatus;
#line 798
		}
#line 798

#line 798
		(void) ncio_rel(ncp->nciop, offset,
#line 798
				 RGN_MODIFIED);
#line 798

#line 798
		remaining -= extent;
#line 798
		if(remaining == 0)
#line 798
			break; /* normal loop exit */
#line 798
		offset += extent;
#line 798
		value += nput;
#line 798

#line 798
	}
#line 798

#line 798
	return status;
#line 798
}
#line 798


static int
#line 800
putNCvx_uint_schar(NC3_INFO* ncp, const NC_var *varp,
#line 800
		 const size_t *start, size_t nelems, const schar *value)
#line 800
{
#line 800
	off_t offset = NC_varoffset(ncp, varp, start);
#line 800
	size_t remaining = varp->xsz * nelems;
#line 800
	int status = NC_NOERR;
#line 800
	void *xp;
#line 800

#line 800
	if(nelems == 0)
#line 800
		return NC_NOERR;
#line 800

#line 800
	assert(value != NULL);
#line 800

#line 800
	for(;;)
#line 800
	{
#line 800
		size_t extent = MIN(remaining, ncp->chunk);
#line 800
		size_t nput = ncx_howmany(varp->type, extent);
#line 800

#line 800
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 800
				 RGN_WRITE, &xp);
#line 800
		if(lstatus != NC_NOERR)
#line 800
			return lstatus;
#line 800

#line 800
		lstatus = ncx_putn_uint_schar(&xp, nput, value);
#line 800
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 800
		{
#line 800
			/* not fatal to the loop */
#line 800
			status = lstatus;
#line 800
		}
#line 800

#line 800
		(void) ncio_rel(ncp->nciop, offset,
#line 800
				 RGN_MODIFIED);
#line 800

#line 800
		remaining -= extent;
#line 800
		if(remaining == 0)
#line 800
			break; /* normal loop exit */
#line 800
		offset += extent;
#line 800
		value += nput;
#line 800

#line 800
	}
#line 800

#line 800
	return status;
#line 800
}
#line 800

static int
#line 801
putNCvx_uint_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 801
		 const size_t *start, size_t nelems, const uchar *value)
#line 801
{
#line 801
	off_t offset = NC_varoffset(ncp, varp, start);
#line 801
	size_t remaining = varp->xsz * nelems;
#line 801
	int status = NC_NOERR;
#line 801
	void *xp;
#line 801

#line 801
	if(nelems == 0)
#line 801
		return NC_NOERR;
#line 801

#line 801
	assert(value != NULL);
#line 801

#line 801
	for(;;)
#line 801
	{
#line 801
		size_t extent = MIN(remaining, ncp->chunk);
#line 801
		size_t nput = ncx_howmany(varp->type, extent);
#line 801

#line 801
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 801
				 RGN_WRITE, &xp);
#line 801
		if(lstatus != NC_NOERR)
#line 801
			return lstatus;
#line 801

#line 801
		lstatus = ncx_putn_uint_uchar(&xp, nput, value);
#line 801
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 801
		{
#line 801
			/* not fatal to the loop */
#line 801
			status = lstatus;
#line 801
		}
#line 801

#line 801
		(void) ncio_rel(ncp->nciop, offset,
#line 801
				 RGN_MODIFIED);
#line 801

#line 801
		remaining -= extent;
#line 801
		if(remaining == 0)
#line 801
			break; /* normal loop exit */
#line 801
		offset += extent;
#line 801
		value += nput;
#line 801

#line 801
	}
#line 801

#line 801
	return status;
#line 801
}
#line 801

static int
#line 802
putNCvx_uint_short(NC3_INFO* ncp, const NC_var *varp,
#line 802
		 const size_t *start, size_t nelems, const short *value)
#line 802
{
#line 802
	off_t offset = NC_varoffset(ncp, varp, start);
#line 802
	size_t remaining = varp->xsz * nelems;
#line 802
	int status = NC_NOERR;
#line 802
	void *xp;
#line 802

#line 802
	if(nelems == 0)
#line 802
		return NC_NOERR;
#line 802

#line 802
	assert(value != NULL);
#line 802

#line 802
	for(;;)
#line 802
	{
#line 802
		size_t extent = MIN(remaining, ncp->chunk);
#line 802
		size_t nput = ncx_howmany(varp->type, extent);
#line 802

#line 802
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 802
				 RGN_WRITE, &xp);
#line 802
		if(lstatus != NC_NOERR)
#line 802
			return lstatus;
#line 802

#line 802
		lstatus = ncx_putn_uint_short(&xp, nput, value);
#line 802
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 802
		{
#line 802
			/* not fatal to the loop */
#line 802
			status = lstatus;
#line 802
		}
#line 802

#line 802
		(void) ncio_rel(ncp->nciop, offset,
#line 802
				 RGN_MODIFIED);
#line 802

#line 802
		remaining -= extent;
#line 802
		if(remaining == 0)
#line 802
			break; /* normal loop exit */
#line 802
		offset += extent;
#line 802
		value += nput;
#line 802

#line 802
	}
#line 802

#line 802
	return status;
#line 802
}
#line 802

static int
#line 803
putNCvx_uint_int(NC3_INFO* ncp, const NC_var *varp,
#line 803
		 const size_t *start, size_t nelems, const int *value)
#line 803
{
#line 803
	off_t offset = NC_varoffset(ncp, varp, start);
#line 803
	size_t remaining = varp->xsz * nelems;
#line 803
	int status = NC_NOERR;
#line 803
	void *xp;
#line 803

#line 803
	if(nelems == 0)
#line 803
		return NC_NOERR;
#line 803

#line 803
	assert(value != NULL);
#line 803

#line 803
	for(;;)
#line 803
	{
#line 803
		size_t extent = MIN(remaining, ncp->chunk);
#line 803
		size_t nput = ncx_howmany(varp->type, extent);
#line 803

#line 803
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 803
				 RGN_WRITE, &xp);
#line 803
		if(lstatus != NC_NOERR)
#line 803
			return lstatus;
#line 803

#line 803
		lstatus = ncx_putn_uint_int(&xp, nput, value);
#line 803
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 803
		{
#line 803
			/* not fatal to the loop */
#line 803
			status = lstatus;
#line 803
		}
#line 803

#line 803
		(void) ncio_rel(ncp->nciop, offset,
#line 803
				 RGN_MODIFIED);
#line 803

#line 803
		remaining -= extent;
#line 803
		if(remaining == 0)
#line 803
			break; /* normal loop exit */
#line 803
		offset += extent;
#line 803
		value += nput;
#line 803

#line 803
	}
#line 803

#line 803
	return status;
#line 803
}
#line 803

static int
#line 804
putNCvx_uint_float(NC3_INFO* ncp, const NC_var *varp,
#line 804
		 const size_t *start, size_t nelems, const float *value)
#line 804
{
#line 804
	off_t offset = NC_varoffset(ncp, varp, start);
#line 804
	size_t remaining = varp->xsz * nelems;
#line 804
	int status = NC_NOERR;
#line 804
	void *xp;
#line 804

#line 804
	if(nelems == 0)
#line 804
		return NC_NOERR;
#line 804

#line 804
	assert(value != NULL);
#line 804

#line 804
	for(;;)
#line 804
	{
#line 804
		size_t extent = MIN(remaining, ncp->chunk);
#line 804
		size_t nput = ncx_howmany(varp->type, extent);
#line 804

#line 804
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 804
				 RGN_WRITE, &xp);
#line 804
		if(lstatus != NC_NOERR)
#line 804
			return lstatus;
#line 804

#line 804
		lstatus = ncx_putn_uint_float(&xp, nput, value);
#line 804
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 804
		{
#line 804
			/* not fatal to the loop */
#line 804
			status = lstatus;
#line 804
		}
#line 804

#line 804
		(void) ncio_rel(ncp->nciop, offset,
#line 804
				 RGN_MODIFIED);
#line 804

#line 804
		remaining -= extent;
#line 804
		if(remaining == 0)
#line 804
			break; /* normal loop exit */
#line 804
		offset += extent;
#line 804
		value += nput;
#line 804

#line 804
	}
#line 804

#line 804
	return status;
#line 804
}
#line 804

static int
#line 805
putNCvx_uint_double(NC3_INFO* ncp, const NC_var *varp,
#line 805
		 const size_t *start, size_t nelems, const double *value)
#line 805
{
#line 805
	off_t offset = NC_varoffset(ncp, varp, start);
#line 805
	size_t remaining = varp->xsz * nelems;
#line 805
	int status = NC_NOERR;
#line 805
	void *xp;
#line 805

#line 805
	if(nelems == 0)
#line 805
		return NC_NOERR;
#line 805

#line 805
	assert(value != NULL);
#line 805

#line 805
	for(;;)
#line 805
	{
#line 805
		size_t extent = MIN(remaining, ncp->chunk);
#line 805
		size_t nput = ncx_howmany(varp->type, extent);
#line 805

#line 805
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 805
				 RGN_WRITE, &xp);
#line 805
		if(lstatus != NC_NOERR)
#line 805
			return lstatus;
#line 805

#line 805
		lstatus = ncx_putn_uint_double(&xp, nput, value);
#line 805
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 805
		{
#line 805
			/* not fatal to the loop */
#line 805
			status = lstatus;
#line 805
		}
#line 805

#line 805
		(void) ncio_rel(ncp->nciop, offset,
#line 805
				 RGN_MODIFIED);
#line 805

#line 805
		remaining -= extent;
#line 805
		if(remaining == 0)
#line 805
			break; /* normal loop exit */
#line 805
		offset += extent;
#line 805
		value += nput;
#line 805

#line 805
	}
#line 805

#line 805
	return status;
#line 805
}
#line 805

static int
#line 806
putNCvx_uint_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 806
		 const size_t *start, size_t nelems, const longlong *value)
#line 806
{
#line 806
	off_t offset = NC_varoffset(ncp, varp, start);
#line 806
	size_t remaining = varp->xsz * nelems;
#line 806
	int status = NC_NOERR;
#line 806
	void *xp;
#line 806

#line 806
	if(nelems == 0)
#line 806
		return NC_NOERR;
#line 806

#line 806
	assert(value != NULL);
#line 806

#line 806
	for(;;)
#line 806
	{
#line 806
		size_t extent = MIN(remaining, ncp->chunk);
#line 806
		size_t nput = ncx_howmany(varp->type, extent);
#line 806

#line 806
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 806
				 RGN_WRITE, &xp);
#line 806
		if(lstatus != NC_NOERR)
#line 806
			return lstatus;
#line 806

#line 806
		lstatus = ncx_putn_uint_longlong(&xp, nput, value);
#line 806
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 806
		{
#line 806
			/* not fatal to the loop */
#line 806
			status = lstatus;
#line 806
		}
#line 806

#line 806
		(void) ncio_rel(ncp->nciop, offset,
#line 806
				 RGN_MODIFIED);
#line 806

#line 806
		remaining -= extent;
#line 806
		if(remaining == 0)
#line 806
			break; /* normal loop exit */
#line 806
		offset += extent;
#line 806
		value += nput;
#line 806

#line 806
	}
#line 806

#line 806
	return status;
#line 806
}
#line 806

static int
#line 807
putNCvx_uint_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 807
		 const size_t *start, size_t nelems, const ushort *value)
#line 807
{
#line 807
	off_t offset = NC_varoffset(ncp, varp, start);
#line 807
	size_t remaining = varp->xsz * nelems;
#line 807
	int status = NC_NOERR;
#line 807
	void *xp;
#line 807

#line 807
	if(nelems == 0)
#line 807
		return NC_NOERR;
#line 807

#line 807
	assert(value != NULL);
#line 807

#line 807
	for(;;)
#line 807
	{
#line 807
		size_t extent = MIN(remaining, ncp->chunk);
#line 807
		size_t nput = ncx_howmany(varp->type, extent);
#line 807

#line 807
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 807
				 RGN_WRITE, &xp);
#line 807
		if(lstatus != NC_NOERR)
#line 807
			return lstatus;
#line 807

#line 807
		lstatus = ncx_putn_uint_ushort(&xp, nput, value);
#line 807
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 807
		{
#line 807
			/* not fatal to the loop */
#line 807
			status = lstatus;
#line 807
		}
#line 807

#line 807
		(void) ncio_rel(ncp->nciop, offset,
#line 807
				 RGN_MODIFIED);
#line 807

#line 807
		remaining -= extent;
#line 807
		if(remaining == 0)
#line 807
			break; /* normal loop exit */
#line 807
		offset += extent;
#line 807
		value += nput;
#line 807

#line 807
	}
#line 807

#line 807
	return status;
#line 807
}
#line 807

static int
#line 808
putNCvx_uint_uint(NC3_INFO* ncp, const NC_var *varp,
#line 808
		 const size_t *start, size_t nelems, const uint *value)
#line 808
{
#line 808
	off_t offset = NC_varoffset(ncp, varp, start);
#line 808
	size_t remaining = varp->xsz * nelems;
#line 808
	int status = NC_NOERR;
#line 808
	void *xp;
#line 808

#line 808
	if(nelems == 0)
#line 808
		return NC_NOERR;
#line 808

#line 808
	assert(value != NULL);
#line 808

#line 808
	for(;;)
#line 808
	{
#line 808
		size_t extent = MIN(remaining, ncp->chunk);
#line 808
		size_t nput = ncx_howmany(varp->type, extent);
#line 808

#line 808
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 808
				 RGN_WRITE, &xp);
#line 808
		if(lstatus != NC_NOERR)
#line 808
			return lstatus;
#line 808

#line 808
		lstatus = ncx_putn_uint_uint(&xp, nput, value);
#line 808
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 808
		{
#line 808
			/* not fatal to the loop */
#line 808
			status = lstatus;
#line 808
		}
#line 808

#line 808
		(void) ncio_rel(ncp->nciop, offset,
#line 808
				 RGN_MODIFIED);
#line 808

#line 808
		remaining -= extent;
#line 808
		if(remaining == 0)
#line 808
			break; /* normal loop exit */
#line 808
		offset += extent;
#line 808
		value += nput;
#line 808

#line 808
	}
#line 808

#line 808
	return status;
#line 808
}
#line 808

static int
#line 809
putNCvx_uint_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 809
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 809
{
#line 809
	off_t offset = NC_varoffset(ncp, varp, start);
#line 809
	size_t remaining = varp->xsz * nelems;
#line 809
	int status = NC_NOERR;
#line 809
	void *xp;
#line 809

#line 809
	if(nelems == 0)
#line 809
		return NC_NOERR;
#line 809

#line 809
	assert(value != NULL);
#line 809

#line 809
	for(;;)
#line 809
	{
#line 809
		size_t extent = MIN(remaining, ncp->chunk);
#line 809
		size_t nput = ncx_howmany(varp->type, extent);
#line 809

#line 809
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 809
				 RGN_WRITE, &xp);
#line 809
		if(lstatus != NC_NOERR)
#line 809
			return lstatus;
#line 809

#line 809
		lstatus = ncx_putn_uint_ulonglong(&xp, nput, value);
#line 809
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 809
		{
#line 809
			/* not fatal to the loop */
#line 809
			status = lstatus;
#line 809
		}
#line 809

#line 809
		(void) ncio_rel(ncp->nciop, offset,
#line 809
				 RGN_MODIFIED);
#line 809

#line 809
		remaining -= extent;
#line 809
		if(remaining == 0)
#line 809
			break; /* normal loop exit */
#line 809
		offset += extent;
#line 809
		value += nput;
#line 809

#line 809
	}
#line 809

#line 809
	return status;
#line 809
}
#line 809


static int
#line 811
putNCvx_longlong_schar(NC3_INFO* ncp, const NC_var *varp,
#line 811
		 const size_t *start, size_t nelems, const schar *value)
#line 811
{
#line 811
	off_t offset = NC_varoffset(ncp, varp, start);
#line 811
	size_t remaining = varp->xsz * nelems;
#line 811
	int status = NC_NOERR;
#line 811
	void *xp;
#line 811

#line 811
	if(nelems == 0)
#line 811
		return NC_NOERR;
#line 811

#line 811
	assert(value != NULL);
#line 811

#line 811
	for(;;)
#line 811
	{
#line 811
		size_t extent = MIN(remaining, ncp->chunk);
#line 811
		size_t nput = ncx_howmany(varp->type, extent);
#line 811

#line 811
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 811
				 RGN_WRITE, &xp);
#line 811
		if(lstatus != NC_NOERR)
#line 811
			return lstatus;
#line 811

#line 811
		lstatus = ncx_putn_longlong_schar(&xp, nput, value);
#line 811
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 811
		{
#line 811
			/* not fatal to the loop */
#line 811
			status = lstatus;
#line 811
		}
#line 811

#line 811
		(void) ncio_rel(ncp->nciop, offset,
#line 811
				 RGN_MODIFIED);
#line 811

#line 811
		remaining -= extent;
#line 811
		if(remaining == 0)
#line 811
			break; /* normal loop exit */
#line 811
		offset += extent;
#line 811
		value += nput;
#line 811

#line 811
	}
#line 811

#line 811
	return status;
#line 811
}
#line 811

static int
#line 812
putNCvx_longlong_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 812
		 const size_t *start, size_t nelems, const uchar *value)
#line 812
{
#line 812
	off_t offset = NC_varoffset(ncp, varp, start);
#line 812
	size_t remaining = varp->xsz * nelems;
#line 812
	int status = NC_NOERR;
#line 812
	void *xp;
#line 812

#line 812
	if(nelems == 0)
#line 812
		return NC_NOERR;
#line 812

#line 812
	assert(value != NULL);
#line 812

#line 812
	for(;;)
#line 812
	{
#line 812
		size_t extent = MIN(remaining, ncp->chunk);
#line 812
		size_t nput = ncx_howmany(varp->type, extent);
#line 812

#line 812
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 812
				 RGN_WRITE, &xp);
#line 812
		if(lstatus != NC_NOERR)
#line 812
			return lstatus;
#line 812

#line 812
		lstatus = ncx_putn_longlong_uchar(&xp, nput, value);
#line 812
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 812
		{
#line 812
			/* not fatal to the loop */
#line 812
			status = lstatus;
#line 812
		}
#line 812

#line 812
		(void) ncio_rel(ncp->nciop, offset,
#line 812
				 RGN_MODIFIED);
#line 812

#line 812
		remaining -= extent;
#line 812
		if(remaining == 0)
#line 812
			break; /* normal loop exit */
#line 812
		offset += extent;
#line 812
		value += nput;
#line 812

#line 812
	}
#line 812

#line 812
	return status;
#line 812
}
#line 812

static int
#line 813
putNCvx_longlong_short(NC3_INFO* ncp, const NC_var *varp,
#line 813
		 const size_t *start, size_t nelems, const short *value)
#line 813
{
#line 813
	off_t offset = NC_varoffset(ncp, varp, start);
#line 813
	size_t remaining = varp->xsz * nelems;
#line 813
	int status = NC_NOERR;
#line 813
	void *xp;
#line 813

#line 813
	if(nelems == 0)
#line 813
		return NC_NOERR;
#line 813

#line 813
	assert(value != NULL);
#line 813

#line 813
	for(;;)
#line 813
	{
#line 813
		size_t extent = MIN(remaining, ncp->chunk);
#line 813
		size_t nput = ncx_howmany(varp->type, extent);
#line 813

#line 813
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 813
				 RGN_WRITE, &xp);
#line 813
		if(lstatus != NC_NOERR)
#line 813
			return lstatus;
#line 813

#line 813
		lstatus = ncx_putn_longlong_short(&xp, nput, value);
#line 813
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 813
		{
#line 813
			/* not fatal to the loop */
#line 813
			status = lstatus;
#line 813
		}
#line 813

#line 813
		(void) ncio_rel(ncp->nciop, offset,
#line 813
				 RGN_MODIFIED);
#line 813

#line 813
		remaining -= extent;
#line 813
		if(remaining == 0)
#line 813
			break; /* normal loop exit */
#line 813
		offset += extent;
#line 813
		value += nput;
#line 813

#line 813
	}
#line 813

#line 813
	return status;
#line 813
}
#line 813

static int
#line 814
putNCvx_longlong_int(NC3_INFO* ncp, const NC_var *varp,
#line 814
		 const size_t *start, size_t nelems, const int *value)
#line 814
{
#line 814
	off_t offset = NC_varoffset(ncp, varp, start);
#line 814
	size_t remaining = varp->xsz * nelems;
#line 814
	int status = NC_NOERR;
#line 814
	void *xp;
#line 814

#line 814
	if(nelems == 0)
#line 814
		return NC_NOERR;
#line 814

#line 814
	assert(value != NULL);
#line 814

#line 814
	for(;;)
#line 814
	{
#line 814
		size_t extent = MIN(remaining, ncp->chunk);
#line 814
		size_t nput = ncx_howmany(varp->type, extent);
#line 814

#line 814
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 814
				 RGN_WRITE, &xp);
#line 814
		if(lstatus != NC_NOERR)
#line 814
			return lstatus;
#line 814

#line 814
		lstatus = ncx_putn_longlong_int(&xp, nput, value);
#line 814
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 814
		{
#line 814
			/* not fatal to the loop */
#line 814
			status = lstatus;
#line 814
		}
#line 814

#line 814
		(void) ncio_rel(ncp->nciop, offset,
#line 814
				 RGN_MODIFIED);
#line 814

#line 814
		remaining -= extent;
#line 814
		if(remaining == 0)
#line 814
			break; /* normal loop exit */
#line 814
		offset += extent;
#line 814
		value += nput;
#line 814

#line 814
	}
#line 814

#line 814
	return status;
#line 814
}
#line 814

static int
#line 815
putNCvx_longlong_float(NC3_INFO* ncp, const NC_var *varp,
#line 815
		 const size_t *start, size_t nelems, const float *value)
#line 815
{
#line 815
	off_t offset = NC_varoffset(ncp, varp, start);
#line 815
	size_t remaining = varp->xsz * nelems;
#line 815
	int status = NC_NOERR;
#line 815
	void *xp;
#line 815

#line 815
	if(nelems == 0)
#line 815
		return NC_NOERR;
#line 815

#line 815
	assert(value != NULL);
#line 815

#line 815
	for(;;)
#line 815
	{
#line 815
		size_t extent = MIN(remaining, ncp->chunk);
#line 815
		size_t nput = ncx_howmany(varp->type, extent);
#line 815

#line 815
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 815
				 RGN_WRITE, &xp);
#line 815
		if(lstatus != NC_NOERR)
#line 815
			return lstatus;
#line 815

#line 815
		lstatus = ncx_putn_longlong_float(&xp, nput, value);
#line 815
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 815
		{
#line 815
			/* not fatal to the loop */
#line 815
			status = lstatus;
#line 815
		}
#line 815

#line 815
		(void) ncio_rel(ncp->nciop, offset,
#line 815
				 RGN_MODIFIED);
#line 815

#line 815
		remaining -= extent;
#line 815
		if(remaining == 0)
#line 815
			break; /* normal loop exit */
#line 815
		offset += extent;
#line 815
		value += nput;
#line 815

#line 815
	}
#line 815

#line 815
	return status;
#line 815
}
#line 815

static int
#line 816
putNCvx_longlong_double(NC3_INFO* ncp, const NC_var *varp,
#line 816
		 const size_t *start, size_t nelems, const double *value)
#line 816
{
#line 816
	off_t offset = NC_varoffset(ncp, varp, start);
#line 816
	size_t remaining = varp->xsz * nelems;
#line 816
	int status = NC_NOERR;
#line 816
	void *xp;
#line 816

#line 816
	if(nelems == 0)
#line 816
		return NC_NOERR;
#line 816

#line 816
	assert(value != NULL);
#line 816

#line 816
	for(;;)
#line 816
	{
#line 816
		size_t extent = MIN(remaining, ncp->chunk);
#line 816
		size_t nput = ncx_howmany(varp->type, extent);
#line 816

#line 816
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 816
				 RGN_WRITE, &xp);
#line 816
		if(lstatus != NC_NOERR)
#line 816
			return lstatus;
#line 816

#line 816
		lstatus = ncx_putn_longlong_double(&xp, nput, value);
#line 816
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 816
		{
#line 816
			/* not fatal to the loop */
#line 816
			status = lstatus;
#line 816
		}
#line 816

#line 816
		(void) ncio_rel(ncp->nciop, offset,
#line 816
				 RGN_MODIFIED);
#line 816

#line 816
		remaining -= extent;
#line 816
		if(remaining == 0)
#line 816
			break; /* normal loop exit */
#line 816
		offset += extent;
#line 816
		value += nput;
#line 816

#line 816
	}
#line 816

#line 816
	return status;
#line 816
}
#line 816

static int
#line 817
putNCvx_longlong_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 817
		 const size_t *start, size_t nelems, const longlong *value)
#line 817
{
#line 817
	off_t offset = NC_varoffset(ncp, varp, start);
#line 817
	size_t remaining = varp->xsz * nelems;
#line 817
	int status = NC_NOERR;
#line 817
	void *xp;
#line 817

#line 817
	if(nelems == 0)
#line 817
		return NC_NOERR;
#line 817

#line 817
	assert(value != NULL);
#line 817

#line 817
	for(;;)
#line 817
	{
#line 817
		size_t extent = MIN(remaining, ncp->chunk);
#line 817
		size_t nput = ncx_howmany(varp->type, extent);
#line 817

#line 817
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 817
				 RGN_WRITE, &xp);
#line 817
		if(lstatus != NC_NOERR)
#line 817
			return lstatus;
#line 817

#line 817
		lstatus = ncx_putn_longlong_longlong(&xp, nput, value);
#line 817
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 817
		{
#line 817
			/* not fatal to the loop */
#line 817
			status = lstatus;
#line 817
		}
#line 817

#line 817
		(void) ncio_rel(ncp->nciop, offset,
#line 817
				 RGN_MODIFIED);
#line 817

#line 817
		remaining -= extent;
#line 817
		if(remaining == 0)
#line 817
			break; /* normal loop exit */
#line 817
		offset += extent;
#line 817
		value += nput;
#line 817

#line 817
	}
#line 817

#line 817
	return status;
#line 817
}
#line 817

static int
#line 818
putNCvx_longlong_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 818
		 const size_t *start, size_t nelems, const ushort *value)
#line 818
{
#line 818
	off_t offset = NC_varoffset(ncp, varp, start);
#line 818
	size_t remaining = varp->xsz * nelems;
#line 818
	int status = NC_NOERR;
#line 818
	void *xp;
#line 818

#line 818
	if(nelems == 0)
#line 818
		return NC_NOERR;
#line 818

#line 818
	assert(value != NULL);
#line 818

#line 818
	for(;;)
#line 818
	{
#line 818
		size_t extent = MIN(remaining, ncp->chunk);
#line 818
		size_t nput = ncx_howmany(varp->type, extent);
#line 818

#line 818
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 818
				 RGN_WRITE, &xp);
#line 818
		if(lstatus != NC_NOERR)
#line 818
			return lstatus;
#line 818

#line 818
		lstatus = ncx_putn_longlong_ushort(&xp, nput, value);
#line 818
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 818
		{
#line 818
			/* not fatal to the loop */
#line 818
			status = lstatus;
#line 818
		}
#line 818

#line 818
		(void) ncio_rel(ncp->nciop, offset,
#line 818
				 RGN_MODIFIED);
#line 818

#line 818
		remaining -= extent;
#line 818
		if(remaining == 0)
#line 818
			break; /* normal loop exit */
#line 818
		offset += extent;
#line 818
		value += nput;
#line 818

#line 818
	}
#line 818

#line 818
	return status;
#line 818
}
#line 818

static int
#line 819
putNCvx_longlong_uint(NC3_INFO* ncp, const NC_var *varp,
#line 819
		 const size_t *start, size_t nelems, const uint *value)
#line 819
{
#line 819
	off_t offset = NC_varoffset(ncp, varp, start);
#line 819
	size_t remaining = varp->xsz * nelems;
#line 819
	int status = NC_NOERR;
#line 819
	void *xp;
#line 819

#line 819
	if(nelems == 0)
#line 819
		return NC_NOERR;
#line 819

#line 819
	assert(value != NULL);
#line 819

#line 819
	for(;;)
#line 819
	{
#line 819
		size_t extent = MIN(remaining, ncp->chunk);
#line 819
		size_t nput = ncx_howmany(varp->type, extent);
#line 819

#line 819
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 819
				 RGN_WRITE, &xp);
#line 819
		if(lstatus != NC_NOERR)
#line 819
			return lstatus;
#line 819

#line 819
		lstatus = ncx_putn_longlong_uint(&xp, nput, value);
#line 819
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 819
		{
#line 819
			/* not fatal to the loop */
#line 819
			status = lstatus;
#line 819
		}
#line 819

#line 819
		(void) ncio_rel(ncp->nciop, offset,
#line 819
				 RGN_MODIFIED);
#line 819

#line 819
		remaining -= extent;
#line 819
		if(remaining == 0)
#line 819
			break; /* normal loop exit */
#line 819
		offset += extent;
#line 819
		value += nput;
#line 819

#line 819
	}
#line 819

#line 819
	return status;
#line 819
}
#line 819

static int
#line 820
putNCvx_longlong_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 820
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 820
{
#line 820
	off_t offset = NC_varoffset(ncp, varp, start);
#line 820
	size_t remaining = varp->xsz * nelems;
#line 820
	int status = NC_NOERR;
#line 820
	void *xp;
#line 820

#line 820
	if(nelems == 0)
#line 820
		return NC_NOERR;
#line 820

#line 820
	assert(value != NULL);
#line 820

#line 820
	for(;;)
#line 820
	{
#line 820
		size_t extent = MIN(remaining, ncp->chunk);
#line 820
		size_t nput = ncx_howmany(varp->type, extent);
#line 820

#line 820
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 820
				 RGN_WRITE, &xp);
#line 820
		if(lstatus != NC_NOERR)
#line 820
			return lstatus;
#line 820

#line 820
		lstatus = ncx_putn_longlong_ulonglong(&xp, nput, value);
#line 820
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 820
		{
#line 820
			/* not fatal to the loop */
#line 820
			status = lstatus;
#line 820
		}
#line 820

#line 820
		(void) ncio_rel(ncp->nciop, offset,
#line 820
				 RGN_MODIFIED);
#line 820

#line 820
		remaining -= extent;
#line 820
		if(remaining == 0)
#line 820
			break; /* normal loop exit */
#line 820
		offset += extent;
#line 820
		value += nput;
#line 820

#line 820
	}
#line 820

#line 820
	return status;
#line 820
}
#line 820


static int
#line 822
putNCvx_ulonglong_schar(NC3_INFO* ncp, const NC_var *varp,
#line 822
		 const size_t *start, size_t nelems, const schar *value)
#line 822
{
#line 822
	off_t offset = NC_varoffset(ncp, varp, start);
#line 822
	size_t remaining = varp->xsz * nelems;
#line 822
	int status = NC_NOERR;
#line 822
	void *xp;
#line 822

#line 822
	if(nelems == 0)
#line 822
		return NC_NOERR;
#line 822

#line 822
	assert(value != NULL);
#line 822

#line 822
	for(;;)
#line 822
	{
#line 822
		size_t extent = MIN(remaining, ncp->chunk);
#line 822
		size_t nput = ncx_howmany(varp->type, extent);
#line 822

#line 822
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 822
				 RGN_WRITE, &xp);
#line 822
		if(lstatus != NC_NOERR)
#line 822
			return lstatus;
#line 822

#line 822
		lstatus = ncx_putn_ulonglong_schar(&xp, nput, value);
#line 822
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 822
		{
#line 822
			/* not fatal to the loop */
#line 822
			status = lstatus;
#line 822
		}
#line 822

#line 822
		(void) ncio_rel(ncp->nciop, offset,
#line 822
				 RGN_MODIFIED);
#line 822

#line 822
		remaining -= extent;
#line 822
		if(remaining == 0)
#line 822
			break; /* normal loop exit */
#line 822
		offset += extent;
#line 822
		value += nput;
#line 822

#line 822
	}
#line 822

#line 822
	return status;
#line 822
}
#line 822

static int
#line 823
putNCvx_ulonglong_uchar(NC3_INFO* ncp, const NC_var *varp,
#line 823
		 const size_t *start, size_t nelems, const uchar *value)
#line 823
{
#line 823
	off_t offset = NC_varoffset(ncp, varp, start);
#line 823
	size_t remaining = varp->xsz * nelems;
#line 823
	int status = NC_NOERR;
#line 823
	void *xp;
#line 823

#line 823
	if(nelems == 0)
#line 823
		return NC_NOERR;
#line 823

#line 823
	assert(value != NULL);
#line 823

#line 823
	for(;;)
#line 823
	{
#line 823
		size_t extent = MIN(remaining, ncp->chunk);
#line 823
		size_t nput = ncx_howmany(varp->type, extent);
#line 823

#line 823
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 823
				 RGN_WRITE, &xp);
#line 823
		if(lstatus != NC_NOERR)
#line 823
			return lstatus;
#line 823

#line 823
		lstatus = ncx_putn_ulonglong_uchar(&xp, nput, value);
#line 823
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 823
		{
#line 823
			/* not fatal to the loop */
#line 823
			status = lstatus;
#line 823
		}
#line 823

#line 823
		(void) ncio_rel(ncp->nciop, offset,
#line 823
				 RGN_MODIFIED);
#line 823

#line 823
		remaining -= extent;
#line 823
		if(remaining == 0)
#line 823
			break; /* normal loop exit */
#line 823
		offset += extent;
#line 823
		value += nput;
#line 823

#line 823
	}
#line 823

#line 823
	return status;
#line 823
}
#line 823

static int
#line 824
putNCvx_ulonglong_short(NC3_INFO* ncp, const NC_var *varp,
#line 824
		 const size_t *start, size_t nelems, const short *value)
#line 824
{
#line 824
	off_t offset = NC_varoffset(ncp, varp, start);
#line 824
	size_t remaining = varp->xsz * nelems;
#line 824
	int status = NC_NOERR;
#line 824
	void *xp;
#line 824

#line 824
	if(nelems == 0)
#line 824
		return NC_NOERR;
#line 824

#line 824
	assert(value != NULL);
#line 824

#line 824
	for(;;)
#line 824
	{
#line 824
		size_t extent = MIN(remaining, ncp->chunk);
#line 824
		size_t nput = ncx_howmany(varp->type, extent);
#line 824

#line 824
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 824
				 RGN_WRITE, &xp);
#line 824
		if(lstatus != NC_NOERR)
#line 824
			return lstatus;
#line 824

#line 824
		lstatus = ncx_putn_ulonglong_short(&xp, nput, value);
#line 824
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 824
		{
#line 824
			/* not fatal to the loop */
#line 824
			status = lstatus;
#line 824
		}
#line 824

#line 824
		(void) ncio_rel(ncp->nciop, offset,
#line 824
				 RGN_MODIFIED);
#line 824

#line 824
		remaining -= extent;
#line 824
		if(remaining == 0)
#line 824
			break; /* normal loop exit */
#line 824
		offset += extent;
#line 824
		value += nput;
#line 824

#line 824
	}
#line 824

#line 824
	return status;
#line 824
}
#line 824

static int
#line 825
putNCvx_ulonglong_int(NC3_INFO* ncp, const NC_var *varp,
#line 825
		 const size_t *start, size_t nelems, const int *value)
#line 825
{
#line 825
	off_t offset = NC_varoffset(ncp, varp, start);
#line 825
	size_t remaining = varp->xsz * nelems;
#line 825
	int status = NC_NOERR;
#line 825
	void *xp;
#line 825

#line 825
	if(nelems == 0)
#line 825
		return NC_NOERR;
#line 825

#line 825
	assert(value != NULL);
#line 825

#line 825
	for(;;)
#line 825
	{
#line 825
		size_t extent = MIN(remaining, ncp->chunk);
#line 825
		size_t nput = ncx_howmany(varp->type, extent);
#line 825

#line 825
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 825
				 RGN_WRITE, &xp);
#line 825
		if(lstatus != NC_NOERR)
#line 825
			return lstatus;
#line 825

#line 825
		lstatus = ncx_putn_ulonglong_int(&xp, nput, value);
#line 825
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 825
		{
#line 825
			/* not fatal to the loop */
#line 825
			status = lstatus;
#line 825
		}
#line 825

#line 825
		(void) ncio_rel(ncp->nciop, offset,
#line 825
				 RGN_MODIFIED);
#line 825

#line 825
		remaining -= extent;
#line 825
		if(remaining == 0)
#line 825
			break; /* normal loop exit */
#line 825
		offset += extent;
#line 825
		value += nput;
#line 825

#line 825
	}
#line 825

#line 825
	return status;
#line 825
}
#line 825

static int
#line 826
putNCvx_ulonglong_float(NC3_INFO* ncp, const NC_var *varp,
#line 826
		 const size_t *start, size_t nelems, const float *value)
#line 826
{
#line 826
	off_t offset = NC_varoffset(ncp, varp, start);
#line 826
	size_t remaining = varp->xsz * nelems;
#line 826
	int status = NC_NOERR;
#line 826
	void *xp;
#line 826

#line 826
	if(nelems == 0)
#line 826
		return NC_NOERR;
#line 826

#line 826
	assert(value != NULL);
#line 826

#line 826
	for(;;)
#line 826
	{
#line 826
		size_t extent = MIN(remaining, ncp->chunk);
#line 826
		size_t nput = ncx_howmany(varp->type, extent);
#line 826

#line 826
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 826
				 RGN_WRITE, &xp);
#line 826
		if(lstatus != NC_NOERR)
#line 826
			return lstatus;
#line 826

#line 826
		lstatus = ncx_putn_ulonglong_float(&xp, nput, value);
#line 826
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 826
		{
#line 826
			/* not fatal to the loop */
#line 826
			status = lstatus;
#line 826
		}
#line 826

#line 826
		(void) ncio_rel(ncp->nciop, offset,
#line 826
				 RGN_MODIFIED);
#line 826

#line 826
		remaining -= extent;
#line 826
		if(remaining == 0)
#line 826
			break; /* normal loop exit */
#line 826
		offset += extent;
#line 826
		value += nput;
#line 826

#line 826
	}
#line 826

#line 826
	return status;
#line 826
}
#line 826

static int
#line 827
putNCvx_ulonglong_double(NC3_INFO* ncp, const NC_var *varp,
#line 827
		 const size_t *start, size_t nelems, const double *value)
#line 827
{
#line 827
	off_t offset = NC_varoffset(ncp, varp, start);
#line 827
	size_t remaining = varp->xsz * nelems;
#line 827
	int status = NC_NOERR;
#line 827
	void *xp;
#line 827

#line 827
	if(nelems == 0)
#line 827
		return NC_NOERR;
#line 827

#line 827
	assert(value != NULL);
#line 827

#line 827
	for(;;)
#line 827
	{
#line 827
		size_t extent = MIN(remaining, ncp->chunk);
#line 827
		size_t nput = ncx_howmany(varp->type, extent);
#line 827

#line 827
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 827
				 RGN_WRITE, &xp);
#line 827
		if(lstatus != NC_NOERR)
#line 827
			return lstatus;
#line 827

#line 827
		lstatus = ncx_putn_ulonglong_double(&xp, nput, value);
#line 827
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 827
		{
#line 827
			/* not fatal to the loop */
#line 827
			status = lstatus;
#line 827
		}
#line 827

#line 827
		(void) ncio_rel(ncp->nciop, offset,
#line 827
				 RGN_MODIFIED);
#line 827

#line 827
		remaining -= extent;
#line 827
		if(remaining == 0)
#line 827
			break; /* normal loop exit */
#line 827
		offset += extent;
#line 827
		value += nput;
#line 827

#line 827
	}
#line 827

#line 827
	return status;
#line 827
}
#line 827

static int
#line 828
putNCvx_ulonglong_longlong(NC3_INFO* ncp, const NC_var *varp,
#line 828
		 const size_t *start, size_t nelems, const longlong *value)
#line 828
{
#line 828
	off_t offset = NC_varoffset(ncp, varp, start);
#line 828
	size_t remaining = varp->xsz * nelems;
#line 828
	int status = NC_NOERR;
#line 828
	void *xp;
#line 828

#line 828
	if(nelems == 0)
#line 828
		return NC_NOERR;
#line 828

#line 828
	assert(value != NULL);
#line 828

#line 828
	for(;;)
#line 828
	{
#line 828
		size_t extent = MIN(remaining, ncp->chunk);
#line 828
		size_t nput = ncx_howmany(varp->type, extent);
#line 828

#line 828
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 828
				 RGN_WRITE, &xp);
#line 828
		if(lstatus != NC_NOERR)
#line 828
			return lstatus;
#line 828

#line 828
		lstatus = ncx_putn_ulonglong_longlong(&xp, nput, value);
#line 828
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 828
		{
#line 828
			/* not fatal to the loop */
#line 828
			status = lstatus;
#line 828
		}
#line 828

#line 828
		(void) ncio_rel(ncp->nciop, offset,
#line 828
				 RGN_MODIFIED);
#line 828

#line 828
		remaining -= extent;
#line 828
		if(remaining == 0)
#line 828
			break; /* normal loop exit */
#line 828
		offset += extent;
#line 828
		value += nput;
#line 828

#line 828
	}
#line 828

#line 828
	return status;
#line 828
}
#line 828

static int
#line 829
putNCvx_ulonglong_ushort(NC3_INFO* ncp, const NC_var *varp,
#line 829
		 const size_t *start, size_t nelems, const ushort *value)
#line 829
{
#line 829
	off_t offset = NC_varoffset(ncp, varp, start);
#line 829
	size_t remaining = varp->xsz * nelems;
#line 829
	int status = NC_NOERR;
#line 829
	void *xp;
#line 829

#line 829
	if(nelems == 0)
#line 829
		return NC_NOERR;
#line 829

#line 829
	assert(value != NULL);
#line 829

#line 829
	for(;;)
#line 829
	{
#line 829
		size_t extent = MIN(remaining, ncp->chunk);
#line 829
		size_t nput = ncx_howmany(varp->type, extent);
#line 829

#line 829
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 829
				 RGN_WRITE, &xp);
#line 829
		if(lstatus != NC_NOERR)
#line 829
			return lstatus;
#line 829

#line 829
		lstatus = ncx_putn_ulonglong_ushort(&xp, nput, value);
#line 829
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 829
		{
#line 829
			/* not fatal to the loop */
#line 829
			status = lstatus;
#line 829
		}
#line 829

#line 829
		(void) ncio_rel(ncp->nciop, offset,
#line 829
				 RGN_MODIFIED);
#line 829

#line 829
		remaining -= extent;
#line 829
		if(remaining == 0)
#line 829
			break; /* normal loop exit */
#line 829
		offset += extent;
#line 829
		value += nput;
#line 829

#line 829
	}
#line 829

#line 829
	return status;
#line 829
}
#line 829

static int
#line 830
putNCvx_ulonglong_uint(NC3_INFO* ncp, const NC_var *varp,
#line 830
		 const size_t *start, size_t nelems, const uint *value)
#line 830
{
#line 830
	off_t offset = NC_varoffset(ncp, varp, start);
#line 830
	size_t remaining = varp->xsz * nelems;
#line 830
	int status = NC_NOERR;
#line 830
	void *xp;
#line 830

#line 830
	if(nelems == 0)
#line 830
		return NC_NOERR;
#line 830

#line 830
	assert(value != NULL);
#line 830

#line 830
	for(;;)
#line 830
	{
#line 830
		size_t extent = MIN(remaining, ncp->chunk);
#line 830
		size_t nput = ncx_howmany(varp->type, extent);
#line 830

#line 830
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 830
				 RGN_WRITE, &xp);
#line 830
		if(lstatus != NC_NOERR)
#line 830
			return lstatus;
#line 830

#line 830
		lstatus = ncx_putn_ulonglong_uint(&xp, nput, value);
#line 830
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 830
		{
#line 830
			/* not fatal to the loop */
#line 830
			status = lstatus;
#line 830
		}
#line 830

#line 830
		(void) ncio_rel(ncp->nciop, offset,
#line 830
				 RGN_MODIFIED);
#line 830

#line 830
		remaining -= extent;
#line 830
		if(remaining == 0)
#line 830
			break; /* normal loop exit */
#line 830
		offset += extent;
#line 830
		value += nput;
#line 830

#line 830
	}
#line 830

#line 830
	return status;
#line 830
}
#line 830

static int
#line 831
putNCvx_ulonglong_ulonglong(NC3_INFO* ncp, const NC_var *varp,
#line 831
		 const size_t *start, size_t nelems, const ulonglong *value)
#line 831
{
#line 831
	off_t offset = NC_varoffset(ncp, varp, start);
#line 831
	size_t remaining = varp->xsz * nelems;
#line 831
	int status = NC_NOERR;
#line 831
	void *xp;
#line 831

#line 831
	if(nelems == 0)
#line 831
		return NC_NOERR;
#line 831

#line 831
	assert(value != NULL);
#line 831

#line 831
	for(;;)
#line 831
	{
#line 831
		size_t extent = MIN(remaining, ncp->chunk);
#line 831
		size_t nput = ncx_howmany(varp->type, extent);
#line 831

#line 831
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 831
				 RGN_WRITE, &xp);
#line 831
		if(lstatus != NC_NOERR)
#line 831
			return lstatus;
#line 831

#line 831
		lstatus = ncx_putn_ulonglong_ulonglong(&xp, nput, value);
#line 831
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 831
		{
#line 831
			/* not fatal to the loop */
#line 831
			status = lstatus;
#line 831
		}
#line 831

#line 831
		(void) ncio_rel(ncp->nciop, offset,
#line 831
				 RGN_MODIFIED);
#line 831

#line 831
		remaining -= extent;
#line 831
		if(remaining == 0)
#line 831
			break; /* normal loop exit */
#line 831
		offset += extent;
#line 831
		value += nput;
#line 831

#line 831
	}
#line 831

#line 831
	return status;
#line 831
}
#line 831


#line 878

static int
#line 879
getNCvx_char_char(const NC3_INFO* ncp, const NC_var *varp,
#line 879
		 const size_t *start, size_t nelems, char *value)
#line 879
{
#line 879
	off_t offset = NC_varoffset(ncp, varp, start);
#line 879
	size_t remaining = varp->xsz * nelems;
#line 879
	int status = NC_NOERR;
#line 879
	const void *xp;
#line 879

#line 879
	if(nelems == 0)
#line 879
		return NC_NOERR;
#line 879

#line 879
	assert(value != NULL);
#line 879

#line 879
	for(;;)
#line 879
	{
#line 879
		size_t extent = MIN(remaining, ncp->chunk);
#line 879
		size_t nget = ncx_howmany(varp->type, extent);
#line 879

#line 879
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 879
				 0, (void **)&xp);	/* cast away const */
#line 879
		if(lstatus != NC_NOERR)
#line 879
			return lstatus;
#line 879

#line 879
		lstatus = ncx_getn_char_char(&xp, nget, value);
#line 879
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 879
			status = lstatus;
#line 879

#line 879
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 879

#line 879
		remaining -= extent;
#line 879
		if(remaining == 0)
#line 879
			break; /* normal loop exit */
#line 879
		offset += extent;
#line 879
		value += nget;
#line 879
	}
#line 879

#line 879
	return status;
#line 879
}
#line 879


static int
#line 881
getNCvx_schar_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 881
		 const size_t *start, size_t nelems, schar *value)
#line 881
{
#line 881
	off_t offset = NC_varoffset(ncp, varp, start);
#line 881
	size_t remaining = varp->xsz * nelems;
#line 881
	int status = NC_NOERR;
#line 881
	const void *xp;
#line 881

#line 881
	if(nelems == 0)
#line 881
		return NC_NOERR;
#line 881

#line 881
	assert(value != NULL);
#line 881

#line 881
	for(;;)
#line 881
	{
#line 881
		size_t extent = MIN(remaining, ncp->chunk);
#line 881
		size_t nget = ncx_howmany(varp->type, extent);
#line 881

#line 881
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 881
				 0, (void **)&xp);	/* cast away const */
#line 881
		if(lstatus != NC_NOERR)
#line 881
			return lstatus;
#line 881

#line 881
		lstatus = ncx_getn_schar_schar(&xp, nget, value);
#line 881
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 881
			status = lstatus;
#line 881

#line 881
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 881

#line 881
		remaining -= extent;
#line 881
		if(remaining == 0)
#line 881
			break; /* normal loop exit */
#line 881
		offset += extent;
#line 881
		value += nget;
#line 881
	}
#line 881

#line 881
	return status;
#line 881
}
#line 881

static int
#line 882
getNCvx_schar_short(const NC3_INFO* ncp, const NC_var *varp,
#line 882
		 const size_t *start, size_t nelems, short *value)
#line 882
{
#line 882
	off_t offset = NC_varoffset(ncp, varp, start);
#line 882
	size_t remaining = varp->xsz * nelems;
#line 882
	int status = NC_NOERR;
#line 882
	const void *xp;
#line 882

#line 882
	if(nelems == 0)
#line 882
		return NC_NOERR;
#line 882

#line 882
	assert(value != NULL);
#line 882

#line 882
	for(;;)
#line 882
	{
#line 882
		size_t extent = MIN(remaining, ncp->chunk);
#line 882
		size_t nget = ncx_howmany(varp->type, extent);
#line 882

#line 882
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 882
				 0, (void **)&xp);	/* cast away const */
#line 882
		if(lstatus != NC_NOERR)
#line 882
			return lstatus;
#line 882

#line 882
		lstatus = ncx_getn_schar_short(&xp, nget, value);
#line 882
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 882
			status = lstatus;
#line 882

#line 882
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 882

#line 882
		remaining -= extent;
#line 882
		if(remaining == 0)
#line 882
			break; /* normal loop exit */
#line 882
		offset += extent;
#line 882
		value += nget;
#line 882
	}
#line 882

#line 882
	return status;
#line 882
}
#line 882

static int
#line 883
getNCvx_schar_int(const NC3_INFO* ncp, const NC_var *varp,
#line 883
		 const size_t *start, size_t nelems, int *value)
#line 883
{
#line 883
	off_t offset = NC_varoffset(ncp, varp, start);
#line 883
	size_t remaining = varp->xsz * nelems;
#line 883
	int status = NC_NOERR;
#line 883
	const void *xp;
#line 883

#line 883
	if(nelems == 0)
#line 883
		return NC_NOERR;
#line 883

#line 883
	assert(value != NULL);
#line 883

#line 883
	for(;;)
#line 883
	{
#line 883
		size_t extent = MIN(remaining, ncp->chunk);
#line 883
		size_t nget = ncx_howmany(varp->type, extent);
#line 883

#line 883
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 883
				 0, (void **)&xp);	/* cast away const */
#line 883
		if(lstatus != NC_NOERR)
#line 883
			return lstatus;
#line 883

#line 883
		lstatus = ncx_getn_schar_int(&xp, nget, value);
#line 883
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 883
			status = lstatus;
#line 883

#line 883
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 883

#line 883
		remaining -= extent;
#line 883
		if(remaining == 0)
#line 883
			break; /* normal loop exit */
#line 883
		offset += extent;
#line 883
		value += nget;
#line 883
	}
#line 883

#line 883
	return status;
#line 883
}
#line 883

static int
#line 884
getNCvx_schar_float(const NC3_INFO* ncp, const NC_var *varp,
#line 884
		 const size_t *start, size_t nelems, float *value)
#line 884
{
#line 884
	off_t offset = NC_varoffset(ncp, varp, start);
#line 884
	size_t remaining = varp->xsz * nelems;
#line 884
	int status = NC_NOERR;
#line 884
	const void *xp;
#line 884

#line 884
	if(nelems == 0)
#line 884
		return NC_NOERR;
#line 884

#line 884
	assert(value != NULL);
#line 884

#line 884
	for(;;)
#line 884
	{
#line 884
		size_t extent = MIN(remaining, ncp->chunk);
#line 884
		size_t nget = ncx_howmany(varp->type, extent);
#line 884

#line 884
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 884
				 0, (void **)&xp);	/* cast away const */
#line 884
		if(lstatus != NC_NOERR)
#line 884
			return lstatus;
#line 884

#line 884
		lstatus = ncx_getn_schar_float(&xp, nget, value);
#line 884
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 884
			status = lstatus;
#line 884

#line 884
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 884

#line 884
		remaining -= extent;
#line 884
		if(remaining == 0)
#line 884
			break; /* normal loop exit */
#line 884
		offset += extent;
#line 884
		value += nget;
#line 884
	}
#line 884

#line 884
	return status;
#line 884
}
#line 884

static int
#line 885
getNCvx_schar_double(const NC3_INFO* ncp, const NC_var *varp,
#line 885
		 const size_t *start, size_t nelems, double *value)
#line 885
{
#line 885
	off_t offset = NC_varoffset(ncp, varp, start);
#line 885
	size_t remaining = varp->xsz * nelems;
#line 885
	int status = NC_NOERR;
#line 885
	const void *xp;
#line 885

#line 885
	if(nelems == 0)
#line 885
		return NC_NOERR;
#line 885

#line 885
	assert(value != NULL);
#line 885

#line 885
	for(;;)
#line 885
	{
#line 885
		size_t extent = MIN(remaining, ncp->chunk);
#line 885
		size_t nget = ncx_howmany(varp->type, extent);
#line 885

#line 885
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 885
				 0, (void **)&xp);	/* cast away const */
#line 885
		if(lstatus != NC_NOERR)
#line 885
			return lstatus;
#line 885

#line 885
		lstatus = ncx_getn_schar_double(&xp, nget, value);
#line 885
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 885
			status = lstatus;
#line 885

#line 885
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 885

#line 885
		remaining -= extent;
#line 885
		if(remaining == 0)
#line 885
			break; /* normal loop exit */
#line 885
		offset += extent;
#line 885
		value += nget;
#line 885
	}
#line 885

#line 885
	return status;
#line 885
}
#line 885

static int
#line 886
getNCvx_schar_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 886
		 const size_t *start, size_t nelems, longlong *value)
#line 886
{
#line 886
	off_t offset = NC_varoffset(ncp, varp, start);
#line 886
	size_t remaining = varp->xsz * nelems;
#line 886
	int status = NC_NOERR;
#line 886
	const void *xp;
#line 886

#line 886
	if(nelems == 0)
#line 886
		return NC_NOERR;
#line 886

#line 886
	assert(value != NULL);
#line 886

#line 886
	for(;;)
#line 886
	{
#line 886
		size_t extent = MIN(remaining, ncp->chunk);
#line 886
		size_t nget = ncx_howmany(varp->type, extent);
#line 886

#line 886
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 886
				 0, (void **)&xp);	/* cast away const */
#line 886
		if(lstatus != NC_NOERR)
#line 886
			return lstatus;
#line 886

#line 886
		lstatus = ncx_getn_schar_longlong(&xp, nget, value);
#line 886
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 886
			status = lstatus;
#line 886

#line 886
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 886

#line 886
		remaining -= extent;
#line 886
		if(remaining == 0)
#line 886
			break; /* normal loop exit */
#line 886
		offset += extent;
#line 886
		value += nget;
#line 886
	}
#line 886

#line 886
	return status;
#line 886
}
#line 886

static int
#line 887
getNCvx_schar_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 887
		 const size_t *start, size_t nelems, uint *value)
#line 887
{
#line 887
	off_t offset = NC_varoffset(ncp, varp, start);
#line 887
	size_t remaining = varp->xsz * nelems;
#line 887
	int status = NC_NOERR;
#line 887
	const void *xp;
#line 887

#line 887
	if(nelems == 0)
#line 887
		return NC_NOERR;
#line 887

#line 887
	assert(value != NULL);
#line 887

#line 887
	for(;;)
#line 887
	{
#line 887
		size_t extent = MIN(remaining, ncp->chunk);
#line 887
		size_t nget = ncx_howmany(varp->type, extent);
#line 887

#line 887
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 887
				 0, (void **)&xp);	/* cast away const */
#line 887
		if(lstatus != NC_NOERR)
#line 887
			return lstatus;
#line 887

#line 887
		lstatus = ncx_getn_schar_uint(&xp, nget, value);
#line 887
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 887
			status = lstatus;
#line 887

#line 887
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 887

#line 887
		remaining -= extent;
#line 887
		if(remaining == 0)
#line 887
			break; /* normal loop exit */
#line 887
		offset += extent;
#line 887
		value += nget;
#line 887
	}
#line 887

#line 887
	return status;
#line 887
}
#line 887

static int
#line 888
getNCvx_schar_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 888
		 const size_t *start, size_t nelems, ulonglong *value)
#line 888
{
#line 888
	off_t offset = NC_varoffset(ncp, varp, start);
#line 888
	size_t remaining = varp->xsz * nelems;
#line 888
	int status = NC_NOERR;
#line 888
	const void *xp;
#line 888

#line 888
	if(nelems == 0)
#line 888
		return NC_NOERR;
#line 888

#line 888
	assert(value != NULL);
#line 888

#line 888
	for(;;)
#line 888
	{
#line 888
		size_t extent = MIN(remaining, ncp->chunk);
#line 888
		size_t nget = ncx_howmany(varp->type, extent);
#line 888

#line 888
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 888
				 0, (void **)&xp);	/* cast away const */
#line 888
		if(lstatus != NC_NOERR)
#line 888
			return lstatus;
#line 888

#line 888
		lstatus = ncx_getn_schar_ulonglong(&xp, nget, value);
#line 888
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 888
			status = lstatus;
#line 888

#line 888
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 888

#line 888
		remaining -= extent;
#line 888
		if(remaining == 0)
#line 888
			break; /* normal loop exit */
#line 888
		offset += extent;
#line 888
		value += nget;
#line 888
	}
#line 888

#line 888
	return status;
#line 888
}
#line 888

static int
#line 889
getNCvx_schar_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 889
		 const size_t *start, size_t nelems, uchar *value)
#line 889
{
#line 889
	off_t offset = NC_varoffset(ncp, varp, start);
#line 889
	size_t remaining = varp->xsz * nelems;
#line 889
	int status = NC_NOERR;
#line 889
	const void *xp;
#line 889

#line 889
	if(nelems == 0)
#line 889
		return NC_NOERR;
#line 889

#line 889
	assert(value != NULL);
#line 889

#line 889
	for(;;)
#line 889
	{
#line 889
		size_t extent = MIN(remaining, ncp->chunk);
#line 889
		size_t nget = ncx_howmany(varp->type, extent);
#line 889

#line 889
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 889
				 0, (void **)&xp);	/* cast away const */
#line 889
		if(lstatus != NC_NOERR)
#line 889
			return lstatus;
#line 889

#line 889
		lstatus = ncx_getn_schar_uchar(&xp, nget, value);
#line 889
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 889
			status = lstatus;
#line 889

#line 889
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 889

#line 889
		remaining -= extent;
#line 889
		if(remaining == 0)
#line 889
			break; /* normal loop exit */
#line 889
		offset += extent;
#line 889
		value += nget;
#line 889
	}
#line 889

#line 889
	return status;
#line 889
}
#line 889

static int
#line 890
getNCvx_schar_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 890
		 const size_t *start, size_t nelems, ushort *value)
#line 890
{
#line 890
	off_t offset = NC_varoffset(ncp, varp, start);
#line 890
	size_t remaining = varp->xsz * nelems;
#line 890
	int status = NC_NOERR;
#line 890
	const void *xp;
#line 890

#line 890
	if(nelems == 0)
#line 890
		return NC_NOERR;
#line 890

#line 890
	assert(value != NULL);
#line 890

#line 890
	for(;;)
#line 890
	{
#line 890
		size_t extent = MIN(remaining, ncp->chunk);
#line 890
		size_t nget = ncx_howmany(varp->type, extent);
#line 890

#line 890
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 890
				 0, (void **)&xp);	/* cast away const */
#line 890
		if(lstatus != NC_NOERR)
#line 890
			return lstatus;
#line 890

#line 890
		lstatus = ncx_getn_schar_ushort(&xp, nget, value);
#line 890
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 890
			status = lstatus;
#line 890

#line 890
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 890

#line 890
		remaining -= extent;
#line 890
		if(remaining == 0)
#line 890
			break; /* normal loop exit */
#line 890
		offset += extent;
#line 890
		value += nget;
#line 890
	}
#line 890

#line 890
	return status;
#line 890
}
#line 890


static int
#line 892
getNCvx_short_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 892
		 const size_t *start, size_t nelems, schar *value)
#line 892
{
#line 892
	off_t offset = NC_varoffset(ncp, varp, start);
#line 892
	size_t remaining = varp->xsz * nelems;
#line 892
	int status = NC_NOERR;
#line 892
	const void *xp;
#line 892

#line 892
	if(nelems == 0)
#line 892
		return NC_NOERR;
#line 892

#line 892
	assert(value != NULL);
#line 892

#line 892
	for(;;)
#line 892
	{
#line 892
		size_t extent = MIN(remaining, ncp->chunk);
#line 892
		size_t nget = ncx_howmany(varp->type, extent);
#line 892

#line 892
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 892
				 0, (void **)&xp);	/* cast away const */
#line 892
		if(lstatus != NC_NOERR)
#line 892
			return lstatus;
#line 892

#line 892
		lstatus = ncx_getn_short_schar(&xp, nget, value);
#line 892
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 892
			status = lstatus;
#line 892

#line 892
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 892

#line 892
		remaining -= extent;
#line 892
		if(remaining == 0)
#line 892
			break; /* normal loop exit */
#line 892
		offset += extent;
#line 892
		value += nget;
#line 892
	}
#line 892

#line 892
	return status;
#line 892
}
#line 892

static int
#line 893
getNCvx_short_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 893
		 const size_t *start, size_t nelems, uchar *value)
#line 893
{
#line 893
	off_t offset = NC_varoffset(ncp, varp, start);
#line 893
	size_t remaining = varp->xsz * nelems;
#line 893
	int status = NC_NOERR;
#line 893
	const void *xp;
#line 893

#line 893
	if(nelems == 0)
#line 893
		return NC_NOERR;
#line 893

#line 893
	assert(value != NULL);
#line 893

#line 893
	for(;;)
#line 893
	{
#line 893
		size_t extent = MIN(remaining, ncp->chunk);
#line 893
		size_t nget = ncx_howmany(varp->type, extent);
#line 893

#line 893
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 893
				 0, (void **)&xp);	/* cast away const */
#line 893
		if(lstatus != NC_NOERR)
#line 893
			return lstatus;
#line 893

#line 893
		lstatus = ncx_getn_short_uchar(&xp, nget, value);
#line 893
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 893
			status = lstatus;
#line 893

#line 893
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 893

#line 893
		remaining -= extent;
#line 893
		if(remaining == 0)
#line 893
			break; /* normal loop exit */
#line 893
		offset += extent;
#line 893
		value += nget;
#line 893
	}
#line 893

#line 893
	return status;
#line 893
}
#line 893

static int
#line 894
getNCvx_short_short(const NC3_INFO* ncp, const NC_var *varp,
#line 894
		 const size_t *start, size_t nelems, short *value)
#line 894
{
#line 894
	off_t offset = NC_varoffset(ncp, varp, start);
#line 894
	size_t remaining = varp->xsz * nelems;
#line 894
	int status = NC_NOERR;
#line 894
	const void *xp;
#line 894

#line 894
	if(nelems == 0)
#line 894
		return NC_NOERR;
#line 894

#line 894
	assert(value != NULL);
#line 894

#line 894
	for(;;)
#line 894
	{
#line 894
		size_t extent = MIN(remaining, ncp->chunk);
#line 894
		size_t nget = ncx_howmany(varp->type, extent);
#line 894

#line 894
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 894
				 0, (void **)&xp);	/* cast away const */
#line 894
		if(lstatus != NC_NOERR)
#line 894
			return lstatus;
#line 894

#line 894
		lstatus = ncx_getn_short_short(&xp, nget, value);
#line 894
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 894
			status = lstatus;
#line 894

#line 894
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 894

#line 894
		remaining -= extent;
#line 894
		if(remaining == 0)
#line 894
			break; /* normal loop exit */
#line 894
		offset += extent;
#line 894
		value += nget;
#line 894
	}
#line 894

#line 894
	return status;
#line 894
}
#line 894

static int
#line 895
getNCvx_short_int(const NC3_INFO* ncp, const NC_var *varp,
#line 895
		 const size_t *start, size_t nelems, int *value)
#line 895
{
#line 895
	off_t offset = NC_varoffset(ncp, varp, start);
#line 895
	size_t remaining = varp->xsz * nelems;
#line 895
	int status = NC_NOERR;
#line 895
	const void *xp;
#line 895

#line 895
	if(nelems == 0)
#line 895
		return NC_NOERR;
#line 895

#line 895
	assert(value != NULL);
#line 895

#line 895
	for(;;)
#line 895
	{
#line 895
		size_t extent = MIN(remaining, ncp->chunk);
#line 895
		size_t nget = ncx_howmany(varp->type, extent);
#line 895

#line 895
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 895
				 0, (void **)&xp);	/* cast away const */
#line 895
		if(lstatus != NC_NOERR)
#line 895
			return lstatus;
#line 895

#line 895
		lstatus = ncx_getn_short_int(&xp, nget, value);
#line 895
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 895
			status = lstatus;
#line 895

#line 895
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 895

#line 895
		remaining -= extent;
#line 895
		if(remaining == 0)
#line 895
			break; /* normal loop exit */
#line 895
		offset += extent;
#line 895
		value += nget;
#line 895
	}
#line 895

#line 895
	return status;
#line 895
}
#line 895

static int
#line 896
getNCvx_short_float(const NC3_INFO* ncp, const NC_var *varp,
#line 896
		 const size_t *start, size_t nelems, float *value)
#line 896
{
#line 896
	off_t offset = NC_varoffset(ncp, varp, start);
#line 896
	size_t remaining = varp->xsz * nelems;
#line 896
	int status = NC_NOERR;
#line 896
	const void *xp;
#line 896

#line 896
	if(nelems == 0)
#line 896
		return NC_NOERR;
#line 896

#line 896
	assert(value != NULL);
#line 896

#line 896
	for(;;)
#line 896
	{
#line 896
		size_t extent = MIN(remaining, ncp->chunk);
#line 896
		size_t nget = ncx_howmany(varp->type, extent);
#line 896

#line 896
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 896
				 0, (void **)&xp);	/* cast away const */
#line 896
		if(lstatus != NC_NOERR)
#line 896
			return lstatus;
#line 896

#line 896
		lstatus = ncx_getn_short_float(&xp, nget, value);
#line 896
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 896
			status = lstatus;
#line 896

#line 896
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 896

#line 896
		remaining -= extent;
#line 896
		if(remaining == 0)
#line 896
			break; /* normal loop exit */
#line 896
		offset += extent;
#line 896
		value += nget;
#line 896
	}
#line 896

#line 896
	return status;
#line 896
}
#line 896

static int
#line 897
getNCvx_short_double(const NC3_INFO* ncp, const NC_var *varp,
#line 897
		 const size_t *start, size_t nelems, double *value)
#line 897
{
#line 897
	off_t offset = NC_varoffset(ncp, varp, start);
#line 897
	size_t remaining = varp->xsz * nelems;
#line 897
	int status = NC_NOERR;
#line 897
	const void *xp;
#line 897

#line 897
	if(nelems == 0)
#line 897
		return NC_NOERR;
#line 897

#line 897
	assert(value != NULL);
#line 897

#line 897
	for(;;)
#line 897
	{
#line 897
		size_t extent = MIN(remaining, ncp->chunk);
#line 897
		size_t nget = ncx_howmany(varp->type, extent);
#line 897

#line 897
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 897
				 0, (void **)&xp);	/* cast away const */
#line 897
		if(lstatus != NC_NOERR)
#line 897
			return lstatus;
#line 897

#line 897
		lstatus = ncx_getn_short_double(&xp, nget, value);
#line 897
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 897
			status = lstatus;
#line 897

#line 897
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 897

#line 897
		remaining -= extent;
#line 897
		if(remaining == 0)
#line 897
			break; /* normal loop exit */
#line 897
		offset += extent;
#line 897
		value += nget;
#line 897
	}
#line 897

#line 897
	return status;
#line 897
}
#line 897

static int
#line 898
getNCvx_short_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 898
		 const size_t *start, size_t nelems, longlong *value)
#line 898
{
#line 898
	off_t offset = NC_varoffset(ncp, varp, start);
#line 898
	size_t remaining = varp->xsz * nelems;
#line 898
	int status = NC_NOERR;
#line 898
	const void *xp;
#line 898

#line 898
	if(nelems == 0)
#line 898
		return NC_NOERR;
#line 898

#line 898
	assert(value != NULL);
#line 898

#line 898
	for(;;)
#line 898
	{
#line 898
		size_t extent = MIN(remaining, ncp->chunk);
#line 898
		size_t nget = ncx_howmany(varp->type, extent);
#line 898

#line 898
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 898
				 0, (void **)&xp);	/* cast away const */
#line 898
		if(lstatus != NC_NOERR)
#line 898
			return lstatus;
#line 898

#line 898
		lstatus = ncx_getn_short_longlong(&xp, nget, value);
#line 898
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 898
			status = lstatus;
#line 898

#line 898
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 898

#line 898
		remaining -= extent;
#line 898
		if(remaining == 0)
#line 898
			break; /* normal loop exit */
#line 898
		offset += extent;
#line 898
		value += nget;
#line 898
	}
#line 898

#line 898
	return status;
#line 898
}
#line 898

static int
#line 899
getNCvx_short_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 899
		 const size_t *start, size_t nelems, uint *value)
#line 899
{
#line 899
	off_t offset = NC_varoffset(ncp, varp, start);
#line 899
	size_t remaining = varp->xsz * nelems;
#line 899
	int status = NC_NOERR;
#line 899
	const void *xp;
#line 899

#line 899
	if(nelems == 0)
#line 899
		return NC_NOERR;
#line 899

#line 899
	assert(value != NULL);
#line 899

#line 899
	for(;;)
#line 899
	{
#line 899
		size_t extent = MIN(remaining, ncp->chunk);
#line 899
		size_t nget = ncx_howmany(varp->type, extent);
#line 899

#line 899
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 899
				 0, (void **)&xp);	/* cast away const */
#line 899
		if(lstatus != NC_NOERR)
#line 899
			return lstatus;
#line 899

#line 899
		lstatus = ncx_getn_short_uint(&xp, nget, value);
#line 899
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 899
			status = lstatus;
#line 899

#line 899
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 899

#line 899
		remaining -= extent;
#line 899
		if(remaining == 0)
#line 899
			break; /* normal loop exit */
#line 899
		offset += extent;
#line 899
		value += nget;
#line 899
	}
#line 899

#line 899
	return status;
#line 899
}
#line 899

static int
#line 900
getNCvx_short_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 900
		 const size_t *start, size_t nelems, ulonglong *value)
#line 900
{
#line 900
	off_t offset = NC_varoffset(ncp, varp, start);
#line 900
	size_t remaining = varp->xsz * nelems;
#line 900
	int status = NC_NOERR;
#line 900
	const void *xp;
#line 900

#line 900
	if(nelems == 0)
#line 900
		return NC_NOERR;
#line 900

#line 900
	assert(value != NULL);
#line 900

#line 900
	for(;;)
#line 900
	{
#line 900
		size_t extent = MIN(remaining, ncp->chunk);
#line 900
		size_t nget = ncx_howmany(varp->type, extent);
#line 900

#line 900
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 900
				 0, (void **)&xp);	/* cast away const */
#line 900
		if(lstatus != NC_NOERR)
#line 900
			return lstatus;
#line 900

#line 900
		lstatus = ncx_getn_short_ulonglong(&xp, nget, value);
#line 900
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 900
			status = lstatus;
#line 900

#line 900
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 900

#line 900
		remaining -= extent;
#line 900
		if(remaining == 0)
#line 900
			break; /* normal loop exit */
#line 900
		offset += extent;
#line 900
		value += nget;
#line 900
	}
#line 900

#line 900
	return status;
#line 900
}
#line 900

static int
#line 901
getNCvx_short_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 901
		 const size_t *start, size_t nelems, ushort *value)
#line 901
{
#line 901
	off_t offset = NC_varoffset(ncp, varp, start);
#line 901
	size_t remaining = varp->xsz * nelems;
#line 901
	int status = NC_NOERR;
#line 901
	const void *xp;
#line 901

#line 901
	if(nelems == 0)
#line 901
		return NC_NOERR;
#line 901

#line 901
	assert(value != NULL);
#line 901

#line 901
	for(;;)
#line 901
	{
#line 901
		size_t extent = MIN(remaining, ncp->chunk);
#line 901
		size_t nget = ncx_howmany(varp->type, extent);
#line 901

#line 901
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 901
				 0, (void **)&xp);	/* cast away const */
#line 901
		if(lstatus != NC_NOERR)
#line 901
			return lstatus;
#line 901

#line 901
		lstatus = ncx_getn_short_ushort(&xp, nget, value);
#line 901
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 901
			status = lstatus;
#line 901

#line 901
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 901

#line 901
		remaining -= extent;
#line 901
		if(remaining == 0)
#line 901
			break; /* normal loop exit */
#line 901
		offset += extent;
#line 901
		value += nget;
#line 901
	}
#line 901

#line 901
	return status;
#line 901
}
#line 901


static int
#line 903
getNCvx_int_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 903
		 const size_t *start, size_t nelems, schar *value)
#line 903
{
#line 903
	off_t offset = NC_varoffset(ncp, varp, start);
#line 903
	size_t remaining = varp->xsz * nelems;
#line 903
	int status = NC_NOERR;
#line 903
	const void *xp;
#line 903

#line 903
	if(nelems == 0)
#line 903
		return NC_NOERR;
#line 903

#line 903
	assert(value != NULL);
#line 903

#line 903
	for(;;)
#line 903
	{
#line 903
		size_t extent = MIN(remaining, ncp->chunk);
#line 903
		size_t nget = ncx_howmany(varp->type, extent);
#line 903

#line 903
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 903
				 0, (void **)&xp);	/* cast away const */
#line 903
		if(lstatus != NC_NOERR)
#line 903
			return lstatus;
#line 903

#line 903
		lstatus = ncx_getn_int_schar(&xp, nget, value);
#line 903
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 903
			status = lstatus;
#line 903

#line 903
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 903

#line 903
		remaining -= extent;
#line 903
		if(remaining == 0)
#line 903
			break; /* normal loop exit */
#line 903
		offset += extent;
#line 903
		value += nget;
#line 903
	}
#line 903

#line 903
	return status;
#line 903
}
#line 903

static int
#line 904
getNCvx_int_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 904
		 const size_t *start, size_t nelems, uchar *value)
#line 904
{
#line 904
	off_t offset = NC_varoffset(ncp, varp, start);
#line 904
	size_t remaining = varp->xsz * nelems;
#line 904
	int status = NC_NOERR;
#line 904
	const void *xp;
#line 904

#line 904
	if(nelems == 0)
#line 904
		return NC_NOERR;
#line 904

#line 904
	assert(value != NULL);
#line 904

#line 904
	for(;;)
#line 904
	{
#line 904
		size_t extent = MIN(remaining, ncp->chunk);
#line 904
		size_t nget = ncx_howmany(varp->type, extent);
#line 904

#line 904
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 904
				 0, (void **)&xp);	/* cast away const */
#line 904
		if(lstatus != NC_NOERR)
#line 904
			return lstatus;
#line 904

#line 904
		lstatus = ncx_getn_int_uchar(&xp, nget, value);
#line 904
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 904
			status = lstatus;
#line 904

#line 904
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 904

#line 904
		remaining -= extent;
#line 904
		if(remaining == 0)
#line 904
			break; /* normal loop exit */
#line 904
		offset += extent;
#line 904
		value += nget;
#line 904
	}
#line 904

#line 904
	return status;
#line 904
}
#line 904

static int
#line 905
getNCvx_int_short(const NC3_INFO* ncp, const NC_var *varp,
#line 905
		 const size_t *start, size_t nelems, short *value)
#line 905
{
#line 905
	off_t offset = NC_varoffset(ncp, varp, start);
#line 905
	size_t remaining = varp->xsz * nelems;
#line 905
	int status = NC_NOERR;
#line 905
	const void *xp;
#line 905

#line 905
	if(nelems == 0)
#line 905
		return NC_NOERR;
#line 905

#line 905
	assert(value != NULL);
#line 905

#line 905
	for(;;)
#line 905
	{
#line 905
		size_t extent = MIN(remaining, ncp->chunk);
#line 905
		size_t nget = ncx_howmany(varp->type, extent);
#line 905

#line 905
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 905
				 0, (void **)&xp);	/* cast away const */
#line 905
		if(lstatus != NC_NOERR)
#line 905
			return lstatus;
#line 905

#line 905
		lstatus = ncx_getn_int_short(&xp, nget, value);
#line 905
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 905
			status = lstatus;
#line 905

#line 905
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 905

#line 905
		remaining -= extent;
#line 905
		if(remaining == 0)
#line 905
			break; /* normal loop exit */
#line 905
		offset += extent;
#line 905
		value += nget;
#line 905
	}
#line 905

#line 905
	return status;
#line 905
}
#line 905

static int
#line 906
getNCvx_int_int(const NC3_INFO* ncp, const NC_var *varp,
#line 906
		 const size_t *start, size_t nelems, int *value)
#line 906
{
#line 906
	off_t offset = NC_varoffset(ncp, varp, start);
#line 906
	size_t remaining = varp->xsz * nelems;
#line 906
	int status = NC_NOERR;
#line 906
	const void *xp;
#line 906

#line 906
	if(nelems == 0)
#line 906
		return NC_NOERR;
#line 906

#line 906
	assert(value != NULL);
#line 906

#line 906
	for(;;)
#line 906
	{
#line 906
		size_t extent = MIN(remaining, ncp->chunk);
#line 906
		size_t nget = ncx_howmany(varp->type, extent);
#line 906

#line 906
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 906
				 0, (void **)&xp);	/* cast away const */
#line 906
		if(lstatus != NC_NOERR)
#line 906
			return lstatus;
#line 906

#line 906
		lstatus = ncx_getn_int_int(&xp, nget, value);
#line 906
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 906
			status = lstatus;
#line 906

#line 906
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 906

#line 906
		remaining -= extent;
#line 906
		if(remaining == 0)
#line 906
			break; /* normal loop exit */
#line 906
		offset += extent;
#line 906
		value += nget;
#line 906
	}
#line 906

#line 906
	return status;
#line 906
}
#line 906

static int
#line 907
getNCvx_int_float(const NC3_INFO* ncp, const NC_var *varp,
#line 907
		 const size_t *start, size_t nelems, float *value)
#line 907
{
#line 907
	off_t offset = NC_varoffset(ncp, varp, start);
#line 907
	size_t remaining = varp->xsz * nelems;
#line 907
	int status = NC_NOERR;
#line 907
	const void *xp;
#line 907

#line 907
	if(nelems == 0)
#line 907
		return NC_NOERR;
#line 907

#line 907
	assert(value != NULL);
#line 907

#line 907
	for(;;)
#line 907
	{
#line 907
		size_t extent = MIN(remaining, ncp->chunk);
#line 907
		size_t nget = ncx_howmany(varp->type, extent);
#line 907

#line 907
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 907
				 0, (void **)&xp);	/* cast away const */
#line 907
		if(lstatus != NC_NOERR)
#line 907
			return lstatus;
#line 907

#line 907
		lstatus = ncx_getn_int_float(&xp, nget, value);
#line 907
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 907
			status = lstatus;
#line 907

#line 907
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 907

#line 907
		remaining -= extent;
#line 907
		if(remaining == 0)
#line 907
			break; /* normal loop exit */
#line 907
		offset += extent;
#line 907
		value += nget;
#line 907
	}
#line 907

#line 907
	return status;
#line 907
}
#line 907

static int
#line 908
getNCvx_int_double(const NC3_INFO* ncp, const NC_var *varp,
#line 908
		 const size_t *start, size_t nelems, double *value)
#line 908
{
#line 908
	off_t offset = NC_varoffset(ncp, varp, start);
#line 908
	size_t remaining = varp->xsz * nelems;
#line 908
	int status = NC_NOERR;
#line 908
	const void *xp;
#line 908

#line 908
	if(nelems == 0)
#line 908
		return NC_NOERR;
#line 908

#line 908
	assert(value != NULL);
#line 908

#line 908
	for(;;)
#line 908
	{
#line 908
		size_t extent = MIN(remaining, ncp->chunk);
#line 908
		size_t nget = ncx_howmany(varp->type, extent);
#line 908

#line 908
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 908
				 0, (void **)&xp);	/* cast away const */
#line 908
		if(lstatus != NC_NOERR)
#line 908
			return lstatus;
#line 908

#line 908
		lstatus = ncx_getn_int_double(&xp, nget, value);
#line 908
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 908
			status = lstatus;
#line 908

#line 908
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 908

#line 908
		remaining -= extent;
#line 908
		if(remaining == 0)
#line 908
			break; /* normal loop exit */
#line 908
		offset += extent;
#line 908
		value += nget;
#line 908
	}
#line 908

#line 908
	return status;
#line 908
}
#line 908

static int
#line 909
getNCvx_int_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 909
		 const size_t *start, size_t nelems, longlong *value)
#line 909
{
#line 909
	off_t offset = NC_varoffset(ncp, varp, start);
#line 909
	size_t remaining = varp->xsz * nelems;
#line 909
	int status = NC_NOERR;
#line 909
	const void *xp;
#line 909

#line 909
	if(nelems == 0)
#line 909
		return NC_NOERR;
#line 909

#line 909
	assert(value != NULL);
#line 909

#line 909
	for(;;)
#line 909
	{
#line 909
		size_t extent = MIN(remaining, ncp->chunk);
#line 909
		size_t nget = ncx_howmany(varp->type, extent);
#line 909

#line 909
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 909
				 0, (void **)&xp);	/* cast away const */
#line 909
		if(lstatus != NC_NOERR)
#line 909
			return lstatus;
#line 909

#line 909
		lstatus = ncx_getn_int_longlong(&xp, nget, value);
#line 909
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 909
			status = lstatus;
#line 909

#line 909
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 909

#line 909
		remaining -= extent;
#line 909
		if(remaining == 0)
#line 909
			break; /* normal loop exit */
#line 909
		offset += extent;
#line 909
		value += nget;
#line 909
	}
#line 909

#line 909
	return status;
#line 909
}
#line 909

static int
#line 910
getNCvx_int_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 910
		 const size_t *start, size_t nelems, uint *value)
#line 910
{
#line 910
	off_t offset = NC_varoffset(ncp, varp, start);
#line 910
	size_t remaining = varp->xsz * nelems;
#line 910
	int status = NC_NOERR;
#line 910
	const void *xp;
#line 910

#line 910
	if(nelems == 0)
#line 910
		return NC_NOERR;
#line 910

#line 910
	assert(value != NULL);
#line 910

#line 910
	for(;;)
#line 910
	{
#line 910
		size_t extent = MIN(remaining, ncp->chunk);
#line 910
		size_t nget = ncx_howmany(varp->type, extent);
#line 910

#line 910
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 910
				 0, (void **)&xp);	/* cast away const */
#line 910
		if(lstatus != NC_NOERR)
#line 910
			return lstatus;
#line 910

#line 910
		lstatus = ncx_getn_int_uint(&xp, nget, value);
#line 910
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 910
			status = lstatus;
#line 910

#line 910
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 910

#line 910
		remaining -= extent;
#line 910
		if(remaining == 0)
#line 910
			break; /* normal loop exit */
#line 910
		offset += extent;
#line 910
		value += nget;
#line 910
	}
#line 910

#line 910
	return status;
#line 910
}
#line 910

static int
#line 911
getNCvx_int_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 911
		 const size_t *start, size_t nelems, ulonglong *value)
#line 911
{
#line 911
	off_t offset = NC_varoffset(ncp, varp, start);
#line 911
	size_t remaining = varp->xsz * nelems;
#line 911
	int status = NC_NOERR;
#line 911
	const void *xp;
#line 911

#line 911
	if(nelems == 0)
#line 911
		return NC_NOERR;
#line 911

#line 911
	assert(value != NULL);
#line 911

#line 911
	for(;;)
#line 911
	{
#line 911
		size_t extent = MIN(remaining, ncp->chunk);
#line 911
		size_t nget = ncx_howmany(varp->type, extent);
#line 911

#line 911
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 911
				 0, (void **)&xp);	/* cast away const */
#line 911
		if(lstatus != NC_NOERR)
#line 911
			return lstatus;
#line 911

#line 911
		lstatus = ncx_getn_int_ulonglong(&xp, nget, value);
#line 911
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 911
			status = lstatus;
#line 911

#line 911
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 911

#line 911
		remaining -= extent;
#line 911
		if(remaining == 0)
#line 911
			break; /* normal loop exit */
#line 911
		offset += extent;
#line 911
		value += nget;
#line 911
	}
#line 911

#line 911
	return status;
#line 911
}
#line 911

static int
#line 912
getNCvx_int_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 912
		 const size_t *start, size_t nelems, ushort *value)
#line 912
{
#line 912
	off_t offset = NC_varoffset(ncp, varp, start);
#line 912
	size_t remaining = varp->xsz * nelems;
#line 912
	int status = NC_NOERR;
#line 912
	const void *xp;
#line 912

#line 912
	if(nelems == 0)
#line 912
		return NC_NOERR;
#line 912

#line 912
	assert(value != NULL);
#line 912

#line 912
	for(;;)
#line 912
	{
#line 912
		size_t extent = MIN(remaining, ncp->chunk);
#line 912
		size_t nget = ncx_howmany(varp->type, extent);
#line 912

#line 912
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 912
				 0, (void **)&xp);	/* cast away const */
#line 912
		if(lstatus != NC_NOERR)
#line 912
			return lstatus;
#line 912

#line 912
		lstatus = ncx_getn_int_ushort(&xp, nget, value);
#line 912
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 912
			status = lstatus;
#line 912

#line 912
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 912

#line 912
		remaining -= extent;
#line 912
		if(remaining == 0)
#line 912
			break; /* normal loop exit */
#line 912
		offset += extent;
#line 912
		value += nget;
#line 912
	}
#line 912

#line 912
	return status;
#line 912
}
#line 912


static int
#line 914
getNCvx_float_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 914
		 const size_t *start, size_t nelems, schar *value)
#line 914
{
#line 914
	off_t offset = NC_varoffset(ncp, varp, start);
#line 914
	size_t remaining = varp->xsz * nelems;
#line 914
	int status = NC_NOERR;
#line 914
	const void *xp;
#line 914

#line 914
	if(nelems == 0)
#line 914
		return NC_NOERR;
#line 914

#line 914
	assert(value != NULL);
#line 914

#line 914
	for(;;)
#line 914
	{
#line 914
		size_t extent = MIN(remaining, ncp->chunk);
#line 914
		size_t nget = ncx_howmany(varp->type, extent);
#line 914

#line 914
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 914
				 0, (void **)&xp);	/* cast away const */
#line 914
		if(lstatus != NC_NOERR)
#line 914
			return lstatus;
#line 914

#line 914
		lstatus = ncx_getn_float_schar(&xp, nget, value);
#line 914
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 914
			status = lstatus;
#line 914

#line 914
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 914

#line 914
		remaining -= extent;
#line 914
		if(remaining == 0)
#line 914
			break; /* normal loop exit */
#line 914
		offset += extent;
#line 914
		value += nget;
#line 914
	}
#line 914

#line 914
	return status;
#line 914
}
#line 914

static int
#line 915
getNCvx_float_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 915
		 const size_t *start, size_t nelems, uchar *value)
#line 915
{
#line 915
	off_t offset = NC_varoffset(ncp, varp, start);
#line 915
	size_t remaining = varp->xsz * nelems;
#line 915
	int status = NC_NOERR;
#line 915
	const void *xp;
#line 915

#line 915
	if(nelems == 0)
#line 915
		return NC_NOERR;
#line 915

#line 915
	assert(value != NULL);
#line 915

#line 915
	for(;;)
#line 915
	{
#line 915
		size_t extent = MIN(remaining, ncp->chunk);
#line 915
		size_t nget = ncx_howmany(varp->type, extent);
#line 915

#line 915
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 915
				 0, (void **)&xp);	/* cast away const */
#line 915
		if(lstatus != NC_NOERR)
#line 915
			return lstatus;
#line 915

#line 915
		lstatus = ncx_getn_float_uchar(&xp, nget, value);
#line 915
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 915
			status = lstatus;
#line 915

#line 915
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 915

#line 915
		remaining -= extent;
#line 915
		if(remaining == 0)
#line 915
			break; /* normal loop exit */
#line 915
		offset += extent;
#line 915
		value += nget;
#line 915
	}
#line 915

#line 915
	return status;
#line 915
}
#line 915

static int
#line 916
getNCvx_float_short(const NC3_INFO* ncp, const NC_var *varp,
#line 916
		 const size_t *start, size_t nelems, short *value)
#line 916
{
#line 916
	off_t offset = NC_varoffset(ncp, varp, start);
#line 916
	size_t remaining = varp->xsz * nelems;
#line 916
	int status = NC_NOERR;
#line 916
	const void *xp;
#line 916

#line 916
	if(nelems == 0)
#line 916
		return NC_NOERR;
#line 916

#line 916
	assert(value != NULL);
#line 916

#line 916
	for(;;)
#line 916
	{
#line 916
		size_t extent = MIN(remaining, ncp->chunk);
#line 916
		size_t nget = ncx_howmany(varp->type, extent);
#line 916

#line 916
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 916
				 0, (void **)&xp);	/* cast away const */
#line 916
		if(lstatus != NC_NOERR)
#line 916
			return lstatus;
#line 916

#line 916
		lstatus = ncx_getn_float_short(&xp, nget, value);
#line 916
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 916
			status = lstatus;
#line 916

#line 916
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 916

#line 916
		remaining -= extent;
#line 916
		if(remaining == 0)
#line 916
			break; /* normal loop exit */
#line 916
		offset += extent;
#line 916
		value += nget;
#line 916
	}
#line 916

#line 916
	return status;
#line 916
}
#line 916

static int
#line 917
getNCvx_float_int(const NC3_INFO* ncp, const NC_var *varp,
#line 917
		 const size_t *start, size_t nelems, int *value)
#line 917
{
#line 917
	off_t offset = NC_varoffset(ncp, varp, start);
#line 917
	size_t remaining = varp->xsz * nelems;
#line 917
	int status = NC_NOERR;
#line 917
	const void *xp;
#line 917

#line 917
	if(nelems == 0)
#line 917
		return NC_NOERR;
#line 917

#line 917
	assert(value != NULL);
#line 917

#line 917
	for(;;)
#line 917
	{
#line 917
		size_t extent = MIN(remaining, ncp->chunk);
#line 917
		size_t nget = ncx_howmany(varp->type, extent);
#line 917

#line 917
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 917
				 0, (void **)&xp);	/* cast away const */
#line 917
		if(lstatus != NC_NOERR)
#line 917
			return lstatus;
#line 917

#line 917
		lstatus = ncx_getn_float_int(&xp, nget, value);
#line 917
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 917
			status = lstatus;
#line 917

#line 917
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 917

#line 917
		remaining -= extent;
#line 917
		if(remaining == 0)
#line 917
			break; /* normal loop exit */
#line 917
		offset += extent;
#line 917
		value += nget;
#line 917
	}
#line 917

#line 917
	return status;
#line 917
}
#line 917

static int
#line 918
getNCvx_float_float(const NC3_INFO* ncp, const NC_var *varp,
#line 918
		 const size_t *start, size_t nelems, float *value)
#line 918
{
#line 918
	off_t offset = NC_varoffset(ncp, varp, start);
#line 918
	size_t remaining = varp->xsz * nelems;
#line 918
	int status = NC_NOERR;
#line 918
	const void *xp;
#line 918

#line 918
	if(nelems == 0)
#line 918
		return NC_NOERR;
#line 918

#line 918
	assert(value != NULL);
#line 918

#line 918
	for(;;)
#line 918
	{
#line 918
		size_t extent = MIN(remaining, ncp->chunk);
#line 918
		size_t nget = ncx_howmany(varp->type, extent);
#line 918

#line 918
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 918
				 0, (void **)&xp);	/* cast away const */
#line 918
		if(lstatus != NC_NOERR)
#line 918
			return lstatus;
#line 918

#line 918
		lstatus = ncx_getn_float_float(&xp, nget, value);
#line 918
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 918
			status = lstatus;
#line 918

#line 918
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 918

#line 918
		remaining -= extent;
#line 918
		if(remaining == 0)
#line 918
			break; /* normal loop exit */
#line 918
		offset += extent;
#line 918
		value += nget;
#line 918
	}
#line 918

#line 918
	return status;
#line 918
}
#line 918

static int
#line 919
getNCvx_float_double(const NC3_INFO* ncp, const NC_var *varp,
#line 919
		 const size_t *start, size_t nelems, double *value)
#line 919
{
#line 919
	off_t offset = NC_varoffset(ncp, varp, start);
#line 919
	size_t remaining = varp->xsz * nelems;
#line 919
	int status = NC_NOERR;
#line 919
	const void *xp;
#line 919

#line 919
	if(nelems == 0)
#line 919
		return NC_NOERR;
#line 919

#line 919
	assert(value != NULL);
#line 919

#line 919
	for(;;)
#line 919
	{
#line 919
		size_t extent = MIN(remaining, ncp->chunk);
#line 919
		size_t nget = ncx_howmany(varp->type, extent);
#line 919

#line 919
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 919
				 0, (void **)&xp);	/* cast away const */
#line 919
		if(lstatus != NC_NOERR)
#line 919
			return lstatus;
#line 919

#line 919
		lstatus = ncx_getn_float_double(&xp, nget, value);
#line 919
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 919
			status = lstatus;
#line 919

#line 919
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 919

#line 919
		remaining -= extent;
#line 919
		if(remaining == 0)
#line 919
			break; /* normal loop exit */
#line 919
		offset += extent;
#line 919
		value += nget;
#line 919
	}
#line 919

#line 919
	return status;
#line 919
}
#line 919

static int
#line 920
getNCvx_float_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 920
		 const size_t *start, size_t nelems, longlong *value)
#line 920
{
#line 920
	off_t offset = NC_varoffset(ncp, varp, start);
#line 920
	size_t remaining = varp->xsz * nelems;
#line 920
	int status = NC_NOERR;
#line 920
	const void *xp;
#line 920

#line 920
	if(nelems == 0)
#line 920
		return NC_NOERR;
#line 920

#line 920
	assert(value != NULL);
#line 920

#line 920
	for(;;)
#line 920
	{
#line 920
		size_t extent = MIN(remaining, ncp->chunk);
#line 920
		size_t nget = ncx_howmany(varp->type, extent);
#line 920

#line 920
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 920
				 0, (void **)&xp);	/* cast away const */
#line 920
		if(lstatus != NC_NOERR)
#line 920
			return lstatus;
#line 920

#line 920
		lstatus = ncx_getn_float_longlong(&xp, nget, value);
#line 920
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 920
			status = lstatus;
#line 920

#line 920
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 920

#line 920
		remaining -= extent;
#line 920
		if(remaining == 0)
#line 920
			break; /* normal loop exit */
#line 920
		offset += extent;
#line 920
		value += nget;
#line 920
	}
#line 920

#line 920
	return status;
#line 920
}
#line 920

static int
#line 921
getNCvx_float_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 921
		 const size_t *start, size_t nelems, uint *value)
#line 921
{
#line 921
	off_t offset = NC_varoffset(ncp, varp, start);
#line 921
	size_t remaining = varp->xsz * nelems;
#line 921
	int status = NC_NOERR;
#line 921
	const void *xp;
#line 921

#line 921
	if(nelems == 0)
#line 921
		return NC_NOERR;
#line 921

#line 921
	assert(value != NULL);
#line 921

#line 921
	for(;;)
#line 921
	{
#line 921
		size_t extent = MIN(remaining, ncp->chunk);
#line 921
		size_t nget = ncx_howmany(varp->type, extent);
#line 921

#line 921
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 921
				 0, (void **)&xp);	/* cast away const */
#line 921
		if(lstatus != NC_NOERR)
#line 921
			return lstatus;
#line 921

#line 921
		lstatus = ncx_getn_float_uint(&xp, nget, value);
#line 921
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 921
			status = lstatus;
#line 921

#line 921
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 921

#line 921
		remaining -= extent;
#line 921
		if(remaining == 0)
#line 921
			break; /* normal loop exit */
#line 921
		offset += extent;
#line 921
		value += nget;
#line 921
	}
#line 921

#line 921
	return status;
#line 921
}
#line 921

static int
#line 922
getNCvx_float_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 922
		 const size_t *start, size_t nelems, ulonglong *value)
#line 922
{
#line 922
	off_t offset = NC_varoffset(ncp, varp, start);
#line 922
	size_t remaining = varp->xsz * nelems;
#line 922
	int status = NC_NOERR;
#line 922
	const void *xp;
#line 922

#line 922
	if(nelems == 0)
#line 922
		return NC_NOERR;
#line 922

#line 922
	assert(value != NULL);
#line 922

#line 922
	for(;;)
#line 922
	{
#line 922
		size_t extent = MIN(remaining, ncp->chunk);
#line 922
		size_t nget = ncx_howmany(varp->type, extent);
#line 922

#line 922
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 922
				 0, (void **)&xp);	/* cast away const */
#line 922
		if(lstatus != NC_NOERR)
#line 922
			return lstatus;
#line 922

#line 922
		lstatus = ncx_getn_float_ulonglong(&xp, nget, value);
#line 922
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 922
			status = lstatus;
#line 922

#line 922
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 922

#line 922
		remaining -= extent;
#line 922
		if(remaining == 0)
#line 922
			break; /* normal loop exit */
#line 922
		offset += extent;
#line 922
		value += nget;
#line 922
	}
#line 922

#line 922
	return status;
#line 922
}
#line 922

static int
#line 923
getNCvx_float_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 923
		 const size_t *start, size_t nelems, ushort *value)
#line 923
{
#line 923
	off_t offset = NC_varoffset(ncp, varp, start);
#line 923
	size_t remaining = varp->xsz * nelems;
#line 923
	int status = NC_NOERR;
#line 923
	const void *xp;
#line 923

#line 923
	if(nelems == 0)
#line 923
		return NC_NOERR;
#line 923

#line 923
	assert(value != NULL);
#line 923

#line 923
	for(;;)
#line 923
	{
#line 923
		size_t extent = MIN(remaining, ncp->chunk);
#line 923
		size_t nget = ncx_howmany(varp->type, extent);
#line 923

#line 923
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 923
				 0, (void **)&xp);	/* cast away const */
#line 923
		if(lstatus != NC_NOERR)
#line 923
			return lstatus;
#line 923

#line 923
		lstatus = ncx_getn_float_ushort(&xp, nget, value);
#line 923
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 923
			status = lstatus;
#line 923

#line 923
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 923

#line 923
		remaining -= extent;
#line 923
		if(remaining == 0)
#line 923
			break; /* normal loop exit */
#line 923
		offset += extent;
#line 923
		value += nget;
#line 923
	}
#line 923

#line 923
	return status;
#line 923
}
#line 923


static int
#line 925
getNCvx_double_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 925
		 const size_t *start, size_t nelems, schar *value)
#line 925
{
#line 925
	off_t offset = NC_varoffset(ncp, varp, start);
#line 925
	size_t remaining = varp->xsz * nelems;
#line 925
	int status = NC_NOERR;
#line 925
	const void *xp;
#line 925

#line 925
	if(nelems == 0)
#line 925
		return NC_NOERR;
#line 925

#line 925
	assert(value != NULL);
#line 925

#line 925
	for(;;)
#line 925
	{
#line 925
		size_t extent = MIN(remaining, ncp->chunk);
#line 925
		size_t nget = ncx_howmany(varp->type, extent);
#line 925

#line 925
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 925
				 0, (void **)&xp);	/* cast away const */
#line 925
		if(lstatus != NC_NOERR)
#line 925
			return lstatus;
#line 925

#line 925
		lstatus = ncx_getn_double_schar(&xp, nget, value);
#line 925
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 925
			status = lstatus;
#line 925

#line 925
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 925

#line 925
		remaining -= extent;
#line 925
		if(remaining == 0)
#line 925
			break; /* normal loop exit */
#line 925
		offset += extent;
#line 925
		value += nget;
#line 925
	}
#line 925

#line 925
	return status;
#line 925
}
#line 925

static int
#line 926
getNCvx_double_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 926
		 const size_t *start, size_t nelems, uchar *value)
#line 926
{
#line 926
	off_t offset = NC_varoffset(ncp, varp, start);
#line 926
	size_t remaining = varp->xsz * nelems;
#line 926
	int status = NC_NOERR;
#line 926
	const void *xp;
#line 926

#line 926
	if(nelems == 0)
#line 926
		return NC_NOERR;
#line 926

#line 926
	assert(value != NULL);
#line 926

#line 926
	for(;;)
#line 926
	{
#line 926
		size_t extent = MIN(remaining, ncp->chunk);
#line 926
		size_t nget = ncx_howmany(varp->type, extent);
#line 926

#line 926
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 926
				 0, (void **)&xp);	/* cast away const */
#line 926
		if(lstatus != NC_NOERR)
#line 926
			return lstatus;
#line 926

#line 926
		lstatus = ncx_getn_double_uchar(&xp, nget, value);
#line 926
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 926
			status = lstatus;
#line 926

#line 926
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 926

#line 926
		remaining -= extent;
#line 926
		if(remaining == 0)
#line 926
			break; /* normal loop exit */
#line 926
		offset += extent;
#line 926
		value += nget;
#line 926
	}
#line 926

#line 926
	return status;
#line 926
}
#line 926

static int
#line 927
getNCvx_double_short(const NC3_INFO* ncp, const NC_var *varp,
#line 927
		 const size_t *start, size_t nelems, short *value)
#line 927
{
#line 927
	off_t offset = NC_varoffset(ncp, varp, start);
#line 927
	size_t remaining = varp->xsz * nelems;
#line 927
	int status = NC_NOERR;
#line 927
	const void *xp;
#line 927

#line 927
	if(nelems == 0)
#line 927
		return NC_NOERR;
#line 927

#line 927
	assert(value != NULL);
#line 927

#line 927
	for(;;)
#line 927
	{
#line 927
		size_t extent = MIN(remaining, ncp->chunk);
#line 927
		size_t nget = ncx_howmany(varp->type, extent);
#line 927

#line 927
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 927
				 0, (void **)&xp);	/* cast away const */
#line 927
		if(lstatus != NC_NOERR)
#line 927
			return lstatus;
#line 927

#line 927
		lstatus = ncx_getn_double_short(&xp, nget, value);
#line 927
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 927
			status = lstatus;
#line 927

#line 927
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 927

#line 927
		remaining -= extent;
#line 927
		if(remaining == 0)
#line 927
			break; /* normal loop exit */
#line 927
		offset += extent;
#line 927
		value += nget;
#line 927
	}
#line 927

#line 927
	return status;
#line 927
}
#line 927

static int
#line 928
getNCvx_double_int(const NC3_INFO* ncp, const NC_var *varp,
#line 928
		 const size_t *start, size_t nelems, int *value)
#line 928
{
#line 928
	off_t offset = NC_varoffset(ncp, varp, start);
#line 928
	size_t remaining = varp->xsz * nelems;
#line 928
	int status = NC_NOERR;
#line 928
	const void *xp;
#line 928

#line 928
	if(nelems == 0)
#line 928
		return NC_NOERR;
#line 928

#line 928
	assert(value != NULL);
#line 928

#line 928
	for(;;)
#line 928
	{
#line 928
		size_t extent = MIN(remaining, ncp->chunk);
#line 928
		size_t nget = ncx_howmany(varp->type, extent);
#line 928

#line 928
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 928
				 0, (void **)&xp);	/* cast away const */
#line 928
		if(lstatus != NC_NOERR)
#line 928
			return lstatus;
#line 928

#line 928
		lstatus = ncx_getn_double_int(&xp, nget, value);
#line 928
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 928
			status = lstatus;
#line 928

#line 928
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 928

#line 928
		remaining -= extent;
#line 928
		if(remaining == 0)
#line 928
			break; /* normal loop exit */
#line 928
		offset += extent;
#line 928
		value += nget;
#line 928
	}
#line 928

#line 928
	return status;
#line 928
}
#line 928

static int
#line 929
getNCvx_double_float(const NC3_INFO* ncp, const NC_var *varp,
#line 929
		 const size_t *start, size_t nelems, float *value)
#line 929
{
#line 929
	off_t offset = NC_varoffset(ncp, varp, start);
#line 929
	size_t remaining = varp->xsz * nelems;
#line 929
	int status = NC_NOERR;
#line 929
	const void *xp;
#line 929

#line 929
	if(nelems == 0)
#line 929
		return NC_NOERR;
#line 929

#line 929
	assert(value != NULL);
#line 929

#line 929
	for(;;)
#line 929
	{
#line 929
		size_t extent = MIN(remaining, ncp->chunk);
#line 929
		size_t nget = ncx_howmany(varp->type, extent);
#line 929

#line 929
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 929
				 0, (void **)&xp);	/* cast away const */
#line 929
		if(lstatus != NC_NOERR)
#line 929
			return lstatus;
#line 929

#line 929
		lstatus = ncx_getn_double_float(&xp, nget, value);
#line 929
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 929
			status = lstatus;
#line 929

#line 929
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 929

#line 929
		remaining -= extent;
#line 929
		if(remaining == 0)
#line 929
			break; /* normal loop exit */
#line 929
		offset += extent;
#line 929
		value += nget;
#line 929
	}
#line 929

#line 929
	return status;
#line 929
}
#line 929

static int
#line 930
getNCvx_double_double(const NC3_INFO* ncp, const NC_var *varp,
#line 930
		 const size_t *start, size_t nelems, double *value)
#line 930
{
#line 930
	off_t offset = NC_varoffset(ncp, varp, start);
#line 930
	size_t remaining = varp->xsz * nelems;
#line 930
	int status = NC_NOERR;
#line 930
	const void *xp;
#line 930

#line 930
	if(nelems == 0)
#line 930
		return NC_NOERR;
#line 930

#line 930
	assert(value != NULL);
#line 930

#line 930
	for(;;)
#line 930
	{
#line 930
		size_t extent = MIN(remaining, ncp->chunk);
#line 930
		size_t nget = ncx_howmany(varp->type, extent);
#line 930

#line 930
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 930
				 0, (void **)&xp);	/* cast away const */
#line 930
		if(lstatus != NC_NOERR)
#line 930
			return lstatus;
#line 930

#line 930
		lstatus = ncx_getn_double_double(&xp, nget, value);
#line 930
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 930
			status = lstatus;
#line 930

#line 930
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 930

#line 930
		remaining -= extent;
#line 930
		if(remaining == 0)
#line 930
			break; /* normal loop exit */
#line 930
		offset += extent;
#line 930
		value += nget;
#line 930
	}
#line 930

#line 930
	return status;
#line 930
}
#line 930

static int
#line 931
getNCvx_double_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 931
		 const size_t *start, size_t nelems, longlong *value)
#line 931
{
#line 931
	off_t offset = NC_varoffset(ncp, varp, start);
#line 931
	size_t remaining = varp->xsz * nelems;
#line 931
	int status = NC_NOERR;
#line 931
	const void *xp;
#line 931

#line 931
	if(nelems == 0)
#line 931
		return NC_NOERR;
#line 931

#line 931
	assert(value != NULL);
#line 931

#line 931
	for(;;)
#line 931
	{
#line 931
		size_t extent = MIN(remaining, ncp->chunk);
#line 931
		size_t nget = ncx_howmany(varp->type, extent);
#line 931

#line 931
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 931
				 0, (void **)&xp);	/* cast away const */
#line 931
		if(lstatus != NC_NOERR)
#line 931
			return lstatus;
#line 931

#line 931
		lstatus = ncx_getn_double_longlong(&xp, nget, value);
#line 931
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 931
			status = lstatus;
#line 931

#line 931
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 931

#line 931
		remaining -= extent;
#line 931
		if(remaining == 0)
#line 931
			break; /* normal loop exit */
#line 931
		offset += extent;
#line 931
		value += nget;
#line 931
	}
#line 931

#line 931
	return status;
#line 931
}
#line 931

static int
#line 932
getNCvx_double_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 932
		 const size_t *start, size_t nelems, uint *value)
#line 932
{
#line 932
	off_t offset = NC_varoffset(ncp, varp, start);
#line 932
	size_t remaining = varp->xsz * nelems;
#line 932
	int status = NC_NOERR;
#line 932
	const void *xp;
#line 932

#line 932
	if(nelems == 0)
#line 932
		return NC_NOERR;
#line 932

#line 932
	assert(value != NULL);
#line 932

#line 932
	for(;;)
#line 932
	{
#line 932
		size_t extent = MIN(remaining, ncp->chunk);
#line 932
		size_t nget = ncx_howmany(varp->type, extent);
#line 932

#line 932
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 932
				 0, (void **)&xp);	/* cast away const */
#line 932
		if(lstatus != NC_NOERR)
#line 932
			return lstatus;
#line 932

#line 932
		lstatus = ncx_getn_double_uint(&xp, nget, value);
#line 932
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 932
			status = lstatus;
#line 932

#line 932
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 932

#line 932
		remaining -= extent;
#line 932
		if(remaining == 0)
#line 932
			break; /* normal loop exit */
#line 932
		offset += extent;
#line 932
		value += nget;
#line 932
	}
#line 932

#line 932
	return status;
#line 932
}
#line 932

static int
#line 933
getNCvx_double_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 933
		 const size_t *start, size_t nelems, ulonglong *value)
#line 933
{
#line 933
	off_t offset = NC_varoffset(ncp, varp, start);
#line 933
	size_t remaining = varp->xsz * nelems;
#line 933
	int status = NC_NOERR;
#line 933
	const void *xp;
#line 933

#line 933
	if(nelems == 0)
#line 933
		return NC_NOERR;
#line 933

#line 933
	assert(value != NULL);
#line 933

#line 933
	for(;;)
#line 933
	{
#line 933
		size_t extent = MIN(remaining, ncp->chunk);
#line 933
		size_t nget = ncx_howmany(varp->type, extent);
#line 933

#line 933
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 933
				 0, (void **)&xp);	/* cast away const */
#line 933
		if(lstatus != NC_NOERR)
#line 933
			return lstatus;
#line 933

#line 933
		lstatus = ncx_getn_double_ulonglong(&xp, nget, value);
#line 933
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 933
			status = lstatus;
#line 933

#line 933
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 933

#line 933
		remaining -= extent;
#line 933
		if(remaining == 0)
#line 933
			break; /* normal loop exit */
#line 933
		offset += extent;
#line 933
		value += nget;
#line 933
	}
#line 933

#line 933
	return status;
#line 933
}
#line 933

static int
#line 934
getNCvx_double_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 934
		 const size_t *start, size_t nelems, ushort *value)
#line 934
{
#line 934
	off_t offset = NC_varoffset(ncp, varp, start);
#line 934
	size_t remaining = varp->xsz * nelems;
#line 934
	int status = NC_NOERR;
#line 934
	const void *xp;
#line 934

#line 934
	if(nelems == 0)
#line 934
		return NC_NOERR;
#line 934

#line 934
	assert(value != NULL);
#line 934

#line 934
	for(;;)
#line 934
	{
#line 934
		size_t extent = MIN(remaining, ncp->chunk);
#line 934
		size_t nget = ncx_howmany(varp->type, extent);
#line 934

#line 934
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 934
				 0, (void **)&xp);	/* cast away const */
#line 934
		if(lstatus != NC_NOERR)
#line 934
			return lstatus;
#line 934

#line 934
		lstatus = ncx_getn_double_ushort(&xp, nget, value);
#line 934
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 934
			status = lstatus;
#line 934

#line 934
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 934

#line 934
		remaining -= extent;
#line 934
		if(remaining == 0)
#line 934
			break; /* normal loop exit */
#line 934
		offset += extent;
#line 934
		value += nget;
#line 934
	}
#line 934

#line 934
	return status;
#line 934
}
#line 934


static int
#line 936
getNCvx_uchar_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 936
		 const size_t *start, size_t nelems, schar *value)
#line 936
{
#line 936
	off_t offset = NC_varoffset(ncp, varp, start);
#line 936
	size_t remaining = varp->xsz * nelems;
#line 936
	int status = NC_NOERR;
#line 936
	const void *xp;
#line 936

#line 936
	if(nelems == 0)
#line 936
		return NC_NOERR;
#line 936

#line 936
	assert(value != NULL);
#line 936

#line 936
	for(;;)
#line 936
	{
#line 936
		size_t extent = MIN(remaining, ncp->chunk);
#line 936
		size_t nget = ncx_howmany(varp->type, extent);
#line 936

#line 936
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 936
				 0, (void **)&xp);	/* cast away const */
#line 936
		if(lstatus != NC_NOERR)
#line 936
			return lstatus;
#line 936

#line 936
		lstatus = ncx_getn_uchar_schar(&xp, nget, value);
#line 936
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 936
			status = lstatus;
#line 936

#line 936
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 936

#line 936
		remaining -= extent;
#line 936
		if(remaining == 0)
#line 936
			break; /* normal loop exit */
#line 936
		offset += extent;
#line 936
		value += nget;
#line 936
	}
#line 936

#line 936
	return status;
#line 936
}
#line 936

static int
#line 937
getNCvx_uchar_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 937
		 const size_t *start, size_t nelems, uchar *value)
#line 937
{
#line 937
	off_t offset = NC_varoffset(ncp, varp, start);
#line 937
	size_t remaining = varp->xsz * nelems;
#line 937
	int status = NC_NOERR;
#line 937
	const void *xp;
#line 937

#line 937
	if(nelems == 0)
#line 937
		return NC_NOERR;
#line 937

#line 937
	assert(value != NULL);
#line 937

#line 937
	for(;;)
#line 937
	{
#line 937
		size_t extent = MIN(remaining, ncp->chunk);
#line 937
		size_t nget = ncx_howmany(varp->type, extent);
#line 937

#line 937
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 937
				 0, (void **)&xp);	/* cast away const */
#line 937
		if(lstatus != NC_NOERR)
#line 937
			return lstatus;
#line 937

#line 937
		lstatus = ncx_getn_uchar_uchar(&xp, nget, value);
#line 937
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 937
			status = lstatus;
#line 937

#line 937
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 937

#line 937
		remaining -= extent;
#line 937
		if(remaining == 0)
#line 937
			break; /* normal loop exit */
#line 937
		offset += extent;
#line 937
		value += nget;
#line 937
	}
#line 937

#line 937
	return status;
#line 937
}
#line 937

static int
#line 938
getNCvx_uchar_short(const NC3_INFO* ncp, const NC_var *varp,
#line 938
		 const size_t *start, size_t nelems, short *value)
#line 938
{
#line 938
	off_t offset = NC_varoffset(ncp, varp, start);
#line 938
	size_t remaining = varp->xsz * nelems;
#line 938
	int status = NC_NOERR;
#line 938
	const void *xp;
#line 938

#line 938
	if(nelems == 0)
#line 938
		return NC_NOERR;
#line 938

#line 938
	assert(value != NULL);
#line 938

#line 938
	for(;;)
#line 938
	{
#line 938
		size_t extent = MIN(remaining, ncp->chunk);
#line 938
		size_t nget = ncx_howmany(varp->type, extent);
#line 938

#line 938
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 938
				 0, (void **)&xp);	/* cast away const */
#line 938
		if(lstatus != NC_NOERR)
#line 938
			return lstatus;
#line 938

#line 938
		lstatus = ncx_getn_uchar_short(&xp, nget, value);
#line 938
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 938
			status = lstatus;
#line 938

#line 938
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 938

#line 938
		remaining -= extent;
#line 938
		if(remaining == 0)
#line 938
			break; /* normal loop exit */
#line 938
		offset += extent;
#line 938
		value += nget;
#line 938
	}
#line 938

#line 938
	return status;
#line 938
}
#line 938

static int
#line 939
getNCvx_uchar_int(const NC3_INFO* ncp, const NC_var *varp,
#line 939
		 const size_t *start, size_t nelems, int *value)
#line 939
{
#line 939
	off_t offset = NC_varoffset(ncp, varp, start);
#line 939
	size_t remaining = varp->xsz * nelems;
#line 939
	int status = NC_NOERR;
#line 939
	const void *xp;
#line 939

#line 939
	if(nelems == 0)
#line 939
		return NC_NOERR;
#line 939

#line 939
	assert(value != NULL);
#line 939

#line 939
	for(;;)
#line 939
	{
#line 939
		size_t extent = MIN(remaining, ncp->chunk);
#line 939
		size_t nget = ncx_howmany(varp->type, extent);
#line 939

#line 939
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 939
				 0, (void **)&xp);	/* cast away const */
#line 939
		if(lstatus != NC_NOERR)
#line 939
			return lstatus;
#line 939

#line 939
		lstatus = ncx_getn_uchar_int(&xp, nget, value);
#line 939
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 939
			status = lstatus;
#line 939

#line 939
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 939

#line 939
		remaining -= extent;
#line 939
		if(remaining == 0)
#line 939
			break; /* normal loop exit */
#line 939
		offset += extent;
#line 939
		value += nget;
#line 939
	}
#line 939

#line 939
	return status;
#line 939
}
#line 939

static int
#line 940
getNCvx_uchar_float(const NC3_INFO* ncp, const NC_var *varp,
#line 940
		 const size_t *start, size_t nelems, float *value)
#line 940
{
#line 940
	off_t offset = NC_varoffset(ncp, varp, start);
#line 940
	size_t remaining = varp->xsz * nelems;
#line 940
	int status = NC_NOERR;
#line 940
	const void *xp;
#line 940

#line 940
	if(nelems == 0)
#line 940
		return NC_NOERR;
#line 940

#line 940
	assert(value != NULL);
#line 940

#line 940
	for(;;)
#line 940
	{
#line 940
		size_t extent = MIN(remaining, ncp->chunk);
#line 940
		size_t nget = ncx_howmany(varp->type, extent);
#line 940

#line 940
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 940
				 0, (void **)&xp);	/* cast away const */
#line 940
		if(lstatus != NC_NOERR)
#line 940
			return lstatus;
#line 940

#line 940
		lstatus = ncx_getn_uchar_float(&xp, nget, value);
#line 940
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 940
			status = lstatus;
#line 940

#line 940
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 940

#line 940
		remaining -= extent;
#line 940
		if(remaining == 0)
#line 940
			break; /* normal loop exit */
#line 940
		offset += extent;
#line 940
		value += nget;
#line 940
	}
#line 940

#line 940
	return status;
#line 940
}
#line 940

static int
#line 941
getNCvx_uchar_double(const NC3_INFO* ncp, const NC_var *varp,
#line 941
		 const size_t *start, size_t nelems, double *value)
#line 941
{
#line 941
	off_t offset = NC_varoffset(ncp, varp, start);
#line 941
	size_t remaining = varp->xsz * nelems;
#line 941
	int status = NC_NOERR;
#line 941
	const void *xp;
#line 941

#line 941
	if(nelems == 0)
#line 941
		return NC_NOERR;
#line 941

#line 941
	assert(value != NULL);
#line 941

#line 941
	for(;;)
#line 941
	{
#line 941
		size_t extent = MIN(remaining, ncp->chunk);
#line 941
		size_t nget = ncx_howmany(varp->type, extent);
#line 941

#line 941
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 941
				 0, (void **)&xp);	/* cast away const */
#line 941
		if(lstatus != NC_NOERR)
#line 941
			return lstatus;
#line 941

#line 941
		lstatus = ncx_getn_uchar_double(&xp, nget, value);
#line 941
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 941
			status = lstatus;
#line 941

#line 941
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 941

#line 941
		remaining -= extent;
#line 941
		if(remaining == 0)
#line 941
			break; /* normal loop exit */
#line 941
		offset += extent;
#line 941
		value += nget;
#line 941
	}
#line 941

#line 941
	return status;
#line 941
}
#line 941

static int
#line 942
getNCvx_uchar_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 942
		 const size_t *start, size_t nelems, longlong *value)
#line 942
{
#line 942
	off_t offset = NC_varoffset(ncp, varp, start);
#line 942
	size_t remaining = varp->xsz * nelems;
#line 942
	int status = NC_NOERR;
#line 942
	const void *xp;
#line 942

#line 942
	if(nelems == 0)
#line 942
		return NC_NOERR;
#line 942

#line 942
	assert(value != NULL);
#line 942

#line 942
	for(;;)
#line 942
	{
#line 942
		size_t extent = MIN(remaining, ncp->chunk);
#line 942
		size_t nget = ncx_howmany(varp->type, extent);
#line 942

#line 942
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 942
				 0, (void **)&xp);	/* cast away const */
#line 942
		if(lstatus != NC_NOERR)
#line 942
			return lstatus;
#line 942

#line 942
		lstatus = ncx_getn_uchar_longlong(&xp, nget, value);
#line 942
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 942
			status = lstatus;
#line 942

#line 942
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 942

#line 942
		remaining -= extent;
#line 942
		if(remaining == 0)
#line 942
			break; /* normal loop exit */
#line 942
		offset += extent;
#line 942
		value += nget;
#line 942
	}
#line 942

#line 942
	return status;
#line 942
}
#line 942

static int
#line 943
getNCvx_uchar_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 943
		 const size_t *start, size_t nelems, uint *value)
#line 943
{
#line 943
	off_t offset = NC_varoffset(ncp, varp, start);
#line 943
	size_t remaining = varp->xsz * nelems;
#line 943
	int status = NC_NOERR;
#line 943
	const void *xp;
#line 943

#line 943
	if(nelems == 0)
#line 943
		return NC_NOERR;
#line 943

#line 943
	assert(value != NULL);
#line 943

#line 943
	for(;;)
#line 943
	{
#line 943
		size_t extent = MIN(remaining, ncp->chunk);
#line 943
		size_t nget = ncx_howmany(varp->type, extent);
#line 943

#line 943
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 943
				 0, (void **)&xp);	/* cast away const */
#line 943
		if(lstatus != NC_NOERR)
#line 943
			return lstatus;
#line 943

#line 943
		lstatus = ncx_getn_uchar_uint(&xp, nget, value);
#line 943
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 943
			status = lstatus;
#line 943

#line 943
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 943

#line 943
		remaining -= extent;
#line 943
		if(remaining == 0)
#line 943
			break; /* normal loop exit */
#line 943
		offset += extent;
#line 943
		value += nget;
#line 943
	}
#line 943

#line 943
	return status;
#line 943
}
#line 943

static int
#line 944
getNCvx_uchar_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 944
		 const size_t *start, size_t nelems, ulonglong *value)
#line 944
{
#line 944
	off_t offset = NC_varoffset(ncp, varp, start);
#line 944
	size_t remaining = varp->xsz * nelems;
#line 944
	int status = NC_NOERR;
#line 944
	const void *xp;
#line 944

#line 944
	if(nelems == 0)
#line 944
		return NC_NOERR;
#line 944

#line 944
	assert(value != NULL);
#line 944

#line 944
	for(;;)
#line 944
	{
#line 944
		size_t extent = MIN(remaining, ncp->chunk);
#line 944
		size_t nget = ncx_howmany(varp->type, extent);
#line 944

#line 944
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 944
				 0, (void **)&xp);	/* cast away const */
#line 944
		if(lstatus != NC_NOERR)
#line 944
			return lstatus;
#line 944

#line 944
		lstatus = ncx_getn_uchar_ulonglong(&xp, nget, value);
#line 944
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 944
			status = lstatus;
#line 944

#line 944
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 944

#line 944
		remaining -= extent;
#line 944
		if(remaining == 0)
#line 944
			break; /* normal loop exit */
#line 944
		offset += extent;
#line 944
		value += nget;
#line 944
	}
#line 944

#line 944
	return status;
#line 944
}
#line 944

static int
#line 945
getNCvx_uchar_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 945
		 const size_t *start, size_t nelems, ushort *value)
#line 945
{
#line 945
	off_t offset = NC_varoffset(ncp, varp, start);
#line 945
	size_t remaining = varp->xsz * nelems;
#line 945
	int status = NC_NOERR;
#line 945
	const void *xp;
#line 945

#line 945
	if(nelems == 0)
#line 945
		return NC_NOERR;
#line 945

#line 945
	assert(value != NULL);
#line 945

#line 945
	for(;;)
#line 945
	{
#line 945
		size_t extent = MIN(remaining, ncp->chunk);
#line 945
		size_t nget = ncx_howmany(varp->type, extent);
#line 945

#line 945
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 945
				 0, (void **)&xp);	/* cast away const */
#line 945
		if(lstatus != NC_NOERR)
#line 945
			return lstatus;
#line 945

#line 945
		lstatus = ncx_getn_uchar_ushort(&xp, nget, value);
#line 945
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 945
			status = lstatus;
#line 945

#line 945
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 945

#line 945
		remaining -= extent;
#line 945
		if(remaining == 0)
#line 945
			break; /* normal loop exit */
#line 945
		offset += extent;
#line 945
		value += nget;
#line 945
	}
#line 945

#line 945
	return status;
#line 945
}
#line 945


static int
#line 947
getNCvx_ushort_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 947
		 const size_t *start, size_t nelems, schar *value)
#line 947
{
#line 947
	off_t offset = NC_varoffset(ncp, varp, start);
#line 947
	size_t remaining = varp->xsz * nelems;
#line 947
	int status = NC_NOERR;
#line 947
	const void *xp;
#line 947

#line 947
	if(nelems == 0)
#line 947
		return NC_NOERR;
#line 947

#line 947
	assert(value != NULL);
#line 947

#line 947
	for(;;)
#line 947
	{
#line 947
		size_t extent = MIN(remaining, ncp->chunk);
#line 947
		size_t nget = ncx_howmany(varp->type, extent);
#line 947

#line 947
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 947
				 0, (void **)&xp);	/* cast away const */
#line 947
		if(lstatus != NC_NOERR)
#line 947
			return lstatus;
#line 947

#line 947
		lstatus = ncx_getn_ushort_schar(&xp, nget, value);
#line 947
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 947
			status = lstatus;
#line 947

#line 947
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 947

#line 947
		remaining -= extent;
#line 947
		if(remaining == 0)
#line 947
			break; /* normal loop exit */
#line 947
		offset += extent;
#line 947
		value += nget;
#line 947
	}
#line 947

#line 947
	return status;
#line 947
}
#line 947

static int
#line 948
getNCvx_ushort_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 948
		 const size_t *start, size_t nelems, uchar *value)
#line 948
{
#line 948
	off_t offset = NC_varoffset(ncp, varp, start);
#line 948
	size_t remaining = varp->xsz * nelems;
#line 948
	int status = NC_NOERR;
#line 948
	const void *xp;
#line 948

#line 948
	if(nelems == 0)
#line 948
		return NC_NOERR;
#line 948

#line 948
	assert(value != NULL);
#line 948

#line 948
	for(;;)
#line 948
	{
#line 948
		size_t extent = MIN(remaining, ncp->chunk);
#line 948
		size_t nget = ncx_howmany(varp->type, extent);
#line 948

#line 948
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 948
				 0, (void **)&xp);	/* cast away const */
#line 948
		if(lstatus != NC_NOERR)
#line 948
			return lstatus;
#line 948

#line 948
		lstatus = ncx_getn_ushort_uchar(&xp, nget, value);
#line 948
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 948
			status = lstatus;
#line 948

#line 948
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 948

#line 948
		remaining -= extent;
#line 948
		if(remaining == 0)
#line 948
			break; /* normal loop exit */
#line 948
		offset += extent;
#line 948
		value += nget;
#line 948
	}
#line 948

#line 948
	return status;
#line 948
}
#line 948

static int
#line 949
getNCvx_ushort_short(const NC3_INFO* ncp, const NC_var *varp,
#line 949
		 const size_t *start, size_t nelems, short *value)
#line 949
{
#line 949
	off_t offset = NC_varoffset(ncp, varp, start);
#line 949
	size_t remaining = varp->xsz * nelems;
#line 949
	int status = NC_NOERR;
#line 949
	const void *xp;
#line 949

#line 949
	if(nelems == 0)
#line 949
		return NC_NOERR;
#line 949

#line 949
	assert(value != NULL);
#line 949

#line 949
	for(;;)
#line 949
	{
#line 949
		size_t extent = MIN(remaining, ncp->chunk);
#line 949
		size_t nget = ncx_howmany(varp->type, extent);
#line 949

#line 949
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 949
				 0, (void **)&xp);	/* cast away const */
#line 949
		if(lstatus != NC_NOERR)
#line 949
			return lstatus;
#line 949

#line 949
		lstatus = ncx_getn_ushort_short(&xp, nget, value);
#line 949
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 949
			status = lstatus;
#line 949

#line 949
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 949

#line 949
		remaining -= extent;
#line 949
		if(remaining == 0)
#line 949
			break; /* normal loop exit */
#line 949
		offset += extent;
#line 949
		value += nget;
#line 949
	}
#line 949

#line 949
	return status;
#line 949
}
#line 949

static int
#line 950
getNCvx_ushort_int(const NC3_INFO* ncp, const NC_var *varp,
#line 950
		 const size_t *start, size_t nelems, int *value)
#line 950
{
#line 950
	off_t offset = NC_varoffset(ncp, varp, start);
#line 950
	size_t remaining = varp->xsz * nelems;
#line 950
	int status = NC_NOERR;
#line 950
	const void *xp;
#line 950

#line 950
	if(nelems == 0)
#line 950
		return NC_NOERR;
#line 950

#line 950
	assert(value != NULL);
#line 950

#line 950
	for(;;)
#line 950
	{
#line 950
		size_t extent = MIN(remaining, ncp->chunk);
#line 950
		size_t nget = ncx_howmany(varp->type, extent);
#line 950

#line 950
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 950
				 0, (void **)&xp);	/* cast away const */
#line 950
		if(lstatus != NC_NOERR)
#line 950
			return lstatus;
#line 950

#line 950
		lstatus = ncx_getn_ushort_int(&xp, nget, value);
#line 950
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 950
			status = lstatus;
#line 950

#line 950
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 950

#line 950
		remaining -= extent;
#line 950
		if(remaining == 0)
#line 950
			break; /* normal loop exit */
#line 950
		offset += extent;
#line 950
		value += nget;
#line 950
	}
#line 950

#line 950
	return status;
#line 950
}
#line 950

static int
#line 951
getNCvx_ushort_float(const NC3_INFO* ncp, const NC_var *varp,
#line 951
		 const size_t *start, size_t nelems, float *value)
#line 951
{
#line 951
	off_t offset = NC_varoffset(ncp, varp, start);
#line 951
	size_t remaining = varp->xsz * nelems;
#line 951
	int status = NC_NOERR;
#line 951
	const void *xp;
#line 951

#line 951
	if(nelems == 0)
#line 951
		return NC_NOERR;
#line 951

#line 951
	assert(value != NULL);
#line 951

#line 951
	for(;;)
#line 951
	{
#line 951
		size_t extent = MIN(remaining, ncp->chunk);
#line 951
		size_t nget = ncx_howmany(varp->type, extent);
#line 951

#line 951
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 951
				 0, (void **)&xp);	/* cast away const */
#line 951
		if(lstatus != NC_NOERR)
#line 951
			return lstatus;
#line 951

#line 951
		lstatus = ncx_getn_ushort_float(&xp, nget, value);
#line 951
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 951
			status = lstatus;
#line 951

#line 951
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 951

#line 951
		remaining -= extent;
#line 951
		if(remaining == 0)
#line 951
			break; /* normal loop exit */
#line 951
		offset += extent;
#line 951
		value += nget;
#line 951
	}
#line 951

#line 951
	return status;
#line 951
}
#line 951

static int
#line 952
getNCvx_ushort_double(const NC3_INFO* ncp, const NC_var *varp,
#line 952
		 const size_t *start, size_t nelems, double *value)
#line 952
{
#line 952
	off_t offset = NC_varoffset(ncp, varp, start);
#line 952
	size_t remaining = varp->xsz * nelems;
#line 952
	int status = NC_NOERR;
#line 952
	const void *xp;
#line 952

#line 952
	if(nelems == 0)
#line 952
		return NC_NOERR;
#line 952

#line 952
	assert(value != NULL);
#line 952

#line 952
	for(;;)
#line 952
	{
#line 952
		size_t extent = MIN(remaining, ncp->chunk);
#line 952
		size_t nget = ncx_howmany(varp->type, extent);
#line 952

#line 952
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 952
				 0, (void **)&xp);	/* cast away const */
#line 952
		if(lstatus != NC_NOERR)
#line 952
			return lstatus;
#line 952

#line 952
		lstatus = ncx_getn_ushort_double(&xp, nget, value);
#line 952
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 952
			status = lstatus;
#line 952

#line 952
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 952

#line 952
		remaining -= extent;
#line 952
		if(remaining == 0)
#line 952
			break; /* normal loop exit */
#line 952
		offset += extent;
#line 952
		value += nget;
#line 952
	}
#line 952

#line 952
	return status;
#line 952
}
#line 952

static int
#line 953
getNCvx_ushort_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 953
		 const size_t *start, size_t nelems, longlong *value)
#line 953
{
#line 953
	off_t offset = NC_varoffset(ncp, varp, start);
#line 953
	size_t remaining = varp->xsz * nelems;
#line 953
	int status = NC_NOERR;
#line 953
	const void *xp;
#line 953

#line 953
	if(nelems == 0)
#line 953
		return NC_NOERR;
#line 953

#line 953
	assert(value != NULL);
#line 953

#line 953
	for(;;)
#line 953
	{
#line 953
		size_t extent = MIN(remaining, ncp->chunk);
#line 953
		size_t nget = ncx_howmany(varp->type, extent);
#line 953

#line 953
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 953
				 0, (void **)&xp);	/* cast away const */
#line 953
		if(lstatus != NC_NOERR)
#line 953
			return lstatus;
#line 953

#line 953
		lstatus = ncx_getn_ushort_longlong(&xp, nget, value);
#line 953
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 953
			status = lstatus;
#line 953

#line 953
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 953

#line 953
		remaining -= extent;
#line 953
		if(remaining == 0)
#line 953
			break; /* normal loop exit */
#line 953
		offset += extent;
#line 953
		value += nget;
#line 953
	}
#line 953

#line 953
	return status;
#line 953
}
#line 953

static int
#line 954
getNCvx_ushort_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 954
		 const size_t *start, size_t nelems, uint *value)
#line 954
{
#line 954
	off_t offset = NC_varoffset(ncp, varp, start);
#line 954
	size_t remaining = varp->xsz * nelems;
#line 954
	int status = NC_NOERR;
#line 954
	const void *xp;
#line 954

#line 954
	if(nelems == 0)
#line 954
		return NC_NOERR;
#line 954

#line 954
	assert(value != NULL);
#line 954

#line 954
	for(;;)
#line 954
	{
#line 954
		size_t extent = MIN(remaining, ncp->chunk);
#line 954
		size_t nget = ncx_howmany(varp->type, extent);
#line 954

#line 954
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 954
				 0, (void **)&xp);	/* cast away const */
#line 954
		if(lstatus != NC_NOERR)
#line 954
			return lstatus;
#line 954

#line 954
		lstatus = ncx_getn_ushort_uint(&xp, nget, value);
#line 954
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 954
			status = lstatus;
#line 954

#line 954
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 954

#line 954
		remaining -= extent;
#line 954
		if(remaining == 0)
#line 954
			break; /* normal loop exit */
#line 954
		offset += extent;
#line 954
		value += nget;
#line 954
	}
#line 954

#line 954
	return status;
#line 954
}
#line 954

static int
#line 955
getNCvx_ushort_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 955
		 const size_t *start, size_t nelems, ulonglong *value)
#line 955
{
#line 955
	off_t offset = NC_varoffset(ncp, varp, start);
#line 955
	size_t remaining = varp->xsz * nelems;
#line 955
	int status = NC_NOERR;
#line 955
	const void *xp;
#line 955

#line 955
	if(nelems == 0)
#line 955
		return NC_NOERR;
#line 955

#line 955
	assert(value != NULL);
#line 955

#line 955
	for(;;)
#line 955
	{
#line 955
		size_t extent = MIN(remaining, ncp->chunk);
#line 955
		size_t nget = ncx_howmany(varp->type, extent);
#line 955

#line 955
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 955
				 0, (void **)&xp);	/* cast away const */
#line 955
		if(lstatus != NC_NOERR)
#line 955
			return lstatus;
#line 955

#line 955
		lstatus = ncx_getn_ushort_ulonglong(&xp, nget, value);
#line 955
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 955
			status = lstatus;
#line 955

#line 955
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 955

#line 955
		remaining -= extent;
#line 955
		if(remaining == 0)
#line 955
			break; /* normal loop exit */
#line 955
		offset += extent;
#line 955
		value += nget;
#line 955
	}
#line 955

#line 955
	return status;
#line 955
}
#line 955

static int
#line 956
getNCvx_ushort_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 956
		 const size_t *start, size_t nelems, ushort *value)
#line 956
{
#line 956
	off_t offset = NC_varoffset(ncp, varp, start);
#line 956
	size_t remaining = varp->xsz * nelems;
#line 956
	int status = NC_NOERR;
#line 956
	const void *xp;
#line 956

#line 956
	if(nelems == 0)
#line 956
		return NC_NOERR;
#line 956

#line 956
	assert(value != NULL);
#line 956

#line 956
	for(;;)
#line 956
	{
#line 956
		size_t extent = MIN(remaining, ncp->chunk);
#line 956
		size_t nget = ncx_howmany(varp->type, extent);
#line 956

#line 956
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 956
				 0, (void **)&xp);	/* cast away const */
#line 956
		if(lstatus != NC_NOERR)
#line 956
			return lstatus;
#line 956

#line 956
		lstatus = ncx_getn_ushort_ushort(&xp, nget, value);
#line 956
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 956
			status = lstatus;
#line 956

#line 956
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 956

#line 956
		remaining -= extent;
#line 956
		if(remaining == 0)
#line 956
			break; /* normal loop exit */
#line 956
		offset += extent;
#line 956
		value += nget;
#line 956
	}
#line 956

#line 956
	return status;
#line 956
}
#line 956


static int
#line 958
getNCvx_uint_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 958
		 const size_t *start, size_t nelems, schar *value)
#line 958
{
#line 958
	off_t offset = NC_varoffset(ncp, varp, start);
#line 958
	size_t remaining = varp->xsz * nelems;
#line 958
	int status = NC_NOERR;
#line 958
	const void *xp;
#line 958

#line 958
	if(nelems == 0)
#line 958
		return NC_NOERR;
#line 958

#line 958
	assert(value != NULL);
#line 958

#line 958
	for(;;)
#line 958
	{
#line 958
		size_t extent = MIN(remaining, ncp->chunk);
#line 958
		size_t nget = ncx_howmany(varp->type, extent);
#line 958

#line 958
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 958
				 0, (void **)&xp);	/* cast away const */
#line 958
		if(lstatus != NC_NOERR)
#line 958
			return lstatus;
#line 958

#line 958
		lstatus = ncx_getn_uint_schar(&xp, nget, value);
#line 958
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 958
			status = lstatus;
#line 958

#line 958
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 958

#line 958
		remaining -= extent;
#line 958
		if(remaining == 0)
#line 958
			break; /* normal loop exit */
#line 958
		offset += extent;
#line 958
		value += nget;
#line 958
	}
#line 958

#line 958
	return status;
#line 958
}
#line 958

static int
#line 959
getNCvx_uint_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 959
		 const size_t *start, size_t nelems, uchar *value)
#line 959
{
#line 959
	off_t offset = NC_varoffset(ncp, varp, start);
#line 959
	size_t remaining = varp->xsz * nelems;
#line 959
	int status = NC_NOERR;
#line 959
	const void *xp;
#line 959

#line 959
	if(nelems == 0)
#line 959
		return NC_NOERR;
#line 959

#line 959
	assert(value != NULL);
#line 959

#line 959
	for(;;)
#line 959
	{
#line 959
		size_t extent = MIN(remaining, ncp->chunk);
#line 959
		size_t nget = ncx_howmany(varp->type, extent);
#line 959

#line 959
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 959
				 0, (void **)&xp);	/* cast away const */
#line 959
		if(lstatus != NC_NOERR)
#line 959
			return lstatus;
#line 959

#line 959
		lstatus = ncx_getn_uint_uchar(&xp, nget, value);
#line 959
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 959
			status = lstatus;
#line 959

#line 959
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 959

#line 959
		remaining -= extent;
#line 959
		if(remaining == 0)
#line 959
			break; /* normal loop exit */
#line 959
		offset += extent;
#line 959
		value += nget;
#line 959
	}
#line 959

#line 959
	return status;
#line 959
}
#line 959

static int
#line 960
getNCvx_uint_short(const NC3_INFO* ncp, const NC_var *varp,
#line 960
		 const size_t *start, size_t nelems, short *value)
#line 960
{
#line 960
	off_t offset = NC_varoffset(ncp, varp, start);
#line 960
	size_t remaining = varp->xsz * nelems;
#line 960
	int status = NC_NOERR;
#line 960
	const void *xp;
#line 960

#line 960
	if(nelems == 0)
#line 960
		return NC_NOERR;
#line 960

#line 960
	assert(value != NULL);
#line 960

#line 960
	for(;;)
#line 960
	{
#line 960
		size_t extent = MIN(remaining, ncp->chunk);
#line 960
		size_t nget = ncx_howmany(varp->type, extent);
#line 960

#line 960
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 960
				 0, (void **)&xp);	/* cast away const */
#line 960
		if(lstatus != NC_NOERR)
#line 960
			return lstatus;
#line 960

#line 960
		lstatus = ncx_getn_uint_short(&xp, nget, value);
#line 960
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 960
			status = lstatus;
#line 960

#line 960
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 960

#line 960
		remaining -= extent;
#line 960
		if(remaining == 0)
#line 960
			break; /* normal loop exit */
#line 960
		offset += extent;
#line 960
		value += nget;
#line 960
	}
#line 960

#line 960
	return status;
#line 960
}
#line 960

static int
#line 961
getNCvx_uint_int(const NC3_INFO* ncp, const NC_var *varp,
#line 961
		 const size_t *start, size_t nelems, int *value)
#line 961
{
#line 961
	off_t offset = NC_varoffset(ncp, varp, start);
#line 961
	size_t remaining = varp->xsz * nelems;
#line 961
	int status = NC_NOERR;
#line 961
	const void *xp;
#line 961

#line 961
	if(nelems == 0)
#line 961
		return NC_NOERR;
#line 961

#line 961
	assert(value != NULL);
#line 961

#line 961
	for(;;)
#line 961
	{
#line 961
		size_t extent = MIN(remaining, ncp->chunk);
#line 961
		size_t nget = ncx_howmany(varp->type, extent);
#line 961

#line 961
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 961
				 0, (void **)&xp);	/* cast away const */
#line 961
		if(lstatus != NC_NOERR)
#line 961
			return lstatus;
#line 961

#line 961
		lstatus = ncx_getn_uint_int(&xp, nget, value);
#line 961
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 961
			status = lstatus;
#line 961

#line 961
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 961

#line 961
		remaining -= extent;
#line 961
		if(remaining == 0)
#line 961
			break; /* normal loop exit */
#line 961
		offset += extent;
#line 961
		value += nget;
#line 961
	}
#line 961

#line 961
	return status;
#line 961
}
#line 961

static int
#line 962
getNCvx_uint_float(const NC3_INFO* ncp, const NC_var *varp,
#line 962
		 const size_t *start, size_t nelems, float *value)
#line 962
{
#line 962
	off_t offset = NC_varoffset(ncp, varp, start);
#line 962
	size_t remaining = varp->xsz * nelems;
#line 962
	int status = NC_NOERR;
#line 962
	const void *xp;
#line 962

#line 962
	if(nelems == 0)
#line 962
		return NC_NOERR;
#line 962

#line 962
	assert(value != NULL);
#line 962

#line 962
	for(;;)
#line 962
	{
#line 962
		size_t extent = MIN(remaining, ncp->chunk);
#line 962
		size_t nget = ncx_howmany(varp->type, extent);
#line 962

#line 962
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 962
				 0, (void **)&xp);	/* cast away const */
#line 962
		if(lstatus != NC_NOERR)
#line 962
			return lstatus;
#line 962

#line 962
		lstatus = ncx_getn_uint_float(&xp, nget, value);
#line 962
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 962
			status = lstatus;
#line 962

#line 962
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 962

#line 962
		remaining -= extent;
#line 962
		if(remaining == 0)
#line 962
			break; /* normal loop exit */
#line 962
		offset += extent;
#line 962
		value += nget;
#line 962
	}
#line 962

#line 962
	return status;
#line 962
}
#line 962

static int
#line 963
getNCvx_uint_double(const NC3_INFO* ncp, const NC_var *varp,
#line 963
		 const size_t *start, size_t nelems, double *value)
#line 963
{
#line 963
	off_t offset = NC_varoffset(ncp, varp, start);
#line 963
	size_t remaining = varp->xsz * nelems;
#line 963
	int status = NC_NOERR;
#line 963
	const void *xp;
#line 963

#line 963
	if(nelems == 0)
#line 963
		return NC_NOERR;
#line 963

#line 963
	assert(value != NULL);
#line 963

#line 963
	for(;;)
#line 963
	{
#line 963
		size_t extent = MIN(remaining, ncp->chunk);
#line 963
		size_t nget = ncx_howmany(varp->type, extent);
#line 963

#line 963
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 963
				 0, (void **)&xp);	/* cast away const */
#line 963
		if(lstatus != NC_NOERR)
#line 963
			return lstatus;
#line 963

#line 963
		lstatus = ncx_getn_uint_double(&xp, nget, value);
#line 963
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 963
			status = lstatus;
#line 963

#line 963
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 963

#line 963
		remaining -= extent;
#line 963
		if(remaining == 0)
#line 963
			break; /* normal loop exit */
#line 963
		offset += extent;
#line 963
		value += nget;
#line 963
	}
#line 963

#line 963
	return status;
#line 963
}
#line 963

static int
#line 964
getNCvx_uint_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 964
		 const size_t *start, size_t nelems, longlong *value)
#line 964
{
#line 964
	off_t offset = NC_varoffset(ncp, varp, start);
#line 964
	size_t remaining = varp->xsz * nelems;
#line 964
	int status = NC_NOERR;
#line 964
	const void *xp;
#line 964

#line 964
	if(nelems == 0)
#line 964
		return NC_NOERR;
#line 964

#line 964
	assert(value != NULL);
#line 964

#line 964
	for(;;)
#line 964
	{
#line 964
		size_t extent = MIN(remaining, ncp->chunk);
#line 964
		size_t nget = ncx_howmany(varp->type, extent);
#line 964

#line 964
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 964
				 0, (void **)&xp);	/* cast away const */
#line 964
		if(lstatus != NC_NOERR)
#line 964
			return lstatus;
#line 964

#line 964
		lstatus = ncx_getn_uint_longlong(&xp, nget, value);
#line 964
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 964
			status = lstatus;
#line 964

#line 964
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 964

#line 964
		remaining -= extent;
#line 964
		if(remaining == 0)
#line 964
			break; /* normal loop exit */
#line 964
		offset += extent;
#line 964
		value += nget;
#line 964
	}
#line 964

#line 964
	return status;
#line 964
}
#line 964

static int
#line 965
getNCvx_uint_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 965
		 const size_t *start, size_t nelems, uint *value)
#line 965
{
#line 965
	off_t offset = NC_varoffset(ncp, varp, start);
#line 965
	size_t remaining = varp->xsz * nelems;
#line 965
	int status = NC_NOERR;
#line 965
	const void *xp;
#line 965

#line 965
	if(nelems == 0)
#line 965
		return NC_NOERR;
#line 965

#line 965
	assert(value != NULL);
#line 965

#line 965
	for(;;)
#line 965
	{
#line 965
		size_t extent = MIN(remaining, ncp->chunk);
#line 965
		size_t nget = ncx_howmany(varp->type, extent);
#line 965

#line 965
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 965
				 0, (void **)&xp);	/* cast away const */
#line 965
		if(lstatus != NC_NOERR)
#line 965
			return lstatus;
#line 965

#line 965
		lstatus = ncx_getn_uint_uint(&xp, nget, value);
#line 965
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 965
			status = lstatus;
#line 965

#line 965
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 965

#line 965
		remaining -= extent;
#line 965
		if(remaining == 0)
#line 965
			break; /* normal loop exit */
#line 965
		offset += extent;
#line 965
		value += nget;
#line 965
	}
#line 965

#line 965
	return status;
#line 965
}
#line 965

static int
#line 966
getNCvx_uint_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 966
		 const size_t *start, size_t nelems, ulonglong *value)
#line 966
{
#line 966
	off_t offset = NC_varoffset(ncp, varp, start);
#line 966
	size_t remaining = varp->xsz * nelems;
#line 966
	int status = NC_NOERR;
#line 966
	const void *xp;
#line 966

#line 966
	if(nelems == 0)
#line 966
		return NC_NOERR;
#line 966

#line 966
	assert(value != NULL);
#line 966

#line 966
	for(;;)
#line 966
	{
#line 966
		size_t extent = MIN(remaining, ncp->chunk);
#line 966
		size_t nget = ncx_howmany(varp->type, extent);
#line 966

#line 966
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 966
				 0, (void **)&xp);	/* cast away const */
#line 966
		if(lstatus != NC_NOERR)
#line 966
			return lstatus;
#line 966

#line 966
		lstatus = ncx_getn_uint_ulonglong(&xp, nget, value);
#line 966
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 966
			status = lstatus;
#line 966

#line 966
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 966

#line 966
		remaining -= extent;
#line 966
		if(remaining == 0)
#line 966
			break; /* normal loop exit */
#line 966
		offset += extent;
#line 966
		value += nget;
#line 966
	}
#line 966

#line 966
	return status;
#line 966
}
#line 966

static int
#line 967
getNCvx_uint_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 967
		 const size_t *start, size_t nelems, ushort *value)
#line 967
{
#line 967
	off_t offset = NC_varoffset(ncp, varp, start);
#line 967
	size_t remaining = varp->xsz * nelems;
#line 967
	int status = NC_NOERR;
#line 967
	const void *xp;
#line 967

#line 967
	if(nelems == 0)
#line 967
		return NC_NOERR;
#line 967

#line 967
	assert(value != NULL);
#line 967

#line 967
	for(;;)
#line 967
	{
#line 967
		size_t extent = MIN(remaining, ncp->chunk);
#line 967
		size_t nget = ncx_howmany(varp->type, extent);
#line 967

#line 967
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 967
				 0, (void **)&xp);	/* cast away const */
#line 967
		if(lstatus != NC_NOERR)
#line 967
			return lstatus;
#line 967

#line 967
		lstatus = ncx_getn_uint_ushort(&xp, nget, value);
#line 967
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 967
			status = lstatus;
#line 967

#line 967
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 967

#line 967
		remaining -= extent;
#line 967
		if(remaining == 0)
#line 967
			break; /* normal loop exit */
#line 967
		offset += extent;
#line 967
		value += nget;
#line 967
	}
#line 967

#line 967
	return status;
#line 967
}
#line 967


static int
#line 969
getNCvx_longlong_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 969
		 const size_t *start, size_t nelems, schar *value)
#line 969
{
#line 969
	off_t offset = NC_varoffset(ncp, varp, start);
#line 969
	size_t remaining = varp->xsz * nelems;
#line 969
	int status = NC_NOERR;
#line 969
	const void *xp;
#line 969

#line 969
	if(nelems == 0)
#line 969
		return NC_NOERR;
#line 969

#line 969
	assert(value != NULL);
#line 969

#line 969
	for(;;)
#line 969
	{
#line 969
		size_t extent = MIN(remaining, ncp->chunk);
#line 969
		size_t nget = ncx_howmany(varp->type, extent);
#line 969

#line 969
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 969
				 0, (void **)&xp);	/* cast away const */
#line 969
		if(lstatus != NC_NOERR)
#line 969
			return lstatus;
#line 969

#line 969
		lstatus = ncx_getn_longlong_schar(&xp, nget, value);
#line 969
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 969
			status = lstatus;
#line 969

#line 969
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 969

#line 969
		remaining -= extent;
#line 969
		if(remaining == 0)
#line 969
			break; /* normal loop exit */
#line 969
		offset += extent;
#line 969
		value += nget;
#line 969
	}
#line 969

#line 969
	return status;
#line 969
}
#line 969

static int
#line 970
getNCvx_longlong_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 970
		 const size_t *start, size_t nelems, uchar *value)
#line 970
{
#line 970
	off_t offset = NC_varoffset(ncp, varp, start);
#line 970
	size_t remaining = varp->xsz * nelems;
#line 970
	int status = NC_NOERR;
#line 970
	const void *xp;
#line 970

#line 970
	if(nelems == 0)
#line 970
		return NC_NOERR;
#line 970

#line 970
	assert(value != NULL);
#line 970

#line 970
	for(;;)
#line 970
	{
#line 970
		size_t extent = MIN(remaining, ncp->chunk);
#line 970
		size_t nget = ncx_howmany(varp->type, extent);
#line 970

#line 970
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 970
				 0, (void **)&xp);	/* cast away const */
#line 970
		if(lstatus != NC_NOERR)
#line 970
			return lstatus;
#line 970

#line 970
		lstatus = ncx_getn_longlong_uchar(&xp, nget, value);
#line 970
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 970
			status = lstatus;
#line 970

#line 970
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 970

#line 970
		remaining -= extent;
#line 970
		if(remaining == 0)
#line 970
			break; /* normal loop exit */
#line 970
		offset += extent;
#line 970
		value += nget;
#line 970
	}
#line 970

#line 970
	return status;
#line 970
}
#line 970

static int
#line 971
getNCvx_longlong_short(const NC3_INFO* ncp, const NC_var *varp,
#line 971
		 const size_t *start, size_t nelems, short *value)
#line 971
{
#line 971
	off_t offset = NC_varoffset(ncp, varp, start);
#line 971
	size_t remaining = varp->xsz * nelems;
#line 971
	int status = NC_NOERR;
#line 971
	const void *xp;
#line 971

#line 971
	if(nelems == 0)
#line 971
		return NC_NOERR;
#line 971

#line 971
	assert(value != NULL);
#line 971

#line 971
	for(;;)
#line 971
	{
#line 971
		size_t extent = MIN(remaining, ncp->chunk);
#line 971
		size_t nget = ncx_howmany(varp->type, extent);
#line 971

#line 971
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 971
				 0, (void **)&xp);	/* cast away const */
#line 971
		if(lstatus != NC_NOERR)
#line 971
			return lstatus;
#line 971

#line 971
		lstatus = ncx_getn_longlong_short(&xp, nget, value);
#line 971
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 971
			status = lstatus;
#line 971

#line 971
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 971

#line 971
		remaining -= extent;
#line 971
		if(remaining == 0)
#line 971
			break; /* normal loop exit */
#line 971
		offset += extent;
#line 971
		value += nget;
#line 971
	}
#line 971

#line 971
	return status;
#line 971
}
#line 971

static int
#line 972
getNCvx_longlong_int(const NC3_INFO* ncp, const NC_var *varp,
#line 972
		 const size_t *start, size_t nelems, int *value)
#line 972
{
#line 972
	off_t offset = NC_varoffset(ncp, varp, start);
#line 972
	size_t remaining = varp->xsz * nelems;
#line 972
	int status = NC_NOERR;
#line 972
	const void *xp;
#line 972

#line 972
	if(nelems == 0)
#line 972
		return NC_NOERR;
#line 972

#line 972
	assert(value != NULL);
#line 972

#line 972
	for(;;)
#line 972
	{
#line 972
		size_t extent = MIN(remaining, ncp->chunk);
#line 972
		size_t nget = ncx_howmany(varp->type, extent);
#line 972

#line 972
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 972
				 0, (void **)&xp);	/* cast away const */
#line 972
		if(lstatus != NC_NOERR)
#line 972
			return lstatus;
#line 972

#line 972
		lstatus = ncx_getn_longlong_int(&xp, nget, value);
#line 972
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 972
			status = lstatus;
#line 972

#line 972
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 972

#line 972
		remaining -= extent;
#line 972
		if(remaining == 0)
#line 972
			break; /* normal loop exit */
#line 972
		offset += extent;
#line 972
		value += nget;
#line 972
	}
#line 972

#line 972
	return status;
#line 972
}
#line 972

static int
#line 973
getNCvx_longlong_float(const NC3_INFO* ncp, const NC_var *varp,
#line 973
		 const size_t *start, size_t nelems, float *value)
#line 973
{
#line 973
	off_t offset = NC_varoffset(ncp, varp, start);
#line 973
	size_t remaining = varp->xsz * nelems;
#line 973
	int status = NC_NOERR;
#line 973
	const void *xp;
#line 973

#line 973
	if(nelems == 0)
#line 973
		return NC_NOERR;
#line 973

#line 973
	assert(value != NULL);
#line 973

#line 973
	for(;;)
#line 973
	{
#line 973
		size_t extent = MIN(remaining, ncp->chunk);
#line 973
		size_t nget = ncx_howmany(varp->type, extent);
#line 973

#line 973
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 973
				 0, (void **)&xp);	/* cast away const */
#line 973
		if(lstatus != NC_NOERR)
#line 973
			return lstatus;
#line 973

#line 973
		lstatus = ncx_getn_longlong_float(&xp, nget, value);
#line 973
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 973
			status = lstatus;
#line 973

#line 973
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 973

#line 973
		remaining -= extent;
#line 973
		if(remaining == 0)
#line 973
			break; /* normal loop exit */
#line 973
		offset += extent;
#line 973
		value += nget;
#line 973
	}
#line 973

#line 973
	return status;
#line 973
}
#line 973

static int
#line 974
getNCvx_longlong_double(const NC3_INFO* ncp, const NC_var *varp,
#line 974
		 const size_t *start, size_t nelems, double *value)
#line 974
{
#line 974
	off_t offset = NC_varoffset(ncp, varp, start);
#line 974
	size_t remaining = varp->xsz * nelems;
#line 974
	int status = NC_NOERR;
#line 974
	const void *xp;
#line 974

#line 974
	if(nelems == 0)
#line 974
		return NC_NOERR;
#line 974

#line 974
	assert(value != NULL);
#line 974

#line 974
	for(;;)
#line 974
	{
#line 974
		size_t extent = MIN(remaining, ncp->chunk);
#line 974
		size_t nget = ncx_howmany(varp->type, extent);
#line 974

#line 974
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 974
				 0, (void **)&xp);	/* cast away const */
#line 974
		if(lstatus != NC_NOERR)
#line 974
			return lstatus;
#line 974

#line 974
		lstatus = ncx_getn_longlong_double(&xp, nget, value);
#line 974
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 974
			status = lstatus;
#line 974

#line 974
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 974

#line 974
		remaining -= extent;
#line 974
		if(remaining == 0)
#line 974
			break; /* normal loop exit */
#line 974
		offset += extent;
#line 974
		value += nget;
#line 974
	}
#line 974

#line 974
	return status;
#line 974
}
#line 974

static int
#line 975
getNCvx_longlong_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 975
		 const size_t *start, size_t nelems, longlong *value)
#line 975
{
#line 975
	off_t offset = NC_varoffset(ncp, varp, start);
#line 975
	size_t remaining = varp->xsz * nelems;
#line 975
	int status = NC_NOERR;
#line 975
	const void *xp;
#line 975

#line 975
	if(nelems == 0)
#line 975
		return NC_NOERR;
#line 975

#line 975
	assert(value != NULL);
#line 975

#line 975
	for(;;)
#line 975
	{
#line 975
		size_t extent = MIN(remaining, ncp->chunk);
#line 975
		size_t nget = ncx_howmany(varp->type, extent);
#line 975

#line 975
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 975
				 0, (void **)&xp);	/* cast away const */
#line 975
		if(lstatus != NC_NOERR)
#line 975
			return lstatus;
#line 975

#line 975
		lstatus = ncx_getn_longlong_longlong(&xp, nget, value);
#line 975
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 975
			status = lstatus;
#line 975

#line 975
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 975

#line 975
		remaining -= extent;
#line 975
		if(remaining == 0)
#line 975
			break; /* normal loop exit */
#line 975
		offset += extent;
#line 975
		value += nget;
#line 975
	}
#line 975

#line 975
	return status;
#line 975
}
#line 975

static int
#line 976
getNCvx_longlong_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 976
		 const size_t *start, size_t nelems, uint *value)
#line 976
{
#line 976
	off_t offset = NC_varoffset(ncp, varp, start);
#line 976
	size_t remaining = varp->xsz * nelems;
#line 976
	int status = NC_NOERR;
#line 976
	const void *xp;
#line 976

#line 976
	if(nelems == 0)
#line 976
		return NC_NOERR;
#line 976

#line 976
	assert(value != NULL);
#line 976

#line 976
	for(;;)
#line 976
	{
#line 976
		size_t extent = MIN(remaining, ncp->chunk);
#line 976
		size_t nget = ncx_howmany(varp->type, extent);
#line 976

#line 976
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 976
				 0, (void **)&xp);	/* cast away const */
#line 976
		if(lstatus != NC_NOERR)
#line 976
			return lstatus;
#line 976

#line 976
		lstatus = ncx_getn_longlong_uint(&xp, nget, value);
#line 976
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 976
			status = lstatus;
#line 976

#line 976
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 976

#line 976
		remaining -= extent;
#line 976
		if(remaining == 0)
#line 976
			break; /* normal loop exit */
#line 976
		offset += extent;
#line 976
		value += nget;
#line 976
	}
#line 976

#line 976
	return status;
#line 976
}
#line 976

static int
#line 977
getNCvx_longlong_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 977
		 const size_t *start, size_t nelems, ulonglong *value)
#line 977
{
#line 977
	off_t offset = NC_varoffset(ncp, varp, start);
#line 977
	size_t remaining = varp->xsz * nelems;
#line 977
	int status = NC_NOERR;
#line 977
	const void *xp;
#line 977

#line 977
	if(nelems == 0)
#line 977
		return NC_NOERR;
#line 977

#line 977
	assert(value != NULL);
#line 977

#line 977
	for(;;)
#line 977
	{
#line 977
		size_t extent = MIN(remaining, ncp->chunk);
#line 977
		size_t nget = ncx_howmany(varp->type, extent);
#line 977

#line 977
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 977
				 0, (void **)&xp);	/* cast away const */
#line 977
		if(lstatus != NC_NOERR)
#line 977
			return lstatus;
#line 977

#line 977
		lstatus = ncx_getn_longlong_ulonglong(&xp, nget, value);
#line 977
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 977
			status = lstatus;
#line 977

#line 977
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 977

#line 977
		remaining -= extent;
#line 977
		if(remaining == 0)
#line 977
			break; /* normal loop exit */
#line 977
		offset += extent;
#line 977
		value += nget;
#line 977
	}
#line 977

#line 977
	return status;
#line 977
}
#line 977

static int
#line 978
getNCvx_longlong_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 978
		 const size_t *start, size_t nelems, ushort *value)
#line 978
{
#line 978
	off_t offset = NC_varoffset(ncp, varp, start);
#line 978
	size_t remaining = varp->xsz * nelems;
#line 978
	int status = NC_NOERR;
#line 978
	const void *xp;
#line 978

#line 978
	if(nelems == 0)
#line 978
		return NC_NOERR;
#line 978

#line 978
	assert(value != NULL);
#line 978

#line 978
	for(;;)
#line 978
	{
#line 978
		size_t extent = MIN(remaining, ncp->chunk);
#line 978
		size_t nget = ncx_howmany(varp->type, extent);
#line 978

#line 978
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 978
				 0, (void **)&xp);	/* cast away const */
#line 978
		if(lstatus != NC_NOERR)
#line 978
			return lstatus;
#line 978

#line 978
		lstatus = ncx_getn_longlong_ushort(&xp, nget, value);
#line 978
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 978
			status = lstatus;
#line 978

#line 978
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 978

#line 978
		remaining -= extent;
#line 978
		if(remaining == 0)
#line 978
			break; /* normal loop exit */
#line 978
		offset += extent;
#line 978
		value += nget;
#line 978
	}
#line 978

#line 978
	return status;
#line 978
}
#line 978


static int
#line 980
getNCvx_ulonglong_schar(const NC3_INFO* ncp, const NC_var *varp,
#line 980
		 const size_t *start, size_t nelems, schar *value)
#line 980
{
#line 980
	off_t offset = NC_varoffset(ncp, varp, start);
#line 980
	size_t remaining = varp->xsz * nelems;
#line 980
	int status = NC_NOERR;
#line 980
	const void *xp;
#line 980

#line 980
	if(nelems == 0)
#line 980
		return NC_NOERR;
#line 980

#line 980
	assert(value != NULL);
#line 980

#line 980
	for(;;)
#line 980
	{
#line 980
		size_t extent = MIN(remaining, ncp->chunk);
#line 980
		size_t nget = ncx_howmany(varp->type, extent);
#line 980

#line 980
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 980
				 0, (void **)&xp);	/* cast away const */
#line 980
		if(lstatus != NC_NOERR)
#line 980
			return lstatus;
#line 980

#line 980
		lstatus = ncx_getn_ulonglong_schar(&xp, nget, value);
#line 980
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 980
			status = lstatus;
#line 980

#line 980
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 980

#line 980
		remaining -= extent;
#line 980
		if(remaining == 0)
#line 980
			break; /* normal loop exit */
#line 980
		offset += extent;
#line 980
		value += nget;
#line 980
	}
#line 980

#line 980
	return status;
#line 980
}
#line 980

static int
#line 981
getNCvx_ulonglong_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 981
		 const size_t *start, size_t nelems, uchar *value)
#line 981
{
#line 981
	off_t offset = NC_varoffset(ncp, varp, start);
#line 981
	size_t remaining = varp->xsz * nelems;
#line 981
	int status = NC_NOERR;
#line 981
	const void *xp;
#line 981

#line 981
	if(nelems == 0)
#line 981
		return NC_NOERR;
#line 981

#line 981
	assert(value != NULL);
#line 981

#line 981
	for(;;)
#line 981
	{
#line 981
		size_t extent = MIN(remaining, ncp->chunk);
#line 981
		size_t nget = ncx_howmany(varp->type, extent);
#line 981

#line 981
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 981
				 0, (void **)&xp);	/* cast away const */
#line 981
		if(lstatus != NC_NOERR)
#line 981
			return lstatus;
#line 981

#line 981
		lstatus = ncx_getn_ulonglong_uchar(&xp, nget, value);
#line 981
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 981
			status = lstatus;
#line 981

#line 981
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 981

#line 981
		remaining -= extent;
#line 981
		if(remaining == 0)
#line 981
			break; /* normal loop exit */
#line 981
		offset += extent;
#line 981
		value += nget;
#line 981
	}
#line 981

#line 981
	return status;
#line 981
}
#line 981

static int
#line 982
getNCvx_ulonglong_short(const NC3_INFO* ncp, const NC_var *varp,
#line 982
		 const size_t *start, size_t nelems, short *value)
#line 982
{
#line 982
	off_t offset = NC_varoffset(ncp, varp, start);
#line 982
	size_t remaining = varp->xsz * nelems;
#line 982
	int status = NC_NOERR;
#line 982
	const void *xp;
#line 982

#line 982
	if(nelems == 0)
#line 982
		return NC_NOERR;
#line 982

#line 982
	assert(value != NULL);
#line 982

#line 982
	for(;;)
#line 982
	{
#line 982
		size_t extent = MIN(remaining, ncp->chunk);
#line 982
		size_t nget = ncx_howmany(varp->type, extent);
#line 982

#line 982
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 982
				 0, (void **)&xp);	/* cast away const */
#line 982
		if(lstatus != NC_NOERR)
#line 982
			return lstatus;
#line 982

#line 982
		lstatus = ncx_getn_ulonglong_short(&xp, nget, value);
#line 982
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 982
			status = lstatus;
#line 982

#line 982
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 982

#line 982
		remaining -= extent;
#line 982
		if(remaining == 0)
#line 982
			break; /* normal loop exit */
#line 982
		offset += extent;
#line 982
		value += nget;
#line 982
	}
#line 982

#line 982
	return status;
#line 982
}
#line 982

static int
#line 983
getNCvx_ulonglong_int(const NC3_INFO* ncp, const NC_var *varp,
#line 983
		 const size_t *start, size_t nelems, int *value)
#line 983
{
#line 983
	off_t offset = NC_varoffset(ncp, varp, start);
#line 983
	size_t remaining = varp->xsz * nelems;
#line 983
	int status = NC_NOERR;
#line 983
	const void *xp;
#line 983

#line 983
	if(nelems == 0)
#line 983
		return NC_NOERR;
#line 983

#line 983
	assert(value != NULL);
#line 983

#line 983
	for(;;)
#line 983
	{
#line 983
		size_t extent = MIN(remaining, ncp->chunk);
#line 983
		size_t nget = ncx_howmany(varp->type, extent);
#line 983

#line 983
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 983
				 0, (void **)&xp);	/* cast away const */
#line 983
		if(lstatus != NC_NOERR)
#line 983
			return lstatus;
#line 983

#line 983
		lstatus = ncx_getn_ulonglong_int(&xp, nget, value);
#line 983
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 983
			status = lstatus;
#line 983

#line 983
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 983

#line 983
		remaining -= extent;
#line 983
		if(remaining == 0)
#line 983
			break; /* normal loop exit */
#line 983
		offset += extent;
#line 983
		value += nget;
#line 983
	}
#line 983

#line 983
	return status;
#line 983
}
#line 983

static int
#line 984
getNCvx_ulonglong_float(const NC3_INFO* ncp, const NC_var *varp,
#line 984
		 const size_t *start, size_t nelems, float *value)
#line 984
{
#line 984
	off_t offset = NC_varoffset(ncp, varp, start);
#line 984
	size_t remaining = varp->xsz * nelems;
#line 984
	int status = NC_NOERR;
#line 984
	const void *xp;
#line 984

#line 984
	if(nelems == 0)
#line 984
		return NC_NOERR;
#line 984

#line 984
	assert(value != NULL);
#line 984

#line 984
	for(;;)
#line 984
	{
#line 984
		size_t extent = MIN(remaining, ncp->chunk);
#line 984
		size_t nget = ncx_howmany(varp->type, extent);
#line 984

#line 984
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 984
				 0, (void **)&xp);	/* cast away const */
#line 984
		if(lstatus != NC_NOERR)
#line 984
			return lstatus;
#line 984

#line 984
		lstatus = ncx_getn_ulonglong_float(&xp, nget, value);
#line 984
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 984
			status = lstatus;
#line 984

#line 984
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 984

#line 984
		remaining -= extent;
#line 984
		if(remaining == 0)
#line 984
			break; /* normal loop exit */
#line 984
		offset += extent;
#line 984
		value += nget;
#line 984
	}
#line 984

#line 984
	return status;
#line 984
}
#line 984

static int
#line 985
getNCvx_ulonglong_double(const NC3_INFO* ncp, const NC_var *varp,
#line 985
		 const size_t *start, size_t nelems, double *value)
#line 985
{
#line 985
	off_t offset = NC_varoffset(ncp, varp, start);
#line 985
	size_t remaining = varp->xsz * nelems;
#line 985
	int status = NC_NOERR;
#line 985
	const void *xp;
#line 985

#line 985
	if(nelems == 0)
#line 985
		return NC_NOERR;
#line 985

#line 985
	assert(value != NULL);
#line 985

#line 985
	for(;;)
#line 985
	{
#line 985
		size_t extent = MIN(remaining, ncp->chunk);
#line 985
		size_t nget = ncx_howmany(varp->type, extent);
#line 985

#line 985
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 985
				 0, (void **)&xp);	/* cast away const */
#line 985
		if(lstatus != NC_NOERR)
#line 985
			return lstatus;
#line 985

#line 985
		lstatus = ncx_getn_ulonglong_double(&xp, nget, value);
#line 985
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 985
			status = lstatus;
#line 985

#line 985
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 985

#line 985
		remaining -= extent;
#line 985
		if(remaining == 0)
#line 985
			break; /* normal loop exit */
#line 985
		offset += extent;
#line 985
		value += nget;
#line 985
	}
#line 985

#line 985
	return status;
#line 985
}
#line 985

static int
#line 986
getNCvx_ulonglong_longlong(const NC3_INFO* ncp, const NC_var *varp,
#line 986
		 const size_t *start, size_t nelems, longlong *value)
#line 986
{
#line 986
	off_t offset = NC_varoffset(ncp, varp, start);
#line 986
	size_t remaining = varp->xsz * nelems;
#line 986
	int status = NC_NOERR;
#line 986
	const void *xp;
#line 986

#line 986
	if(nelems == 0)
#line 986
		return NC_NOERR;
#line 986

#line 986
	assert(value != NULL);
#line 986

#line 986
	for(;;)
#line 986
	{
#line 986
		size_t extent = MIN(remaining, ncp->chunk);
#line 986
		size_t nget = ncx_howmany(varp->type, extent);
#line 986

#line 986
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 986
				 0, (void **)&xp);	/* cast away const */
#line 986
		if(lstatus != NC_NOERR)
#line 986
			return lstatus;
#line 986

#line 986
		lstatus = ncx_getn_ulonglong_longlong(&xp, nget, value);
#line 986
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 986
			status = lstatus;
#line 986

#line 986
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 986

#line 986
		remaining -= extent;
#line 986
		if(remaining == 0)
#line 986
			break; /* normal loop exit */
#line 986
		offset += extent;
#line 986
		value += nget;
#line 986
	}
#line 986

#line 986
	return status;
#line 986
}
#line 986

static int
#line 987
getNCvx_ulonglong_uint(const NC3_INFO* ncp, const NC_var *varp,
#line 987
		 const size_t *start, size_t nelems, uint *value)
#line 987
{
#line 987
	off_t offset = NC_varoffset(ncp, varp, start);
#line 987
	size_t remaining = varp->xsz * nelems;
#line 987
	int status = NC_NOERR;
#line 987
	const void *xp;
#line 987

#line 987
	if(nelems == 0)
#line 987
		return NC_NOERR;
#line 987

#line 987
	assert(value != NULL);
#line 987

#line 987
	for(;;)
#line 987
	{
#line 987
		size_t extent = MIN(remaining, ncp->chunk);
#line 987
		size_t nget = ncx_howmany(varp->type, extent);
#line 987

#line 987
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 987
				 0, (void **)&xp);	/* cast away const */
#line 987
		if(lstatus != NC_NOERR)
#line 987
			return lstatus;
#line 987

#line 987
		lstatus = ncx_getn_ulonglong_uint(&xp, nget, value);
#line 987
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 987
			status = lstatus;
#line 987

#line 987
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 987

#line 987
		remaining -= extent;
#line 987
		if(remaining == 0)
#line 987
			break; /* normal loop exit */
#line 987
		offset += extent;
#line 987
		value += nget;
#line 987
	}
#line 987

#line 987
	return status;
#line 987
}
#line 987

static int
#line 988
getNCvx_ulonglong_ulonglong(const NC3_INFO* ncp, const NC_var *varp,
#line 988
		 const size_t *start, size_t nelems, ulonglong *value)
#line 988
{
#line 988
	off_t offset = NC_varoffset(ncp, varp, start);
#line 988
	size_t remaining = varp->xsz * nelems;
#line 988
	int status = NC_NOERR;
#line 988
	const void *xp;
#line 988

#line 988
	if(nelems == 0)
#line 988
		return NC_NOERR;
#line 988

#line 988
	assert(value != NULL);
#line 988

#line 988
	for(;;)
#line 988
	{
#line 988
		size_t extent = MIN(remaining, ncp->chunk);
#line 988
		size_t nget = ncx_howmany(varp->type, extent);
#line 988

#line 988
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 988
				 0, (void **)&xp);	/* cast away const */
#line 988
		if(lstatus != NC_NOERR)
#line 988
			return lstatus;
#line 988

#line 988
		lstatus = ncx_getn_ulonglong_ulonglong(&xp, nget, value);
#line 988
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 988
			status = lstatus;
#line 988

#line 988
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 988

#line 988
		remaining -= extent;
#line 988
		if(remaining == 0)
#line 988
			break; /* normal loop exit */
#line 988
		offset += extent;
#line 988
		value += nget;
#line 988
	}
#line 988

#line 988
	return status;
#line 988
}
#line 988

static int
#line 989
getNCvx_ulonglong_ushort(const NC3_INFO* ncp, const NC_var *varp,
#line 989
		 const size_t *start, size_t nelems, ushort *value)
#line 989
{
#line 989
	off_t offset = NC_varoffset(ncp, varp, start);
#line 989
	size_t remaining = varp->xsz * nelems;
#line 989
	int status = NC_NOERR;
#line 989
	const void *xp;
#line 989

#line 989
	if(nelems == 0)
#line 989
		return NC_NOERR;
#line 989

#line 989
	assert(value != NULL);
#line 989

#line 989
	for(;;)
#line 989
	{
#line 989
		size_t extent = MIN(remaining, ncp->chunk);
#line 989
		size_t nget = ncx_howmany(varp->type, extent);
#line 989

#line 989
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 989
				 0, (void **)&xp);	/* cast away const */
#line 989
		if(lstatus != NC_NOERR)
#line 989
			return lstatus;
#line 989

#line 989
		lstatus = ncx_getn_ulonglong_ushort(&xp, nget, value);
#line 989
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 989
			status = lstatus;
#line 989

#line 989
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 989

#line 989
		remaining -= extent;
#line 989
		if(remaining == 0)
#line 989
			break; /* normal loop exit */
#line 989
		offset += extent;
#line 989
		value += nget;
#line 989
	}
#line 989

#line 989
	return status;
#line 989
}
#line 989


#line 992
#ifdef NOTUSED
static int
#line 993
getNCvx_schar_uchar(const NC3_INFO* ncp, const NC_var *varp,
#line 993
		 const size_t *start, size_t nelems, uchar *value)
#line 993
{
#line 993
	off_t offset = NC_varoffset(ncp, varp, start);
#line 993
	size_t remaining = varp->xsz * nelems;
#line 993
	int status = NC_NOERR;
#line 993
	const void *xp;
#line 993

#line 993
	if(nelems == 0)
#line 993
		return NC_NOERR;
#line 993

#line 993
	assert(value != NULL);
#line 993

#line 993
	for(;;)
#line 993
	{
#line 993
		size_t extent = MIN(remaining, ncp->chunk);
#line 993
		size_t nget = ncx_howmany(varp->type, extent);
#line 993

#line 993
		int lstatus = ncio_get(ncp->nciop, offset, extent,
#line 993
				 0, (void **)&xp);	/* cast away const */
#line 993
		if(lstatus != NC_NOERR)
#line 993
			return lstatus;
#line 993

#line 993
		lstatus = ncx_getn_schar_uchar(&xp, nget, value);
#line 993
		if(lstatus != NC_NOERR && status == NC_NOERR)
#line 993
			status = lstatus;
#line 993

#line 993
		(void) ncio_rel(ncp->nciop, offset, 0);
#line 993

#line 993
		remaining -= extent;
#line 993
		if(remaining == 0)
#line 993
			break; /* normal loop exit */
#line 993
		offset += extent;
#line 993
		value += nget;
#line 993
	}
#line 993

#line 993
	return status;
#line 993
}
#line 993

#endif /*NOTUSED*/

/*
 *  For ncvar{put,get},
 *  find the largest contiguous block from within 'edges'.
 *  returns the index to the left of this (which may be -1).
 *  Compute the number of contiguous elements and return
 *  that in *iocountp.
 *  The presence of "record" variables makes this routine
 *  overly subtle.
 */
static int
NCiocount(const NC3_INFO* const ncp, const NC_var *const varp,
	const size_t *const edges,
	size_t *const iocountp)
{
	const size_t *edp0 = edges;
	const size_t *edp = edges + varp->ndims;
	const size_t *shp = varp->shape + varp->ndims;

	if(IS_RECVAR(varp))
	{
		if(varp->ndims == 1 && ncp->recsize <= varp->len)
		{
			/* one dimensional && the only 'record' variable */
			*iocountp = *edges;
			return(0);
		}
		/* else */
		edp0++;
	}

	assert(edges != NULL);

	/* find max contiguous */
	while(edp > edp0)
	{
		shp--; edp--;
		if(*edp < *shp )
		{
			const size_t *zedp = edp;
			while(zedp >= edp0)
			{
				if(*zedp == 0)
				{
					*iocountp = 0;
					goto done;
				}
				/* Tip of the hat to segmented architectures */
				if(zedp == edp0)
					break;
				zedp--;
			}
			break;
		}
		assert(*edp == *shp);
	}

	/*
	 * edp, shp reference rightmost index s.t. *(edp +1) == *(shp +1)
	 *
	 * Or there is only one dimension.
	 * If there is only one dimension and it is 'non record' dimension,
	 * 	edp is &edges[0] and we will return -1.
	 * If there is only one dimension and and it is a "record dimension",
	 *	edp is &edges[1] (out of bounds) and we will return 0;
	 */
	assert(shp >= varp->shape + varp->ndims -1
		|| *(edp +1) == *(shp +1));

	/* now accumulate max count for a single io operation */
	for(*iocountp = 1, edp0 = edp;
		 	edp0 < edges + varp->ndims;
			edp0++)
	{
		*iocountp *= *edp0;
	}

done:
	return((int)(edp - edges) - 1);
}


/*
 * Set the elements of the array 'upp' to
 * the sum of the corresponding elements of
 * 'stp' and 'edp'. 'end' should be &stp[nelems].
 */
static void
set_upper(size_t *upp, /* modified on return */
	const size_t *stp,
	const size_t *edp,
	const size_t *const end)
{
	while(upp < end) {
		*upp++ = *stp++ + *edp++;
	}
}


/*
 * The infamous and oft-discussed odometer code.
 *
 * 'start[]' is the starting coordinate.
 * 'upper[]' is the upper bound s.t. start[ii] < upper[ii].
 * 'coord[]' is the register, the current coordinate value.
 * For some ii,
 * upp == &upper[ii]
 * cdp == &coord[ii]
 *
 * Running this routine increments *cdp.
 *
 * If after the increment, *cdp is equal to *upp
 * (and cdp is not the leftmost dimension),
 * *cdp is "zeroed" to the starting value and
 * we need to "carry", eg, increment one place to
 * the left.
 *
 * TODO: Some architectures hate recursion?
 * 	Reimplement non-recursively.
 */
static void
odo1(const size_t *const start, const size_t *const upper,
	size_t *const coord, /* modified on return */
	const size_t *upp,
	size_t *cdp)
{
	assert(coord <= cdp && cdp <= coord + NC_MAX_VAR_DIMS);
	assert(upper <= upp && upp <= upper + NC_MAX_VAR_DIMS);
	assert(upp - upper == cdp - coord);

	assert(*cdp <= *upp);

	(*cdp)++;
	if(cdp != coord && *cdp >= *upp)
	{
		*cdp = start[cdp - coord];
		odo1(start, upper, coord, upp -1, cdp -1);
	}
}
#ifdef _CRAYC
#pragma _CRI noinline odo1
#endif


#line 1155

/* Define a macro to allow hash on two type values */
#define CASE(nc1,nc2) (nc1*256+nc2)

static int
readNCv(const NC3_INFO* ncp, const NC_var* varp, const size_t* start,
        const size_t nelems, void* value, const nc_type memtype)
{
    int status = NC_NOERR;
    switch (CASE(varp->type,memtype)) {

    case CASE(NC_CHAR,NC_CHAR):
    case CASE(NC_CHAR,NC_UBYTE):
#ifndef __CHAR_UNSIGNED__
       return getNCvx_char_char(ncp,varp,start,nelems,(char*)value);
#else
    return getNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
#endif
    break;
    case CASE(NC_BYTE,NC_BYTE):
        return getNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_BYTE,NC_UBYTE):
        return getNCvx_schar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_BYTE,NC_SHORT):
        return getNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_BYTE,NC_INT):
        return getNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_BYTE,NC_FLOAT):
        return getNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_BYTE,NC_DOUBLE):
        return getNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_BYTE,NC_INT64):
        return getNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_BYTE,NC_UINT):
        return getNCvx_schar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_BYTE,NC_UINT64):
        return getNCvx_schar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
    	break;
    case CASE(NC_BYTE,NC_USHORT):
        return getNCvx_schar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_SHORT,NC_BYTE):
        return getNCvx_short_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_SHORT,NC_UBYTE):
        return getNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_SHORT,NC_SHORT):
        return getNCvx_short_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_SHORT,NC_INT):
        return getNCvx_short_int(ncp,varp,start,nelems,(int*)value);
	break;
   case CASE(NC_SHORT,NC_FLOAT):
        return getNCvx_short_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_SHORT,NC_DOUBLE):
        return getNCvx_short_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_SHORT,NC_INT64):
        return getNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
   	break;
    case CASE(NC_SHORT,NC_UINT):
        return getNCvx_short_uint(ncp,varp,start,nelems,(unsigned int*)value);
    	break;
    case CASE(NC_SHORT,NC_UINT64):
        return getNCvx_short_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_SHORT,NC_USHORT):
        return getNCvx_short_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_INT,NC_BYTE):
        return getNCvx_int_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_INT,NC_UBYTE):
        return getNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT,NC_SHORT):
        return getNCvx_int_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT,NC_INT):
        return getNCvx_int_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT,NC_FLOAT):
        return getNCvx_int_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT,NC_DOUBLE):
        return getNCvx_int_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT,NC_INT64):
        return getNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT,NC_UINT):
        return getNCvx_int_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT,NC_UINT64):
        return getNCvx_int_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT,NC_USHORT):
        return getNCvx_int_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_FLOAT,NC_BYTE):
        return getNCvx_float_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_FLOAT,NC_UBYTE):
        return getNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_FLOAT,NC_SHORT):
        return getNCvx_float_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_FLOAT,NC_INT):
        return getNCvx_float_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_FLOAT,NC_FLOAT):
        return getNCvx_float_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_FLOAT,NC_DOUBLE):
        return getNCvx_float_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_FLOAT,NC_INT64):
        return getNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT):
        return getNCvx_float_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT64):
        return getNCvx_float_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_FLOAT,NC_USHORT):
        return getNCvx_float_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_DOUBLE,NC_BYTE):
        return getNCvx_double_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_DOUBLE,NC_UBYTE):
        return getNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_DOUBLE,NC_SHORT):
        return getNCvx_double_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT):
        return getNCvx_double_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_DOUBLE,NC_FLOAT):
        return getNCvx_double_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_DOUBLE,NC_DOUBLE):
        return getNCvx_double_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT64):
        return getNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT):
        return getNCvx_double_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT64):
        return getNCvx_double_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_USHORT):
        return getNCvx_double_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_UBYTE,NC_UBYTE):
        return getNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UBYTE,NC_BYTE):
        return getNCvx_uchar_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_UBYTE,NC_SHORT):
        return getNCvx_uchar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UBYTE,NC_INT):
        return getNCvx_uchar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UBYTE,NC_FLOAT):
        return getNCvx_uchar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UBYTE,NC_DOUBLE):
        return getNCvx_uchar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_UBYTE,NC_INT64):
        return getNCvx_uchar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT):
        return getNCvx_uchar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT64):
        return getNCvx_uchar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UBYTE,NC_USHORT):
        return getNCvx_uchar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_USHORT,NC_BYTE):
        return getNCvx_ushort_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_USHORT,NC_UBYTE):
        return getNCvx_ushort_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_USHORT,NC_SHORT):
        return getNCvx_ushort_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_USHORT,NC_INT):
        return getNCvx_ushort_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_USHORT,NC_FLOAT):
        return getNCvx_ushort_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_USHORT,NC_DOUBLE):
        return getNCvx_ushort_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_USHORT,NC_INT64):
        return getNCvx_ushort_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_USHORT,NC_UINT):
        return getNCvx_ushort_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_USHORT,NC_UINT64):
        return getNCvx_ushort_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_USHORT,NC_USHORT):
        return getNCvx_ushort_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_UINT,NC_BYTE):
        return getNCvx_uint_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_UINT,NC_UBYTE):
        return getNCvx_uint_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT,NC_SHORT):
        return getNCvx_uint_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT,NC_INT):
        return getNCvx_uint_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT,NC_FLOAT):
        return getNCvx_uint_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT,NC_DOUBLE):
        return getNCvx_uint_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT,NC_INT64):
        return getNCvx_uint_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT,NC_UINT):
        return getNCvx_uint_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT,NC_UINT64):
        return getNCvx_uint_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT,NC_USHORT):
        return getNCvx_uint_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_INT64,NC_BYTE):
        return getNCvx_longlong_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_INT64,NC_UBYTE):
        return getNCvx_longlong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT64,NC_SHORT):
        return getNCvx_longlong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT64,NC_INT):
        return getNCvx_longlong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT64,NC_FLOAT):
        return getNCvx_longlong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT64,NC_DOUBLE):
        return getNCvx_longlong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT64,NC_INT64):
        return getNCvx_longlong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT64,NC_UINT):
        return getNCvx_longlong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT64,NC_UINT64):
        return getNCvx_longlong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT64,NC_USHORT):
        return getNCvx_longlong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    case CASE(NC_UINT64,NC_BYTE):
        return getNCvx_ulonglong_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_UINT64,NC_UBYTE):
        return getNCvx_ulonglong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT64,NC_SHORT):
        return getNCvx_ulonglong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT64,NC_INT):
        return getNCvx_ulonglong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT64,NC_FLOAT):
        return getNCvx_ulonglong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT64,NC_DOUBLE):
        return getNCvx_ulonglong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT64,NC_INT64):
        return getNCvx_ulonglong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT64,NC_UINT):
        return getNCvx_ulonglong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT64,NC_UINT64):
        return getNCvx_ulonglong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT64,NC_USHORT):
        return getNCvx_ulonglong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    default:
	return NC_EBADTYPE;
	break;
    }
    return status;
}


static int
writeNCv(NC3_INFO* ncp, const NC_var* varp, const size_t* start,
         const size_t nelems, const void* value, const nc_type memtype)
{
    int status = NC_NOERR;
    switch (CASE(varp->type,memtype)) {

    case CASE(NC_CHAR,NC_CHAR):
    case CASE(NC_CHAR,NC_UBYTE):
        return putNCvx_char_char(ncp,varp,start,nelems,(char*)value);
	break;
    case CASE(NC_BYTE,NC_BYTE):
        return putNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_BYTE,NC_UBYTE):
        return putNCvx_schar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_BYTE,NC_SHORT):
        return putNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_BYTE,NC_INT):
        return putNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_BYTE,NC_FLOAT):
        return putNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_BYTE,NC_DOUBLE):
        return putNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_BYTE,NC_INT64):
        return putNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_BYTE,NC_UINT):
        return putNCvx_schar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_BYTE,NC_UINT64):
        return putNCvx_schar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_BYTE,NC_USHORT):
        return putNCvx_schar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_SHORT,NC_BYTE):
        return putNCvx_short_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_SHORT,NC_UBYTE):
        return putNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_SHORT,NC_SHORT):
        return putNCvx_short_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_SHORT,NC_INT):
        return putNCvx_short_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_SHORT,NC_FLOAT):
        return putNCvx_short_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_SHORT,NC_DOUBLE):
        return putNCvx_short_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_SHORT,NC_INT64):
        return putNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_SHORT,NC_UINT):
        return putNCvx_short_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_SHORT,NC_UINT64):
        return putNCvx_short_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_SHORT,NC_USHORT):
        return putNCvx_short_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_INT,NC_BYTE):
        return putNCvx_int_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_INT,NC_UBYTE):
        return putNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT,NC_SHORT):
        return putNCvx_int_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT,NC_INT):
        return putNCvx_int_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT,NC_FLOAT):
        return putNCvx_int_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT,NC_DOUBLE):
        return putNCvx_int_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT,NC_INT64):
        return putNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT,NC_UINT):
        return putNCvx_int_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT,NC_UINT64):
        return putNCvx_int_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT,NC_USHORT):
        return putNCvx_int_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_FLOAT,NC_BYTE):
        return putNCvx_float_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_FLOAT,NC_UBYTE):
        return putNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_FLOAT,NC_SHORT):
        return putNCvx_float_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_FLOAT,NC_INT):
        return putNCvx_float_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_FLOAT,NC_FLOAT):
        return putNCvx_float_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_FLOAT,NC_DOUBLE):
        return putNCvx_float_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_FLOAT,NC_INT64):
        return putNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT):
        return putNCvx_float_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_FLOAT,NC_UINT64):
        return putNCvx_float_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_FLOAT,NC_USHORT):
        return putNCvx_float_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_DOUBLE,NC_BYTE):
        return putNCvx_double_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_DOUBLE,NC_UBYTE):
        return putNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_DOUBLE,NC_SHORT):
        return putNCvx_double_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT):
        return putNCvx_double_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_DOUBLE,NC_FLOAT):
        return putNCvx_double_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_DOUBLE,NC_DOUBLE):
        return putNCvx_double_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_DOUBLE,NC_INT64):
        return putNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT):
        return putNCvx_double_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_DOUBLE,NC_UINT64):
        return putNCvx_double_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_DOUBLE,NC_USHORT):
        return putNCvx_double_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_UBYTE,NC_UBYTE):
        return putNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UBYTE,NC_BYTE):
        return putNCvx_uchar_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_UBYTE,NC_SHORT):
        return putNCvx_uchar_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UBYTE,NC_INT):
        return putNCvx_uchar_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UBYTE,NC_FLOAT):
        return putNCvx_uchar_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UBYTE,NC_DOUBLE):
        return putNCvx_uchar_double(ncp,varp,start,nelems,(double *)value);
	break;
    case CASE(NC_UBYTE,NC_INT64):
        return putNCvx_uchar_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT):
        return putNCvx_uchar_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UBYTE,NC_UINT64):
        return putNCvx_uchar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UBYTE,NC_USHORT):
        return putNCvx_uchar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_USHORT,NC_BYTE):
        return putNCvx_ushort_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_USHORT,NC_UBYTE):
        return putNCvx_ushort_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_USHORT,NC_SHORT):
        return putNCvx_ushort_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_USHORT,NC_INT):
        return putNCvx_ushort_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_USHORT,NC_FLOAT):
        return putNCvx_ushort_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_USHORT,NC_DOUBLE):
        return putNCvx_ushort_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_USHORT,NC_INT64):
        return putNCvx_ushort_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_USHORT,NC_UINT):
        return putNCvx_ushort_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_USHORT,NC_UINT64):
        return putNCvx_ushort_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_USHORT,NC_USHORT):
        return putNCvx_ushort_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_UINT,NC_BYTE):
        return putNCvx_uint_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_UINT,NC_UBYTE):
        return putNCvx_uint_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT,NC_SHORT):
        return putNCvx_uint_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT,NC_INT):
        return putNCvx_uint_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT,NC_FLOAT):
        return putNCvx_uint_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT,NC_DOUBLE):
        return putNCvx_uint_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT,NC_INT64):
        return putNCvx_uint_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT,NC_UINT):
        return putNCvx_uint_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT,NC_UINT64):
        return putNCvx_uint_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT,NC_USHORT):
        return putNCvx_uint_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_INT64,NC_BYTE):
        return putNCvx_longlong_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_INT64,NC_UBYTE):
        return putNCvx_longlong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_INT64,NC_SHORT):
        return putNCvx_longlong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_INT64,NC_INT):
        return putNCvx_longlong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_INT64,NC_FLOAT):
        return putNCvx_longlong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_INT64,NC_DOUBLE):
        return putNCvx_longlong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_INT64,NC_INT64):
        return putNCvx_longlong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_INT64,NC_UINT):
        return putNCvx_longlong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_INT64,NC_UINT64):
        return putNCvx_longlong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_INT64,NC_USHORT):
        return putNCvx_longlong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;
    case CASE(NC_UINT64,NC_BYTE):
        return putNCvx_ulonglong_schar(ncp,varp,start,nelems,(signed char*)value);
	break;
    case CASE(NC_UINT64,NC_UBYTE):
        return putNCvx_ulonglong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
	break;
    case CASE(NC_UINT64,NC_SHORT):
        return putNCvx_ulonglong_short(ncp,varp,start,nelems,(short*)value);
	break;
    case CASE(NC_UINT64,NC_INT):
        return putNCvx_ulonglong_int(ncp,varp,start,nelems,(int*)value);
	break;
    case CASE(NC_UINT64,NC_FLOAT):
        return putNCvx_ulonglong_float(ncp,varp,start,nelems,(float*)value);
	break;
    case CASE(NC_UINT64,NC_DOUBLE):
        return putNCvx_ulonglong_double(ncp,varp,start,nelems,(double*)value);
	break;
    case CASE(NC_UINT64,NC_INT64):
        return putNCvx_ulonglong_longlong(ncp,varp,start,nelems,(long long*)value);
	break;
    case CASE(NC_UINT64,NC_UINT):
        return putNCvx_ulonglong_uint(ncp,varp,start,nelems,(unsigned int*)value);
	break;
    case CASE(NC_UINT64,NC_UINT64):
        return putNCvx_ulonglong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
	break;
    case CASE(NC_UINT64,NC_USHORT):
        return putNCvx_ulonglong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
	break;

    default:
	return NC_EBADTYPE;
	break;
    }
    return status;
}

/**************************************************/

int
NC3_get_vara(int ncid, int varid,
	    const size_t *start, const size_t *edges0,
            void *value0,
	    nc_type memtype)
{
    int status = NC_NOERR;
    NC* nc;
    NC3_INFO* nc3;
    NC_var *varp;
    int ii;
    size_t iocount;
    size_t memtypelen;
    signed char* value = (signed char*) value0; /* legally allow ptr arithmetic */
    const size_t* edges = edges0; /* so we can modify for special cases */
    size_t modedges[NC_MAX_VAR_DIMS];

    status = NC_check_id(ncid, &nc);
    if(status != NC_NOERR)
        return status;
    nc3 = NC3_DATA(nc);

    if(NC_indef(nc3))
        return NC_EINDEFINE;

    status = NC_lookupvar(nc3, varid, &varp);
    if(status != NC_NOERR)
        return status;

    if(memtype == NC_NAT) memtype=varp->type;

    if(memtype == NC_CHAR && varp->type != NC_CHAR)
        return NC_ECHAR;
    else if(memtype != NC_CHAR && varp->type == NC_CHAR)
        return NC_ECHAR;

    /* If edges is NULL, then this was called from nc_get_var() */
    if(edges == NULL && varp->ndims > 0) {
	/* If this is a record variable, then we have to
           substitute the number of records into dimension 0. */
	if(varp->shape[0] == 0) {
	    (void)memcpy((void*)modedges,(void*)varp->shape,
                          sizeof(size_t)*varp->ndims);
	    modedges[0] = NC_get_numrecs(nc3);
	    edges = modedges;
	} else
	    edges = varp->shape;
    }

    status = NCcoordck(nc3, varp, start);
    if(status != NC_NOERR)
        return status;

    status = NCedgeck(nc3, varp, start, edges);
    if(status != NC_NOERR)
        return status;

    /* Get the size of the memtype */
    memtypelen = nctypelen(memtype);

    if(varp->ndims == 0) /* scalar variable */
    {
        return( readNCv(nc3, varp, start, 1, (void*)value, memtype) );
    }

    if(IS_RECVAR(varp))
    {
        if(*start + *edges > NC_get_numrecs(nc3))
            return NC_EEDGE;
        if(varp->ndims == 1 && nc3->recsize <= varp->len)
        {
            /* one dimensional && the only record variable  */
            return( readNCv(nc3, varp, start, *edges, (void*)value, memtype) );
        }
    }

    /*
     * find max contiguous
     *   and accumulate max count for a single io operation
     */
    ii = NCiocount(nc3, varp, edges, &iocount);

    if(ii == -1)
    {
        return( readNCv(nc3, varp, start, iocount, (void*)value, memtype) );
    }

    assert(ii >= 0);

    { /* inline */
    ALLOC_ONSTACK(coord, size_t, varp->ndims);
    ALLOC_ONSTACK(upper, size_t, varp->ndims);
    const size_t index = ii;

    /* copy in starting indices */
    (void) memcpy(coord, start, varp->ndims * sizeof(size_t));

    /* set up in maximum indices */
    set_upper(upper, start, edges, &upper[varp->ndims]);

    /* ripple counter */
    while(*coord < *upper)
    {
        const int lstatus = readNCv(nc3, varp, coord, iocount, (void*)value, memtype);
	if(lstatus != NC_NOERR)
        {
            if(lstatus != NC_ERANGE)
            {
                status = lstatus;
                /* fatal for the loop */
                break;
            }
            /* else NC_ERANGE, not fatal for the loop */
            if(status == NC_NOERR)
                status = lstatus;
        }
        value += (iocount * memtypelen);
        odo1(start, upper, coord, &upper[index], &coord[index]);
    }

    FREE_ONSTACK(upper);
    FREE_ONSTACK(coord);
    } /* end inline */

    return status;
}

int
NC3_put_vara(int ncid, int varid,
	    const size_t *start, const size_t *edges0,
            const void *value0,
	    nc_type memtype)
{
    int status = NC_NOERR;
    NC *nc;
    NC3_INFO* nc3;
    NC_var *varp;
    int ii;
    size_t iocount;
    size_t memtypelen;
    signed char* value = (signed char*) value0; /* legally allow ptr arithmetic */
    const size_t* edges = edges0; /* so we can modify for special cases */
    size_t modedges[NC_MAX_VAR_DIMS];

    status = NC_check_id(ncid, &nc);
    if(status != NC_NOERR)
        return status;
    nc3 = NC3_DATA(nc);

    if(NC_readonly(nc3))
        return NC_EPERM;

    if(NC_indef(nc3))
        return NC_EINDEFINE;

    status = NC_lookupvar(nc3, varid, &varp);
    if(status != NC_NOERR)
       return status; /*invalid varid */


    if(memtype == NC_NAT) memtype=varp->type;

    if(memtype == NC_CHAR && varp->type != NC_CHAR)
        return NC_ECHAR;
    else if(memtype != NC_CHAR && varp->type == NC_CHAR)
        return NC_ECHAR;

    /* Get the size of the memtype */
    memtypelen = nctypelen(memtype);

    /* If edges is NULL, then this was called from nc_get_var() */
    if(edges == NULL && varp->ndims > 0) {
	/* If this is a record variable, then we have to
           substitute the number of records into dimension 0. */
	if(varp->shape[0] == 0) {
	    (void)memcpy((void*)modedges,(void*)varp->shape,
                          sizeof(size_t)*varp->ndims);
	    modedges[0] = NC_get_numrecs(nc3);
	    edges = modedges;
	} else
	    edges = varp->shape;
    }

    status = NCcoordck(nc3, varp, start);
    if(status != NC_NOERR)
        return status;
    status = NCedgeck(nc3, varp, start, edges);
    if(status != NC_NOERR)
        return status;

    if(varp->ndims == 0) /* scalar variable */
    {
        return( writeNCv(nc3, varp, start, 1, (void*)value, memtype) );
    }

    if(IS_RECVAR(varp))
    {
        status = NCvnrecs(nc3, *start + *edges);
        if(status != NC_NOERR)
            return status;

        if(varp->ndims == 1
            && nc3->recsize <= varp->len)
        {
            /* one dimensional && the only record variable  */
            return( writeNCv(nc3, varp, start, *edges, (void*)value, memtype) );
        }
    }

    /*
     * find max contiguous
     *   and accumulate max count for a single io operation
     */
    ii = NCiocount(nc3, varp, edges, &iocount);

    if(ii == -1)
    {
        return( writeNCv(nc3, varp, start, iocount, (void*)value, memtype) );
    }

    assert(ii >= 0);

    { /* inline */
    ALLOC_ONSTACK(coord, size_t, varp->ndims);
    ALLOC_ONSTACK(upper, size_t, varp->ndims);
    const size_t index = ii;

    /* copy in starting indices */
    (void) memcpy(coord, start, varp->ndims * sizeof(size_t));

    /* set up in maximum indices */
    set_upper(upper, start, edges, &upper[varp->ndims]);

    /* ripple counter */
    while(*coord < *upper)
    {
        const int lstatus = writeNCv(nc3, varp, coord, iocount, (void*)value, memtype);
        if(lstatus != NC_NOERR)
        {
            if(lstatus != NC_ERANGE)
            {
                status = lstatus;
                /* fatal for the loop */
                break;
            }
            /* else NC_ERANGE, not fatal for the loop */
            if(status == NC_NOERR)
                status = lstatus;
        }
        value += (iocount * memtypelen);
        odo1(start, upper, coord, &upper[index], &coord[index]);
    }

    FREE_ONSTACK(upper);
    FREE_ONSTACK(coord);
    } /* end inline */

    return status;
}
